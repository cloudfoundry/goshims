// Code generated by counterfeiter. DO NOT EDIT.
package syscall_fake

import (
	"sync"

	"code.cloudfoundry.org/goshims/syscallshim"
)

type FakeSyscall struct {
	BpfStmtStub        func(code, k int) *syscall.BpfInsn
	bpfStmtMutex       sync.RWMutex
	bpfStmtArgsForCall []struct {
		code int
		k    int
	}
	bpfStmtReturns struct {
		result1 *syscall.BpfInsn
	}
	bpfStmtReturnsOnCall map[int]struct {
		result1 *syscall.BpfInsn
	}
	BpfJumpStub        func(code, k, jt, jf int) *syscall.BpfInsn
	bpfJumpMutex       sync.RWMutex
	bpfJumpArgsForCall []struct {
		code int
		k    int
		jt   int
		jf   int
	}
	bpfJumpReturns struct {
		result1 *syscall.BpfInsn
	}
	bpfJumpReturnsOnCall map[int]struct {
		result1 *syscall.BpfInsn
	}
	BpfBuflenStub        func(fd int) (int, error)
	bpfBuflenMutex       sync.RWMutex
	bpfBuflenArgsForCall []struct {
		fd int
	}
	bpfBuflenReturns struct {
		result1 int
		result2 error
	}
	bpfBuflenReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SetBpfBuflenStub        func(fd, l int) (int, error)
	setBpfBuflenMutex       sync.RWMutex
	setBpfBuflenArgsForCall []struct {
		fd int
		l  int
	}
	setBpfBuflenReturns struct {
		result1 int
		result2 error
	}
	setBpfBuflenReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	BpfDatalinkStub        func(fd int) (int, error)
	bpfDatalinkMutex       sync.RWMutex
	bpfDatalinkArgsForCall []struct {
		fd int
	}
	bpfDatalinkReturns struct {
		result1 int
		result2 error
	}
	bpfDatalinkReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SetBpfDatalinkStub        func(fd, t int) (int, error)
	setBpfDatalinkMutex       sync.RWMutex
	setBpfDatalinkArgsForCall []struct {
		fd int
		t  int
	}
	setBpfDatalinkReturns struct {
		result1 int
		result2 error
	}
	setBpfDatalinkReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SetBpfPromiscStub        func(fd, m int) error
	setBpfPromiscMutex       sync.RWMutex
	setBpfPromiscArgsForCall []struct {
		fd int
		m  int
	}
	setBpfPromiscReturns struct {
		result1 error
	}
	setBpfPromiscReturnsOnCall map[int]struct {
		result1 error
	}
	FlushBpfStub        func(fd int) error
	flushBpfMutex       sync.RWMutex
	flushBpfArgsForCall []struct {
		fd int
	}
	flushBpfReturns struct {
		result1 error
	}
	flushBpfReturnsOnCall map[int]struct {
		result1 error
	}
	BpfInterfaceStub        func(fd int, name string) (string, error)
	bpfInterfaceMutex       sync.RWMutex
	bpfInterfaceArgsForCall []struct {
		fd   int
		name string
	}
	bpfInterfaceReturns struct {
		result1 string
		result2 error
	}
	bpfInterfaceReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SetBpfInterfaceStub        func(fd int, name string) error
	setBpfInterfaceMutex       sync.RWMutex
	setBpfInterfaceArgsForCall []struct {
		fd   int
		name string
	}
	setBpfInterfaceReturns struct {
		result1 error
	}
	setBpfInterfaceReturnsOnCall map[int]struct {
		result1 error
	}
	BpfTimeoutStub        func(fd int) (*syscall.Timeval, error)
	bpfTimeoutMutex       sync.RWMutex
	bpfTimeoutArgsForCall []struct {
		fd int
	}
	bpfTimeoutReturns struct {
		result1 *syscall.Timeval
		result2 error
	}
	bpfTimeoutReturnsOnCall map[int]struct {
		result1 *syscall.Timeval
		result2 error
	}
	SetBpfTimeoutStub        func(fd int, tv *syscall.Timeval) error
	setBpfTimeoutMutex       sync.RWMutex
	setBpfTimeoutArgsForCall []struct {
		fd int
		tv *syscall.Timeval
	}
	setBpfTimeoutReturns struct {
		result1 error
	}
	setBpfTimeoutReturnsOnCall map[int]struct {
		result1 error
	}
	BpfStatsStub        func(fd int) (*syscall.BpfStat, error)
	bpfStatsMutex       sync.RWMutex
	bpfStatsArgsForCall []struct {
		fd int
	}
	bpfStatsReturns struct {
		result1 *syscall.BpfStat
		result2 error
	}
	bpfStatsReturnsOnCall map[int]struct {
		result1 *syscall.BpfStat
		result2 error
	}
	SetBpfImmediateStub        func(fd, m int) error
	setBpfImmediateMutex       sync.RWMutex
	setBpfImmediateArgsForCall []struct {
		fd int
		m  int
	}
	setBpfImmediateReturns struct {
		result1 error
	}
	setBpfImmediateReturnsOnCall map[int]struct {
		result1 error
	}
	SetBpfStub        func(fd int, i []syscall.BpfInsn) error
	setBpfMutex       sync.RWMutex
	setBpfArgsForCall []struct {
		fd int
		i  []syscall.BpfInsn
	}
	setBpfReturns struct {
		result1 error
	}
	setBpfReturnsOnCall map[int]struct {
		result1 error
	}
	CheckBpfVersionStub        func(fd int) error
	checkBpfVersionMutex       sync.RWMutex
	checkBpfVersionArgsForCall []struct {
		fd int
	}
	checkBpfVersionReturns struct {
		result1 error
	}
	checkBpfVersionReturnsOnCall map[int]struct {
		result1 error
	}
	BpfHeadercmplStub        func(fd int) (int, error)
	bpfHeadercmplMutex       sync.RWMutex
	bpfHeadercmplArgsForCall []struct {
		fd int
	}
	bpfHeadercmplReturns struct {
		result1 int
		result2 error
	}
	bpfHeadercmplReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SetBpfHeadercmplStub        func(fd, f int) error
	setBpfHeadercmplMutex       sync.RWMutex
	setBpfHeadercmplArgsForCall []struct {
		fd int
		f  int
	}
	setBpfHeadercmplReturns struct {
		result1 error
	}
	setBpfHeadercmplReturnsOnCall map[int]struct {
		result1 error
	}
	UnmarshalDirStub        func(b []byte) (*syscall.Dir, error)
	unmarshalDirMutex       sync.RWMutex
	unmarshalDirArgsForCall []struct {
		b []byte
	}
	unmarshalDirReturns struct {
		result1 *syscall.Dir
		result2 error
	}
	unmarshalDirReturnsOnCall map[int]struct {
		result1 *syscall.Dir
		result2 error
	}
	ParseDirentStub        func(buf []byte, max int, names []string) (consumed int, count int, newnames []string)
	parseDirentMutex       sync.RWMutex
	parseDirentArgsForCall []struct {
		buf   []byte
		max   int
		names []string
	}
	parseDirentReturns struct {
		result1 int
		result2 int
		result3 []string
	}
	parseDirentReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 []string
	}
	SyscallStub        func(trap, nargs, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno)
	syscallMutex       sync.RWMutex
	syscallArgsForCall []struct {
		trap  uintptr
		nargs uintptr
		a1    uintptr
		a2    uintptr
		a3    uintptr
	}
	syscallReturns struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	syscallReturnsOnCall map[int]struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	Syscall6Stub        func(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)
	syscall6Mutex       sync.RWMutex
	syscall6ArgsForCall []struct {
		trap  uintptr
		nargs uintptr
		a1    uintptr
		a2    uintptr
		a3    uintptr
		a4    uintptr
		a5    uintptr
		a6    uintptr
	}
	syscall6Returns struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	syscall6ReturnsOnCall map[int]struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	Syscall9Stub        func(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)
	syscall9Mutex       sync.RWMutex
	syscall9ArgsForCall []struct {
		trap  uintptr
		nargs uintptr
		a1    uintptr
		a2    uintptr
		a3    uintptr
		a4    uintptr
		a5    uintptr
		a6    uintptr
		a7    uintptr
		a8    uintptr
		a9    uintptr
	}
	syscall9Returns struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	syscall9ReturnsOnCall map[int]struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	Syscall12Stub        func(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 uintptr) (r1, r2 uintptr, err syscall.Errno)
	syscall12Mutex       sync.RWMutex
	syscall12ArgsForCall []struct {
		trap  uintptr
		nargs uintptr
		a1    uintptr
		a2    uintptr
		a3    uintptr
		a4    uintptr
		a5    uintptr
		a6    uintptr
		a7    uintptr
		a8    uintptr
		a9    uintptr
		a10   uintptr
		a11   uintptr
		a12   uintptr
	}
	syscall12Returns struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	syscall12ReturnsOnCall map[int]struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	Syscall15Stub        func(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 uintptr) (r1, r2 uintptr, err syscall.Errno)
	syscall15Mutex       sync.RWMutex
	syscall15ArgsForCall []struct {
		trap  uintptr
		nargs uintptr
		a1    uintptr
		a2    uintptr
		a3    uintptr
		a4    uintptr
		a5    uintptr
		a6    uintptr
		a7    uintptr
		a8    uintptr
		a9    uintptr
		a10   uintptr
		a11   uintptr
		a12   uintptr
		a13   uintptr
		a14   uintptr
		a15   uintptr
	}
	syscall15Returns struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	syscall15ReturnsOnCall map[int]struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	LoadDLLStub        func(name string) (*syscall.DLL, error)
	loadDLLMutex       sync.RWMutex
	loadDLLArgsForCall []struct {
		name string
	}
	loadDLLReturns struct {
		result1 *syscall.DLL
		result2 error
	}
	loadDLLReturnsOnCall map[int]struct {
		result1 *syscall.DLL
		result2 error
	}
	MustLoadDLLStub        func(name string) *syscall.DLL
	mustLoadDLLMutex       sync.RWMutex
	mustLoadDLLArgsForCall []struct {
		name string
	}
	mustLoadDLLReturns struct {
		result1 *syscall.DLL
	}
	mustLoadDLLReturnsOnCall map[int]struct {
		result1 *syscall.DLL
	}
	NewLazyDLLStub        func(name string) *syscall.LazyDLL
	newLazyDLLMutex       sync.RWMutex
	newLazyDLLArgsForCall []struct {
		name string
	}
	newLazyDLLReturns struct {
		result1 *syscall.LazyDLL
	}
	newLazyDLLReturnsOnCall map[int]struct {
		result1 *syscall.LazyDLL
	}
	GetenvStub        func(key string) (value string, found bool)
	getenvMutex       sync.RWMutex
	getenvArgsForCall []struct {
		key string
	}
	getenvReturns struct {
		result1 string
		result2 bool
	}
	getenvReturnsOnCall map[int]struct {
		result1 string
		result2 bool
	}
	SetenvStub        func(key, value string) error
	setenvMutex       sync.RWMutex
	setenvArgsForCall []struct {
		key   string
		value string
	}
	setenvReturns struct {
		result1 error
	}
	setenvReturnsOnCall map[int]struct {
		result1 error
	}
	ClearenvStub        func()
	clearenvMutex       sync.RWMutex
	clearenvArgsForCall []struct{}
	UnsetenvStub        func(key string) error
	unsetenvMutex       sync.RWMutex
	unsetenvArgsForCall []struct {
		key string
	}
	unsetenvReturns struct {
		result1 error
	}
	unsetenvReturnsOnCall map[int]struct {
		result1 error
	}
	EnvironStub        func() []string
	environMutex       sync.RWMutex
	environArgsForCall []struct{}
	environReturns     struct {
		result1 []string
	}
	environReturnsOnCall map[int]struct {
		result1 []string
	}
	StringSlicePtrStub        func(ss []string) []*byte
	stringSlicePtrMutex       sync.RWMutex
	stringSlicePtrArgsForCall []struct {
		ss []string
	}
	stringSlicePtrReturns struct {
		result1 []*byte
	}
	stringSlicePtrReturnsOnCall map[int]struct {
		result1 []*byte
	}
	SlicePtrFromStringsStub        func(ss []string) ([]*byte, error)
	slicePtrFromStringsMutex       sync.RWMutex
	slicePtrFromStringsArgsForCall []struct {
		ss []string
	}
	slicePtrFromStringsReturns struct {
		result1 []*byte
		result2 error
	}
	slicePtrFromStringsReturnsOnCall map[int]struct {
		result1 []*byte
		result2 error
	}
	ForkExecStub        func(argv0 string, argv []string, attr *syscall.ProcAttr) (pid int, err error)
	forkExecMutex       sync.RWMutex
	forkExecArgsForCall []struct {
		argv0 string
		argv  []string
		attr  *syscall.ProcAttr
	}
	forkExecReturns struct {
		result1 int
		result2 error
	}
	forkExecReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	StartProcessStub        func(argv0 string, argv []string, attr *syscall.ProcAttr) (pid int, handle uintptr, err error)
	startProcessMutex       sync.RWMutex
	startProcessArgsForCall []struct {
		argv0 string
		argv  []string
		attr  *syscall.ProcAttr
	}
	startProcessReturns struct {
		result1 int
		result2 uintptr
		result3 error
	}
	startProcessReturnsOnCall map[int]struct {
		result1 int
		result2 uintptr
		result3 error
	}
	ExecStub        func(argv0 string, argv []string, envv []string) (err error)
	execMutex       sync.RWMutex
	execArgsForCall []struct {
		argv0 string
		argv  []string
		envv  []string
	}
	execReturns struct {
		result1 error
	}
	execReturnsOnCall map[int]struct {
		result1 error
	}
	WaitProcessStub        func(pid int, w *syscall.Waitmsg) (err error)
	waitProcessMutex       sync.RWMutex
	waitProcessArgsForCall []struct {
		pid int
		w   *syscall.Waitmsg
	}
	waitProcessReturns struct {
		result1 error
	}
	waitProcessReturnsOnCall map[int]struct {
		result1 error
	}
	CloseOnExecStub        func(fd int)
	closeOnExecMutex       sync.RWMutex
	closeOnExecArgsForCall []struct {
		fd int
	}
	SetNonblockStub        func(fd int, nonblocking bool) (err error)
	setNonblockMutex       sync.RWMutex
	setNonblockArgsForCall []struct {
		fd          int
		nonblocking bool
	}
	setNonblockReturns struct {
		result1 error
	}
	setNonblockReturnsOnCall map[int]struct {
		result1 error
	}
	EscapeArgStub        func(s string) string
	escapeArgMutex       sync.RWMutex
	escapeArgArgsForCall []struct {
		s string
	}
	escapeArgReturns struct {
		result1 string
	}
	escapeArgReturnsOnCall map[int]struct {
		result1 string
	}
	FullPathStub        func(name string) (path string, err error)
	fullPathMutex       sync.RWMutex
	fullPathArgsForCall []struct {
		name string
	}
	fullPathReturns struct {
		result1 string
		result2 error
	}
	fullPathReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CloseStub        func(fd int) error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
		fd int
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	DupStub        func(fd int) (int, error)
	dupMutex       sync.RWMutex
	dupArgsForCall []struct {
		fd int
	}
	dupReturns struct {
		result1 int
		result2 error
	}
	dupReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	Dup2Stub        func(fd, newfd int) error
	dup2Mutex       sync.RWMutex
	dup2ArgsForCall []struct {
		fd    int
		newfd int
	}
	dup2Returns struct {
		result1 error
	}
	dup2ReturnsOnCall map[int]struct {
		result1 error
	}
	FstatStub        func(fd int, st *syscall.Stat_t) error
	fstatMutex       sync.RWMutex
	fstatArgsForCall []struct {
		fd int
		st *syscall.Stat_t
	}
	fstatReturns struct {
		result1 error
	}
	fstatReturnsOnCall map[int]struct {
		result1 error
	}
	ReadStub        func(fd int, b []byte) (int, error)
	readMutex       sync.RWMutex
	readArgsForCall []struct {
		fd int
		b  []byte
	}
	readReturns struct {
		result1 int
		result2 error
	}
	readReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	WriteStub        func(fd int, b []byte) (int, error)
	writeMutex       sync.RWMutex
	writeArgsForCall []struct {
		fd int
		b  []byte
	}
	writeReturns struct {
		result1 int
		result2 error
	}
	writeReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	PreadStub        func(fd int, b []byte, offset int64) (int, error)
	preadMutex       sync.RWMutex
	preadArgsForCall []struct {
		fd     int
		b      []byte
		offset int64
	}
	preadReturns struct {
		result1 int
		result2 error
	}
	preadReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	PwriteStub        func(fd int, b []byte, offset int64) (int, error)
	pwriteMutex       sync.RWMutex
	pwriteArgsForCall []struct {
		fd     int
		b      []byte
		offset int64
	}
	pwriteReturns struct {
		result1 int
		result2 error
	}
	pwriteReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SeekStub        func(fd int, offset int64, whence int) (int64, error)
	seekMutex       sync.RWMutex
	seekArgsForCall []struct {
		fd     int
		offset int64
		whence int
	}
	seekReturns struct {
		result1 int64
		result2 error
	}
	seekReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	PipeStub        func(fd []int) error
	pipeMutex       sync.RWMutex
	pipeArgsForCall []struct {
		fd []int
	}
	pipeReturns struct {
		result1 error
	}
	pipeReturnsOnCall map[int]struct {
		result1 error
	}
	FcntlFlockStub        func(fd uintptr, cmd int, lk *syscall.Flock_t) error
	fcntlFlockMutex       sync.RWMutex
	fcntlFlockArgsForCall []struct {
		fd  uintptr
		cmd int
		lk  *syscall.Flock_t
	}
	fcntlFlockReturns struct {
		result1 error
	}
	fcntlFlockReturnsOnCall map[int]struct {
		result1 error
	}
	ReadDirentStub        func(fd int, buf []byte) (int, error)
	readDirentMutex       sync.RWMutex
	readDirentArgsForCall []struct {
		fd  int
		buf []byte
	}
	readDirentReturns struct {
		result1 int
		result2 error
	}
	readDirentReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	OpenStub        func(path string, openmode int, perm uint32) (fd int, err error)
	openMutex       sync.RWMutex
	openArgsForCall []struct {
		path     string
		openmode int
		perm     uint32
	}
	openReturns struct {
		result1 int
		result2 error
	}
	openReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	MkdirStub        func(path string, perm uint32) error
	mkdirMutex       sync.RWMutex
	mkdirArgsForCall []struct {
		path string
		perm uint32
	}
	mkdirReturns struct {
		result1 error
	}
	mkdirReturnsOnCall map[int]struct {
		result1 error
	}
	GetcwdStub        func(buf []byte) (n int, err error)
	getcwdMutex       sync.RWMutex
	getcwdArgsForCall []struct {
		buf []byte
	}
	getcwdReturns struct {
		result1 int
		result2 error
	}
	getcwdReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	StatStub        func(path string, st *syscall.Stat_t) error
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		path string
		st   *syscall.Stat_t
	}
	statReturns struct {
		result1 error
	}
	statReturnsOnCall map[int]struct {
		result1 error
	}
	LstatStub        func(path string, st *syscall.Stat_t) error
	lstatMutex       sync.RWMutex
	lstatArgsForCall []struct {
		path string
		st   *syscall.Stat_t
	}
	lstatReturns struct {
		result1 error
	}
	lstatReturnsOnCall map[int]struct {
		result1 error
	}
	UnlinkStub        func(path string) error
	unlinkMutex       sync.RWMutex
	unlinkArgsForCall []struct {
		path string
	}
	unlinkReturns struct {
		result1 error
	}
	unlinkReturnsOnCall map[int]struct {
		result1 error
	}
	RmdirStub        func(path string) error
	rmdirMutex       sync.RWMutex
	rmdirArgsForCall []struct {
		path string
	}
	rmdirReturns struct {
		result1 error
	}
	rmdirReturnsOnCall map[int]struct {
		result1 error
	}
	ChmodStub        func(path string, mode uint32) error
	chmodMutex       sync.RWMutex
	chmodArgsForCall []struct {
		path string
		mode uint32
	}
	chmodReturns struct {
		result1 error
	}
	chmodReturnsOnCall map[int]struct {
		result1 error
	}
	FchmodStub        func(fd int, mode uint32) error
	fchmodMutex       sync.RWMutex
	fchmodArgsForCall []struct {
		fd   int
		mode uint32
	}
	fchmodReturns struct {
		result1 error
	}
	fchmodReturnsOnCall map[int]struct {
		result1 error
	}
	ChownStub        func(path string, uid, gid int) error
	chownMutex       sync.RWMutex
	chownArgsForCall []struct {
		path string
		uid  int
		gid  int
	}
	chownReturns struct {
		result1 error
	}
	chownReturnsOnCall map[int]struct {
		result1 error
	}
	FchownStub        func(fd int, uid, gid int) error
	fchownMutex       sync.RWMutex
	fchownArgsForCall []struct {
		fd  int
		uid int
		gid int
	}
	fchownReturns struct {
		result1 error
	}
	fchownReturnsOnCall map[int]struct {
		result1 error
	}
	LchownStub        func(path string, uid, gid int) error
	lchownMutex       sync.RWMutex
	lchownArgsForCall []struct {
		path string
		uid  int
		gid  int
	}
	lchownReturns struct {
		result1 error
	}
	lchownReturnsOnCall map[int]struct {
		result1 error
	}
	UtimesNanoStub        func(path string, ts []syscall.Timespec) error
	utimesNanoMutex       sync.RWMutex
	utimesNanoArgsForCall []struct {
		path string
		ts   []syscall.Timespec
	}
	utimesNanoReturns struct {
		result1 error
	}
	utimesNanoReturnsOnCall map[int]struct {
		result1 error
	}
	LinkStub        func(path, link string) error
	linkMutex       sync.RWMutex
	linkArgsForCall []struct {
		path string
		link string
	}
	linkReturns struct {
		result1 error
	}
	linkReturnsOnCall map[int]struct {
		result1 error
	}
	RenameStub        func(from, to string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		from string
		to   string
	}
	renameReturns struct {
		result1 error
	}
	renameReturnsOnCall map[int]struct {
		result1 error
	}
	TruncateStub        func(path string, length int64) error
	truncateMutex       sync.RWMutex
	truncateArgsForCall []struct {
		path   string
		length int64
	}
	truncateReturns struct {
		result1 error
	}
	truncateReturnsOnCall map[int]struct {
		result1 error
	}
	FtruncateStub        func(fd int, length int64) error
	ftruncateMutex       sync.RWMutex
	ftruncateArgsForCall []struct {
		fd     int
		length int64
	}
	ftruncateReturns struct {
		result1 error
	}
	ftruncateReturnsOnCall map[int]struct {
		result1 error
	}
	ChdirStub        func(path string) error
	chdirMutex       sync.RWMutex
	chdirArgsForCall []struct {
		path string
	}
	chdirReturns struct {
		result1 error
	}
	chdirReturnsOnCall map[int]struct {
		result1 error
	}
	FchdirStub        func(fd int) error
	fchdirMutex       sync.RWMutex
	fchdirArgsForCall []struct {
		fd int
	}
	fchdirReturns struct {
		result1 error
	}
	fchdirReturnsOnCall map[int]struct {
		result1 error
	}
	ReadlinkStub        func(path string, buf []byte) (n int, err error)
	readlinkMutex       sync.RWMutex
	readlinkArgsForCall []struct {
		path string
		buf  []byte
	}
	readlinkReturns struct {
		result1 int
		result2 error
	}
	readlinkReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SymlinkStub        func(path, link string) error
	symlinkMutex       sync.RWMutex
	symlinkArgsForCall []struct {
		path string
		link string
	}
	symlinkReturns struct {
		result1 error
	}
	symlinkReturnsOnCall map[int]struct {
		result1 error
	}
	FsyncStub        func(fd int) error
	fsyncMutex       sync.RWMutex
	fsyncArgsForCall []struct {
		fd int
	}
	fsyncReturns struct {
		result1 error
	}
	fsyncReturnsOnCall map[int]struct {
		result1 error
	}
	LsfStmtStub        func(code, k int) *syscall.SockFilter
	lsfStmtMutex       sync.RWMutex
	lsfStmtArgsForCall []struct {
		code int
		k    int
	}
	lsfStmtReturns struct {
		result1 *syscall.SockFilter
	}
	lsfStmtReturnsOnCall map[int]struct {
		result1 *syscall.SockFilter
	}
	LsfJumpStub        func(code, k, jt, jf int) *syscall.SockFilter
	lsfJumpMutex       sync.RWMutex
	lsfJumpArgsForCall []struct {
		code int
		k    int
		jt   int
		jf   int
	}
	lsfJumpReturns struct {
		result1 *syscall.SockFilter
	}
	lsfJumpReturnsOnCall map[int]struct {
		result1 *syscall.SockFilter
	}
	LsfSocketStub        func(ifindex, proto int) (int, error)
	lsfSocketMutex       sync.RWMutex
	lsfSocketArgsForCall []struct {
		ifindex int
		proto   int
	}
	lsfSocketReturns struct {
		result1 int
		result2 error
	}
	lsfSocketReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SetLsfPromiscStub        func(name string, m bool) error
	setLsfPromiscMutex       sync.RWMutex
	setLsfPromiscArgsForCall []struct {
		name string
		m    bool
	}
	setLsfPromiscReturns struct {
		result1 error
	}
	setLsfPromiscReturnsOnCall map[int]struct {
		result1 error
	}
	AttachLsfStub        func(fd int, i []syscall.SockFilter) error
	attachLsfMutex       sync.RWMutex
	attachLsfArgsForCall []struct {
		fd int
		i  []syscall.SockFilter
	}
	attachLsfReturns struct {
		result1 error
	}
	attachLsfReturnsOnCall map[int]struct {
		result1 error
	}
	DetachLsfStub        func(fd int) error
	detachLsfMutex       sync.RWMutex
	detachLsfArgsForCall []struct {
		fd int
	}
	detachLsfReturns struct {
		result1 error
	}
	detachLsfReturnsOnCall map[int]struct {
		result1 error
	}
	ParseFilesStub        func(fs []string) (*Source, error)
	parseFilesMutex       sync.RWMutex
	parseFilesArgsForCall []struct {
		fs []string
	}
	parseFilesReturns struct {
		result1 *Source
		result2 error
	}
	parseFilesReturnsOnCall map[int]struct {
		result1 *Source
		result2 error
	}
	SocketStub        func(proto, sotype, unused int) (fd int, err error)
	socketMutex       sync.RWMutex
	socketArgsForCall []struct {
		proto  int
		sotype int
		unused int
	}
	socketReturns struct {
		result1 int
		result2 error
	}
	socketReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	BindStub        func(fd int, sa syscall.Sockaddr) error
	bindMutex       sync.RWMutex
	bindArgsForCall []struct {
		fd int
		sa syscall.Sockaddr
	}
	bindReturns struct {
		result1 error
	}
	bindReturnsOnCall map[int]struct {
		result1 error
	}
	StopIOStub        func(fd int) error
	stopIOMutex       sync.RWMutex
	stopIOArgsForCall []struct {
		fd int
	}
	stopIOReturns struct {
		result1 error
	}
	stopIOReturnsOnCall map[int]struct {
		result1 error
	}
	ListenStub        func(fd int, backlog int) error
	listenMutex       sync.RWMutex
	listenArgsForCall []struct {
		fd      int
		backlog int
	}
	listenReturns struct {
		result1 error
	}
	listenReturnsOnCall map[int]struct {
		result1 error
	}
	AcceptStub        func(fd int) (newfd int, sa syscall.Sockaddr, err error)
	acceptMutex       sync.RWMutex
	acceptArgsForCall []struct {
		fd int
	}
	acceptReturns struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}
	acceptReturnsOnCall map[int]struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}
	GetsocknameStub        func(fd int) (sa syscall.Sockaddr, err error)
	getsocknameMutex       sync.RWMutex
	getsocknameArgsForCall []struct {
		fd int
	}
	getsocknameReturns struct {
		result1 syscall.Sockaddr
		result2 error
	}
	getsocknameReturnsOnCall map[int]struct {
		result1 syscall.Sockaddr
		result2 error
	}
	GetpeernameStub        func(fd int) (sa syscall.Sockaddr, err error)
	getpeernameMutex       sync.RWMutex
	getpeernameArgsForCall []struct {
		fd int
	}
	getpeernameReturns struct {
		result1 syscall.Sockaddr
		result2 error
	}
	getpeernameReturnsOnCall map[int]struct {
		result1 syscall.Sockaddr
		result2 error
	}
	ConnectStub        func(fd int, sa syscall.Sockaddr) error
	connectMutex       sync.RWMutex
	connectArgsForCall []struct {
		fd int
		sa syscall.Sockaddr
	}
	connectReturns struct {
		result1 error
	}
	connectReturnsOnCall map[int]struct {
		result1 error
	}
	RecvfromStub        func(fd int, p []byte, flags int) (n int, from syscall.Sockaddr, err error)
	recvfromMutex       sync.RWMutex
	recvfromArgsForCall []struct {
		fd    int
		p     []byte
		flags int
	}
	recvfromReturns struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}
	recvfromReturnsOnCall map[int]struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}
	SendtoStub        func(fd int, p []byte, flags int, to syscall.Sockaddr) error
	sendtoMutex       sync.RWMutex
	sendtoArgsForCall []struct {
		fd    int
		p     []byte
		flags int
		to    syscall.Sockaddr
	}
	sendtoReturns struct {
		result1 error
	}
	sendtoReturnsOnCall map[int]struct {
		result1 error
	}
	RecvmsgStub        func(fd int, p, oob []byte, flags int) (n, oobn, recvflags int, from syscall.Sockaddr, err error)
	recvmsgMutex       sync.RWMutex
	recvmsgArgsForCall []struct {
		fd    int
		p     []byte
		oob   []byte
		flags int
	}
	recvmsgReturns struct {
		result1 int
		result2 int
		result3 int
		result4 syscall.Sockaddr
		result5 error
	}
	recvmsgReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 int
		result4 syscall.Sockaddr
		result5 error
	}
	SendmsgStub        func(fd int, p, oob []byte, to syscall.Sockaddr, flags int) error
	sendmsgMutex       sync.RWMutex
	sendmsgArgsForCall []struct {
		fd    int
		p     []byte
		oob   []byte
		to    syscall.Sockaddr
		flags int
	}
	sendmsgReturns struct {
		result1 error
	}
	sendmsgReturnsOnCall map[int]struct {
		result1 error
	}
	SendmsgNStub        func(fd int, p, oob []byte, to syscall.Sockaddr, flags int) (n int, err error)
	sendmsgNMutex       sync.RWMutex
	sendmsgNArgsForCall []struct {
		fd    int
		p     []byte
		oob   []byte
		to    syscall.Sockaddr
		flags int
	}
	sendmsgNReturns struct {
		result1 int
		result2 error
	}
	sendmsgNReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetsockoptIntStub        func(fd, level, opt int) (value int, err error)
	getsockoptIntMutex       sync.RWMutex
	getsockoptIntArgsForCall []struct {
		fd    int
		level int
		opt   int
	}
	getsockoptIntReturns struct {
		result1 int
		result2 error
	}
	getsockoptIntReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SetsockoptIntStub        func(fd, level, opt int, value int) error
	setsockoptIntMutex       sync.RWMutex
	setsockoptIntArgsForCall []struct {
		fd    int
		level int
		opt   int
		value int
	}
	setsockoptIntReturns struct {
		result1 error
	}
	setsockoptIntReturnsOnCall map[int]struct {
		result1 error
	}
	SetsockoptByteStub        func(fd, level, opt int, value byte) error
	setsockoptByteMutex       sync.RWMutex
	setsockoptByteArgsForCall []struct {
		fd    int
		level int
		opt   int
		value byte
	}
	setsockoptByteReturns struct {
		result1 error
	}
	setsockoptByteReturnsOnCall map[int]struct {
		result1 error
	}
	SetsockoptLingerStub        func(fd, level, opt int, l *syscall.Linger) error
	setsockoptLingerMutex       sync.RWMutex
	setsockoptLingerArgsForCall []struct {
		fd    int
		level int
		opt   int
		l     *syscall.Linger
	}
	setsockoptLingerReturns struct {
		result1 error
	}
	setsockoptLingerReturnsOnCall map[int]struct {
		result1 error
	}
	SetReadDeadlineStub        func(fd int, t int64) error
	setReadDeadlineMutex       sync.RWMutex
	setReadDeadlineArgsForCall []struct {
		fd int
		t  int64
	}
	setReadDeadlineReturns struct {
		result1 error
	}
	setReadDeadlineReturnsOnCall map[int]struct {
		result1 error
	}
	SetWriteDeadlineStub        func(fd int, t int64) error
	setWriteDeadlineMutex       sync.RWMutex
	setWriteDeadlineArgsForCall []struct {
		fd int
		t  int64
	}
	setWriteDeadlineReturns struct {
		result1 error
	}
	setWriteDeadlineReturnsOnCall map[int]struct {
		result1 error
	}
	ShutdownStub        func(fd int, how int) error
	shutdownMutex       sync.RWMutex
	shutdownArgsForCall []struct {
		fd  int
		how int
	}
	shutdownReturns struct {
		result1 error
	}
	shutdownReturnsOnCall map[int]struct {
		result1 error
	}
	SetsockoptICMPv6FilterStub        func(fd, level, opt int, filter *syscall.ICMPv6Filter) error
	setsockoptICMPv6FilterMutex       sync.RWMutex
	setsockoptICMPv6FilterArgsForCall []struct {
		fd     int
		level  int
		opt    int
		filter *syscall.ICMPv6Filter
	}
	setsockoptICMPv6FilterReturns struct {
		result1 error
	}
	setsockoptICMPv6FilterReturnsOnCall map[int]struct {
		result1 error
	}
	SetsockoptIPMreqStub        func(fd, level, opt int, mreq *syscall.IPMreq) error
	setsockoptIPMreqMutex       sync.RWMutex
	setsockoptIPMreqArgsForCall []struct {
		fd    int
		level int
		opt   int
		mreq  *syscall.IPMreq
	}
	setsockoptIPMreqReturns struct {
		result1 error
	}
	setsockoptIPMreqReturnsOnCall map[int]struct {
		result1 error
	}
	SetsockoptIPv6MreqStub        func(fd, level, opt int, mreq *syscall.IPv6Mreq) error
	setsockoptIPv6MreqMutex       sync.RWMutex
	setsockoptIPv6MreqArgsForCall []struct {
		fd    int
		level int
		opt   int
		mreq  *syscall.IPv6Mreq
	}
	setsockoptIPv6MreqReturns struct {
		result1 error
	}
	setsockoptIPv6MreqReturnsOnCall map[int]struct {
		result1 error
	}
	SetsockoptInet4AddrStub        func(fd, level, opt int, value [4]byte) error
	setsockoptInet4AddrMutex       sync.RWMutex
	setsockoptInet4AddrArgsForCall []struct {
		fd    int
		level int
		opt   int
		value [4]byte
	}
	setsockoptInet4AddrReturns struct {
		result1 error
	}
	setsockoptInet4AddrReturnsOnCall map[int]struct {
		result1 error
	}
	SetsockoptStringStub        func(fd, level, opt int, s string) error
	setsockoptStringMutex       sync.RWMutex
	setsockoptStringArgsForCall []struct {
		fd    int
		level int
		opt   int
		s     string
	}
	setsockoptStringReturns struct {
		result1 error
	}
	setsockoptStringReturnsOnCall map[int]struct {
		result1 error
	}
	SetsockoptTimevalStub        func(fd, level, opt int, tv *syscall.Timeval) error
	setsockoptTimevalMutex       sync.RWMutex
	setsockoptTimevalArgsForCall []struct {
		fd    int
		level int
		opt   int
		tv    *syscall.Timeval
	}
	setsockoptTimevalReturns struct {
		result1 error
	}
	setsockoptTimevalReturnsOnCall map[int]struct {
		result1 error
	}
	SocketpairStub        func(domain, typ, proto int) (fd [2]int, err error)
	socketpairMutex       sync.RWMutex
	socketpairArgsForCall []struct {
		domain int
		typ    int
		proto  int
	}
	socketpairReturns struct {
		result1 [2]int
		result2 error
	}
	socketpairReturnsOnCall map[int]struct {
		result1 [2]int
		result2 error
	}
	NetlinkRIBStub        func(proto, family int) ([]byte, error)
	netlinkRIBMutex       sync.RWMutex
	netlinkRIBArgsForCall []struct {
		proto  int
		family int
	}
	netlinkRIBReturns struct {
		result1 []byte
		result2 error
	}
	netlinkRIBReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ParseNetlinkMessageStub        func(b []byte) ([]syscall.NetlinkMessage, error)
	parseNetlinkMessageMutex       sync.RWMutex
	parseNetlinkMessageArgsForCall []struct {
		b []byte
	}
	parseNetlinkMessageReturns struct {
		result1 []syscall.NetlinkMessage
		result2 error
	}
	parseNetlinkMessageReturnsOnCall map[int]struct {
		result1 []syscall.NetlinkMessage
		result2 error
	}
	ParseNetlinkRouteAttrStub        func(m *syscall.NetlinkMessage) ([]syscall.NetlinkRouteAttr, error)
	parseNetlinkRouteAttrMutex       sync.RWMutex
	parseNetlinkRouteAttrArgsForCall []struct {
		m *syscall.NetlinkMessage
	}
	parseNetlinkRouteAttrReturns struct {
		result1 []syscall.NetlinkRouteAttr
		result2 error
	}
	parseNetlinkRouteAttrReturnsOnCall map[int]struct {
		result1 []syscall.NetlinkRouteAttr
		result2 error
	}
	FixwdStub        func()
	fixwdMutex       sync.RWMutex
	fixwdArgsForCall []struct{}
	GetwdStub        func() (wd string, err error)
	getwdMutex       sync.RWMutex
	getwdArgsForCall []struct{}
	getwdReturns     struct {
		result1 string
		result2 error
	}
	getwdReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RouteRIBStub        func(facility, param int) ([]byte, error)
	routeRIBMutex       sync.RWMutex
	routeRIBArgsForCall []struct {
		facility int
		param    int
	}
	routeRIBReturns struct {
		result1 []byte
		result2 error
	}
	routeRIBReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ParseRoutingMessageStub        func(b []byte) (msgs []syscall.RoutingMessage, err error)
	parseRoutingMessageMutex       sync.RWMutex
	parseRoutingMessageArgsForCall []struct {
		b []byte
	}
	parseRoutingMessageReturns struct {
		result1 []syscall.RoutingMessage
		result2 error
	}
	parseRoutingMessageReturnsOnCall map[int]struct {
		result1 []syscall.RoutingMessage
		result2 error
	}
	ParseRoutingSockaddrStub        func(msg syscall.RoutingMessage) ([]syscall.Sockaddr, error)
	parseRoutingSockaddrMutex       sync.RWMutex
	parseRoutingSockaddrArgsForCall []struct {
		msg syscall.RoutingMessage
	}
	parseRoutingSockaddrReturns struct {
		result1 []syscall.Sockaddr
		result2 error
	}
	parseRoutingSockaddrReturnsOnCall map[int]struct {
		result1 []syscall.Sockaddr
		result2 error
	}
	TranslateAccountNameStub        func(username string, from, to uint32, initSize int) (string, error)
	translateAccountNameMutex       sync.RWMutex
	translateAccountNameArgsForCall []struct {
		username string
		from     uint32
		to       uint32
		initSize int
	}
	translateAccountNameReturns struct {
		result1 string
		result2 error
	}
	translateAccountNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	StringToSidStub        func(s string) (*syscall.SID, error)
	stringToSidMutex       sync.RWMutex
	stringToSidArgsForCall []struct {
		s string
	}
	stringToSidReturns struct {
		result1 *syscall.SID
		result2 error
	}
	stringToSidReturnsOnCall map[int]struct {
		result1 *syscall.SID
		result2 error
	}
	LookupSIDStub        func(system, account string) (sid *syscall.SID, domain string, accType uint32, err error)
	lookupSIDMutex       sync.RWMutex
	lookupSIDArgsForCall []struct {
		system  string
		account string
	}
	lookupSIDReturns struct {
		result1 *syscall.SID
		result2 string
		result3 uint32
		result4 error
	}
	lookupSIDReturnsOnCall map[int]struct {
		result1 *syscall.SID
		result2 string
		result3 uint32
		result4 error
	}
	OpenCurrentProcessTokenStub        func() (syscall.Token, error)
	openCurrentProcessTokenMutex       sync.RWMutex
	openCurrentProcessTokenArgsForCall []struct{}
	openCurrentProcessTokenReturns     struct {
		result1 syscall.Token
		result2 error
	}
	openCurrentProcessTokenReturnsOnCall map[int]struct {
		result1 syscall.Token
		result2 error
	}
	UnixCredentialsStub        func(ucred *syscall.Ucred) []byte
	unixCredentialsMutex       sync.RWMutex
	unixCredentialsArgsForCall []struct {
		ucred *syscall.Ucred
	}
	unixCredentialsReturns struct {
		result1 []byte
	}
	unixCredentialsReturnsOnCall map[int]struct {
		result1 []byte
	}
	ParseUnixCredentialsStub        func(m *syscall.SocketControlMessage) (*syscall.Ucred, error)
	parseUnixCredentialsMutex       sync.RWMutex
	parseUnixCredentialsArgsForCall []struct {
		m *syscall.SocketControlMessage
	}
	parseUnixCredentialsReturns struct {
		result1 *syscall.Ucred
		result2 error
	}
	parseUnixCredentialsReturnsOnCall map[int]struct {
		result1 *syscall.Ucred
		result2 error
	}
	CmsgLenStub        func(datalen int) int
	cmsgLenMutex       sync.RWMutex
	cmsgLenArgsForCall []struct {
		datalen int
	}
	cmsgLenReturns struct {
		result1 int
	}
	cmsgLenReturnsOnCall map[int]struct {
		result1 int
	}
	CmsgSpaceStub        func(datalen int) int
	cmsgSpaceMutex       sync.RWMutex
	cmsgSpaceArgsForCall []struct {
		datalen int
	}
	cmsgSpaceReturns struct {
		result1 int
	}
	cmsgSpaceReturnsOnCall map[int]struct {
		result1 int
	}
	ParseSocketControlMessageStub        func(b []byte) ([]syscall.SocketControlMessage, error)
	parseSocketControlMessageMutex       sync.RWMutex
	parseSocketControlMessageArgsForCall []struct {
		b []byte
	}
	parseSocketControlMessageReturns struct {
		result1 []syscall.SocketControlMessage
		result2 error
	}
	parseSocketControlMessageReturnsOnCall map[int]struct {
		result1 []syscall.SocketControlMessage
		result2 error
	}
	UnixRightsStub        func(fds ...int) []byte
	unixRightsMutex       sync.RWMutex
	unixRightsArgsForCall []struct {
		fds []int
	}
	unixRightsReturns struct {
		result1 []byte
	}
	unixRightsReturnsOnCall map[int]struct {
		result1 []byte
	}
	ParseUnixRightsStub        func(m *syscall.SocketControlMessage) ([]int, error)
	parseUnixRightsMutex       sync.RWMutex
	parseUnixRightsArgsForCall []struct {
		m *syscall.SocketControlMessage
	}
	parseUnixRightsReturns struct {
		result1 []int
		result2 error
	}
	parseUnixRightsReturnsOnCall map[int]struct {
		result1 []int
		result2 error
	}
	StringByteSliceStub        func(s string) []byte
	stringByteSliceMutex       sync.RWMutex
	stringByteSliceArgsForCall []struct {
		s string
	}
	stringByteSliceReturns struct {
		result1 []byte
	}
	stringByteSliceReturnsOnCall map[int]struct {
		result1 []byte
	}
	ByteSliceFromStringStub        func(s string) ([]byte, error)
	byteSliceFromStringMutex       sync.RWMutex
	byteSliceFromStringArgsForCall []struct {
		s string
	}
	byteSliceFromStringReturns struct {
		result1 []byte
		result2 error
	}
	byteSliceFromStringReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	StringBytePtrStub        func(s string) *byte
	stringBytePtrMutex       sync.RWMutex
	stringBytePtrArgsForCall []struct {
		s string
	}
	stringBytePtrReturns struct {
		result1 *byte
	}
	stringBytePtrReturnsOnCall map[int]struct {
		result1 *byte
	}
	BytePtrFromStringStub        func(s string) (*byte, error)
	bytePtrFromStringMutex       sync.RWMutex
	bytePtrFromStringArgsForCall []struct {
		s string
	}
	bytePtrFromStringReturns struct {
		result1 *byte
		result2 error
	}
	bytePtrFromStringReturnsOnCall map[int]struct {
		result1 *byte
		result2 error
	}
	GetpagesizeStub        func() int
	getpagesizeMutex       sync.RWMutex
	getpagesizeArgsForCall []struct{}
	getpagesizeReturns     struct {
		result1 int
	}
	getpagesizeReturnsOnCall map[int]struct {
		result1 int
	}
	GetgroupsStub        func() (gids []int, err error)
	getgroupsMutex       sync.RWMutex
	getgroupsArgsForCall []struct{}
	getgroupsReturns     struct {
		result1 []int
		result2 error
	}
	getgroupsReturnsOnCall map[int]struct {
		result1 []int
		result2 error
	}
	SetgroupsStub        func(gids []int) (err error)
	setgroupsMutex       sync.RWMutex
	setgroupsArgsForCall []struct {
		gids []int
	}
	setgroupsReturns struct {
		result1 error
	}
	setgroupsReturnsOnCall map[int]struct {
		result1 error
	}
	Wait4Stub        func(pid int, wstatus *syscall.WaitStatus, options int, rusage *syscall.Rusage) (wpid int, err error)
	wait4Mutex       sync.RWMutex
	wait4ArgsForCall []struct {
		pid     int
		wstatus *syscall.WaitStatus
		options int
		rusage  *syscall.Rusage
	}
	wait4Returns struct {
		result1 int
		result2 error
	}
	wait4ReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetsockoptByteStub        func(fd, level, opt int) (value byte, err error)
	getsockoptByteMutex       sync.RWMutex
	getsockoptByteArgsForCall []struct {
		fd    int
		level int
		opt   int
	}
	getsockoptByteReturns struct {
		result1 byte
		result2 error
	}
	getsockoptByteReturnsOnCall map[int]struct {
		result1 byte
		result2 error
	}
	GetsockoptInet4AddrStub        func(fd, level, opt int) (value [4]byte, err error)
	getsockoptInet4AddrMutex       sync.RWMutex
	getsockoptInet4AddrArgsForCall []struct {
		fd    int
		level int
		opt   int
	}
	getsockoptInet4AddrReturns struct {
		result1 [4]byte
		result2 error
	}
	getsockoptInet4AddrReturnsOnCall map[int]struct {
		result1 [4]byte
		result2 error
	}
	GetsockoptIPMreqStub        func(fd, level, opt int) (*syscall.IPMreq, error)
	getsockoptIPMreqMutex       sync.RWMutex
	getsockoptIPMreqArgsForCall []struct {
		fd    int
		level int
		opt   int
	}
	getsockoptIPMreqReturns struct {
		result1 *syscall.IPMreq
		result2 error
	}
	getsockoptIPMreqReturnsOnCall map[int]struct {
		result1 *syscall.IPMreq
		result2 error
	}
	GetsockoptIPv6MreqStub        func(fd, level, opt int) (*syscall.IPv6Mreq, error)
	getsockoptIPv6MreqMutex       sync.RWMutex
	getsockoptIPv6MreqArgsForCall []struct {
		fd    int
		level int
		opt   int
	}
	getsockoptIPv6MreqReturns struct {
		result1 *syscall.IPv6Mreq
		result2 error
	}
	getsockoptIPv6MreqReturnsOnCall map[int]struct {
		result1 *syscall.IPv6Mreq
		result2 error
	}
	GetsockoptIPv6MTUInfoStub        func(fd, level, opt int) (*syscall.IPv6MTUInfo, error)
	getsockoptIPv6MTUInfoMutex       sync.RWMutex
	getsockoptIPv6MTUInfoArgsForCall []struct {
		fd    int
		level int
		opt   int
	}
	getsockoptIPv6MTUInfoReturns struct {
		result1 *syscall.IPv6MTUInfo
		result2 error
	}
	getsockoptIPv6MTUInfoReturnsOnCall map[int]struct {
		result1 *syscall.IPv6MTUInfo
		result2 error
	}
	GetsockoptICMPv6FilterStub        func(fd, level, opt int) (*syscall.ICMPv6Filter, error)
	getsockoptICMPv6FilterMutex       sync.RWMutex
	getsockoptICMPv6FilterArgsForCall []struct {
		fd    int
		level int
		opt   int
	}
	getsockoptICMPv6FilterReturns struct {
		result1 *syscall.ICMPv6Filter
		result2 error
	}
	getsockoptICMPv6FilterReturnsOnCall map[int]struct {
		result1 *syscall.ICMPv6Filter
		result2 error
	}
	KeventStub        func(kq int, changes, events []syscall.Kevent_t, timeout *syscall.Timespec) (n int, err error)
	keventMutex       sync.RWMutex
	keventArgsForCall []struct {
		kq      int
		changes []syscall.Kevent_t
		events  []syscall.Kevent_t
		timeout *syscall.Timespec
	}
	keventReturns struct {
		result1 int
		result2 error
	}
	keventReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SysctlStub        func(name string) (value string, err error)
	sysctlMutex       sync.RWMutex
	sysctlArgsForCall []struct {
		name string
	}
	sysctlReturns struct {
		result1 string
		result2 error
	}
	sysctlReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SysctlUint32Stub        func(name string) (value uint32, err error)
	sysctlUint32Mutex       sync.RWMutex
	sysctlUint32ArgsForCall []struct {
		name string
	}
	sysctlUint32Returns struct {
		result1 uint32
		result2 error
	}
	sysctlUint32ReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	UtimesStub        func(path string, tv []syscall.Timeval) (err error)
	utimesMutex       sync.RWMutex
	utimesArgsForCall []struct {
		path string
		tv   []syscall.Timeval
	}
	utimesReturns struct {
		result1 error
	}
	utimesReturnsOnCall map[int]struct {
		result1 error
	}
	FutimesStub        func(fd int, tv []syscall.Timeval) (err error)
	futimesMutex       sync.RWMutex
	futimesArgsForCall []struct {
		fd int
		tv []syscall.Timeval
	}
	futimesReturns struct {
		result1 error
	}
	futimesReturnsOnCall map[int]struct {
		result1 error
	}
	MmapStub        func(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)
	mmapMutex       sync.RWMutex
	mmapArgsForCall []struct {
		fd     int
		offset int64
		length int
		prot   int
		flags  int
	}
	mmapReturns struct {
		result1 []byte
		result2 error
	}
	mmapReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	MunmapStub        func(b []byte) (err error)
	munmapMutex       sync.RWMutex
	munmapArgsForCall []struct {
		b []byte
	}
	munmapReturns struct {
		result1 error
	}
	munmapReturnsOnCall map[int]struct {
		result1 error
	}
	PtraceAttachStub        func(pid int) (err error)
	ptraceAttachMutex       sync.RWMutex
	ptraceAttachArgsForCall []struct {
		pid int
	}
	ptraceAttachReturns struct {
		result1 error
	}
	ptraceAttachReturnsOnCall map[int]struct {
		result1 error
	}
	PtraceDetachStub        func(pid int) (err error)
	ptraceDetachMutex       sync.RWMutex
	ptraceDetachArgsForCall []struct {
		pid int
	}
	ptraceDetachReturns struct {
		result1 error
	}
	ptraceDetachReturnsOnCall map[int]struct {
		result1 error
	}
	GetfsstatStub        func(buf []syscall.Statfs_t, flags int) (n int, err error)
	getfsstatMutex       sync.RWMutex
	getfsstatArgsForCall []struct {
		buf   []syscall.Statfs_t
		flags int
	}
	getfsstatReturns struct {
		result1 int
		result2 error
	}
	getfsstatReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	KillStub        func(pid int, signum syscall.Signal) (err error)
	killMutex       sync.RWMutex
	killArgsForCall []struct {
		pid    int
		signum syscall.Signal
	}
	killReturns struct {
		result1 error
	}
	killReturnsOnCall map[int]struct {
		result1 error
	}
	GettimeofdayStub        func(tv *syscall.Timeval) error
	gettimeofdayMutex       sync.RWMutex
	gettimeofdayArgsForCall []struct {
		tv *syscall.Timeval
	}
	gettimeofdayReturns struct {
		result1 error
	}
	gettimeofdayReturnsOnCall map[int]struct {
		result1 error
	}
	SetKeventStub        func(k *syscall.Kevent_t, fd, mode, flags int)
	setKeventMutex       sync.RWMutex
	setKeventArgsForCall []struct {
		k     *syscall.Kevent_t
		fd    int
		mode  int
		flags int
	}
	GetsockoptIPMreqnStub        func(fd, level, opt int) (*syscall.IPMreqn, error)
	getsockoptIPMreqnMutex       sync.RWMutex
	getsockoptIPMreqnArgsForCall []struct {
		fd    int
		level int
		opt   int
	}
	getsockoptIPMreqnReturns struct {
		result1 *syscall.IPMreqn
		result2 error
	}
	getsockoptIPMreqnReturnsOnCall map[int]struct {
		result1 *syscall.IPMreqn
		result2 error
	}
	SetsockoptIPMreqnStub        func(fd, level, opt int, mreq *syscall.IPMreqn) (err error)
	setsockoptIPMreqnMutex       sync.RWMutex
	setsockoptIPMreqnArgsForCall []struct {
		fd    int
		level int
		opt   int
		mreq  *syscall.IPMreqn
	}
	setsockoptIPMreqnReturns struct {
		result1 error
	}
	setsockoptIPMreqnReturnsOnCall map[int]struct {
		result1 error
	}
	Accept4Stub        func(fd, flags int) (nfd int, sa syscall.Sockaddr, err error)
	accept4Mutex       sync.RWMutex
	accept4ArgsForCall []struct {
		fd    int
		flags int
	}
	accept4Returns struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}
	accept4ReturnsOnCall map[int]struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}
	AccessStub        func(path string, mode uint32) (err error)
	accessMutex       sync.RWMutex
	accessArgsForCall []struct {
		path string
		mode uint32
	}
	accessReturns struct {
		result1 error
	}
	accessReturnsOnCall map[int]struct {
		result1 error
	}
	CreatStub        func(path string, mode uint32) (fd int, err error)
	creatMutex       sync.RWMutex
	creatArgsForCall []struct {
		path string
		mode uint32
	}
	creatReturns struct {
		result1 int
		result2 error
	}
	creatReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	MknodStub        func(path string, mode uint32, dev int) (err error)
	mknodMutex       sync.RWMutex
	mknodArgsForCall []struct {
		path string
		mode uint32
		dev  int
	}
	mknodReturns struct {
		result1 error
	}
	mknodReturnsOnCall map[int]struct {
		result1 error
	}
	OpenatStub        func(dirfd int, path string, flags int, mode uint32) (fd int, err error)
	openatMutex       sync.RWMutex
	openatArgsForCall []struct {
		dirfd int
		path  string
		flags int
		mode  uint32
	}
	openatReturns struct {
		result1 int
		result2 error
	}
	openatReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	UnlinkatStub        func(dirfd int, path string) error
	unlinkatMutex       sync.RWMutex
	unlinkatArgsForCall []struct {
		dirfd int
		path  string
	}
	unlinkatReturns struct {
		result1 error
	}
	unlinkatReturnsOnCall map[int]struct {
		result1 error
	}
	FutimesatStub        func(dirfd int, path string, tv []syscall.Timeval) (err error)
	futimesatMutex       sync.RWMutex
	futimesatArgsForCall []struct {
		dirfd int
		path  string
		tv    []syscall.Timeval
	}
	futimesatReturns struct {
		result1 error
	}
	futimesatReturnsOnCall map[int]struct {
		result1 error
	}
	MkfifoStub        func(path string, mode uint32) (err error)
	mkfifoMutex       sync.RWMutex
	mkfifoArgsForCall []struct {
		path string
		mode uint32
	}
	mkfifoReturns struct {
		result1 error
	}
	mkfifoReturnsOnCall map[int]struct {
		result1 error
	}
	GetsockoptUcredStub        func(fd, level, opt int) (*syscall.Ucred, error)
	getsockoptUcredMutex       sync.RWMutex
	getsockoptUcredArgsForCall []struct {
		fd    int
		level int
		opt   int
	}
	getsockoptUcredReturns struct {
		result1 *syscall.Ucred
		result2 error
	}
	getsockoptUcredReturnsOnCall map[int]struct {
		result1 *syscall.Ucred
		result2 error
	}
	BindToDeviceStub        func(fd int, device string) (err error)
	bindToDeviceMutex       sync.RWMutex
	bindToDeviceArgsForCall []struct {
		fd     int
		device string
	}
	bindToDeviceReturns struct {
		result1 error
	}
	bindToDeviceReturnsOnCall map[int]struct {
		result1 error
	}
	PtracePeekTextStub        func(pid int, addr uintptr, out []byte) (count int, err error)
	ptracePeekTextMutex       sync.RWMutex
	ptracePeekTextArgsForCall []struct {
		pid  int
		addr uintptr
		out  []byte
	}
	ptracePeekTextReturns struct {
		result1 int
		result2 error
	}
	ptracePeekTextReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	PtracePeekDataStub        func(pid int, addr uintptr, out []byte) (count int, err error)
	ptracePeekDataMutex       sync.RWMutex
	ptracePeekDataArgsForCall []struct {
		pid  int
		addr uintptr
		out  []byte
	}
	ptracePeekDataReturns struct {
		result1 int
		result2 error
	}
	ptracePeekDataReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	PtracePokeTextStub        func(pid int, addr uintptr, data []byte) (count int, err error)
	ptracePokeTextMutex       sync.RWMutex
	ptracePokeTextArgsForCall []struct {
		pid  int
		addr uintptr
		data []byte
	}
	ptracePokeTextReturns struct {
		result1 int
		result2 error
	}
	ptracePokeTextReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	PtracePokeDataStub        func(pid int, addr uintptr, data []byte) (count int, err error)
	ptracePokeDataMutex       sync.RWMutex
	ptracePokeDataArgsForCall []struct {
		pid  int
		addr uintptr
		data []byte
	}
	ptracePokeDataReturns struct {
		result1 int
		result2 error
	}
	ptracePokeDataReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	PtraceGetRegsStub        func(pid int, regsout *syscall.PtraceRegs) (err error)
	ptraceGetRegsMutex       sync.RWMutex
	ptraceGetRegsArgsForCall []struct {
		pid     int
		regsout *syscall.PtraceRegs
	}
	ptraceGetRegsReturns struct {
		result1 error
	}
	ptraceGetRegsReturnsOnCall map[int]struct {
		result1 error
	}
	PtraceSetRegsStub        func(pid int, regs *syscall.PtraceRegs) (err error)
	ptraceSetRegsMutex       sync.RWMutex
	ptraceSetRegsArgsForCall []struct {
		pid  int
		regs *syscall.PtraceRegs
	}
	ptraceSetRegsReturns struct {
		result1 error
	}
	ptraceSetRegsReturnsOnCall map[int]struct {
		result1 error
	}
	PtraceSetOptionsStub        func(pid int, options int) (err error)
	ptraceSetOptionsMutex       sync.RWMutex
	ptraceSetOptionsArgsForCall []struct {
		pid     int
		options int
	}
	ptraceSetOptionsReturns struct {
		result1 error
	}
	ptraceSetOptionsReturnsOnCall map[int]struct {
		result1 error
	}
	PtraceGetEventMsgStub        func(pid int) (msg uint, err error)
	ptraceGetEventMsgMutex       sync.RWMutex
	ptraceGetEventMsgArgsForCall []struct {
		pid int
	}
	ptraceGetEventMsgReturns struct {
		result1 uint
		result2 error
	}
	ptraceGetEventMsgReturnsOnCall map[int]struct {
		result1 uint
		result2 error
	}
	PtraceContStub        func(pid int, signal int) (err error)
	ptraceContMutex       sync.RWMutex
	ptraceContArgsForCall []struct {
		pid    int
		signal int
	}
	ptraceContReturns struct {
		result1 error
	}
	ptraceContReturnsOnCall map[int]struct {
		result1 error
	}
	PtraceSyscallStub        func(pid int, signal int) (err error)
	ptraceSyscallMutex       sync.RWMutex
	ptraceSyscallArgsForCall []struct {
		pid    int
		signal int
	}
	ptraceSyscallReturns struct {
		result1 error
	}
	ptraceSyscallReturnsOnCall map[int]struct {
		result1 error
	}
	PtraceSingleStepStub        func(pid int) (err error)
	ptraceSingleStepMutex       sync.RWMutex
	ptraceSingleStepArgsForCall []struct {
		pid int
	}
	ptraceSingleStepReturns struct {
		result1 error
	}
	ptraceSingleStepReturnsOnCall map[int]struct {
		result1 error
	}
	RebootStub        func(cmd int) (err error)
	rebootMutex       sync.RWMutex
	rebootArgsForCall []struct {
		cmd int
	}
	rebootReturns struct {
		result1 error
	}
	rebootReturnsOnCall map[int]struct {
		result1 error
	}
	MountStub        func(source string, target string, fstype string, flags uintptr, data string) (err error)
	mountMutex       sync.RWMutex
	mountArgsForCall []struct {
		source string
		target string
		fstype string
		flags  uintptr
		data   string
	}
	mountReturns struct {
		result1 error
	}
	mountReturnsOnCall map[int]struct {
		result1 error
	}
	GetpgrpStub        func() (pid int)
	getpgrpMutex       sync.RWMutex
	getpgrpArgsForCall []struct{}
	getpgrpReturns     struct {
		result1 int
	}
	getpgrpReturnsOnCall map[int]struct {
		result1 int
	}
	SetuidStub        func(uid int) (err error)
	setuidMutex       sync.RWMutex
	setuidArgsForCall []struct {
		uid int
	}
	setuidReturns struct {
		result1 error
	}
	setuidReturnsOnCall map[int]struct {
		result1 error
	}
	SetgidStub        func(gid int) (err error)
	setgidMutex       sync.RWMutex
	setgidArgsForCall []struct {
		gid int
	}
	setgidReturns struct {
		result1 error
	}
	setgidReturnsOnCall map[int]struct {
		result1 error
	}
	Pipe2Stub        func(p []int, flags int) (err error)
	pipe2Mutex       sync.RWMutex
	pipe2ArgsForCall []struct {
		p     []int
		flags int
	}
	pipe2Returns struct {
		result1 error
	}
	pipe2ReturnsOnCall map[int]struct {
		result1 error
	}
	GetrlimitStub        func(resource int, rlim *syscall.Rlimit) (err error)
	getrlimitMutex       sync.RWMutex
	getrlimitArgsForCall []struct {
		resource int
		rlim     *syscall.Rlimit
	}
	getrlimitReturns struct {
		result1 error
	}
	getrlimitReturnsOnCall map[int]struct {
		result1 error
	}
	SetrlimitStub        func(resource int, rlim *syscall.Rlimit) (err error)
	setrlimitMutex       sync.RWMutex
	setrlimitArgsForCall []struct {
		resource int
		rlim     *syscall.Rlimit
	}
	setrlimitReturns struct {
		result1 error
	}
	setrlimitReturnsOnCall map[int]struct {
		result1 error
	}
	FstatfsStub        func(fd int, buf *syscall.Statfs_t) (err error)
	fstatfsMutex       sync.RWMutex
	fstatfsArgsForCall []struct {
		fd  int
		buf *syscall.Statfs_t
	}
	fstatfsReturns struct {
		result1 error
	}
	fstatfsReturnsOnCall map[int]struct {
		result1 error
	}
	StatfsStub        func(path string, buf *syscall.Statfs_t) (err error)
	statfsMutex       sync.RWMutex
	statfsArgsForCall []struct {
		path string
		buf  *syscall.Statfs_t
	}
	statfsReturns struct {
		result1 error
	}
	statfsReturnsOnCall map[int]struct {
		result1 error
	}
	TimeStub        func(t *syscall.Time_t) (tt syscall.Time_t, err error)
	timeMutex       sync.RWMutex
	timeArgsForCall []struct {
		t *syscall.Time_t
	}
	timeReturns struct {
		result1 syscall.Time_t
		result2 error
	}
	timeReturnsOnCall map[int]struct {
		result1 syscall.Time_t
		result2 error
	}
	InotifyInitStub        func() (fd int, err error)
	inotifyInitMutex       sync.RWMutex
	inotifyInitArgsForCall []struct{}
	inotifyInitReturns     struct {
		result1 int
		result2 error
	}
	inotifyInitReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	IopermStub        func(from int, num int, on int) (err error)
	iopermMutex       sync.RWMutex
	iopermArgsForCall []struct {
		from int
		num  int
		on   int
	}
	iopermReturns struct {
		result1 error
	}
	iopermReturnsOnCall map[int]struct {
		result1 error
	}
	IoplStub        func(level int) (err error)
	ioplMutex       sync.RWMutex
	ioplArgsForCall []struct {
		level int
	}
	ioplReturns struct {
		result1 error
	}
	ioplReturnsOnCall map[int]struct {
		result1 error
	}
	RawSyscallStub        func(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno)
	rawSyscallMutex       sync.RWMutex
	rawSyscallArgsForCall []struct {
		trap uintptr
		a1   uintptr
		a2   uintptr
		a3   uintptr
	}
	rawSyscallReturns struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	rawSyscallReturnsOnCall map[int]struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	RawSyscall6Stub        func(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)
	rawSyscall6Mutex       sync.RWMutex
	rawSyscall6ArgsForCall []struct {
		trap uintptr
		a1   uintptr
		a2   uintptr
		a3   uintptr
		a4   uintptr
		a5   uintptr
		a6   uintptr
	}
	rawSyscall6Returns struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	rawSyscall6ReturnsOnCall map[int]struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}
	GetegidStub        func() int
	getegidMutex       sync.RWMutex
	getegidArgsForCall []struct{}
	getegidReturns     struct {
		result1 int
	}
	getegidReturnsOnCall map[int]struct {
		result1 int
	}
	GeteuidStub        func() int
	geteuidMutex       sync.RWMutex
	geteuidArgsForCall []struct{}
	geteuidReturns     struct {
		result1 int
	}
	geteuidReturnsOnCall map[int]struct {
		result1 int
	}
	GetgidStub        func() int
	getgidMutex       sync.RWMutex
	getgidArgsForCall []struct{}
	getgidReturns     struct {
		result1 int
	}
	getgidReturnsOnCall map[int]struct {
		result1 int
	}
	GetppidStub        func() int
	getppidMutex       sync.RWMutex
	getppidArgsForCall []struct{}
	getppidReturns     struct {
		result1 int
	}
	getppidReturnsOnCall map[int]struct {
		result1 int
	}
	GetpidStub        func() int
	getpidMutex       sync.RWMutex
	getpidArgsForCall []struct{}
	getpidReturns     struct {
		result1 int
	}
	getpidReturnsOnCall map[int]struct {
		result1 int
	}
	GetuidStub        func() int
	getuidMutex       sync.RWMutex
	getuidArgsForCall []struct{}
	getuidReturns     struct {
		result1 int
	}
	getuidReturnsOnCall map[int]struct {
		result1 int
	}
	SendfileStub        func(outfd int, infd int, offset *int64, count int) (written int, err error)
	sendfileMutex       sync.RWMutex
	sendfileArgsForCall []struct {
		outfd  int
		infd   int
		offset *int64
		count  int
	}
	sendfileReturns struct {
		result1 int
		result2 error
	}
	sendfileReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetdirentriesStub        func(fd int, buf []byte, basep *uintptr) (n int, err error)
	getdirentriesMutex       sync.RWMutex
	getdirentriesArgsForCall []struct {
		fd    int
		buf   []byte
		basep *uintptr
	}
	getdirentriesReturns struct {
		result1 int
		result2 error
	}
	getdirentriesReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	NewErrorStub        func(s string) error
	newErrorMutex       sync.RWMutex
	newErrorArgsForCall []struct {
		s string
	}
	newErrorReturns struct {
		result1 error
	}
	newErrorReturnsOnCall map[int]struct {
		result1 error
	}
	ExitStub        func(code int)
	exitMutex       sync.RWMutex
	exitArgsForCall []struct {
		code int
	}
	Fd2pathStub        func(fd int) (path string, err error)
	fd2pathMutex       sync.RWMutex
	fd2pathArgsForCall []struct {
		fd int
	}
	fd2pathReturns struct {
		result1 string
		result2 error
	}
	fd2pathReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	AwaitStub        func(w *syscall.Waitmsg) (err error)
	awaitMutex       sync.RWMutex
	awaitArgsForCall []struct {
		w *syscall.Waitmsg
	}
	awaitReturns struct {
		result1 error
	}
	awaitReturnsOnCall map[int]struct {
		result1 error
	}
	UnmountStub        func(name, old string) (err error)
	unmountMutex       sync.RWMutex
	unmountArgsForCall []struct {
		name string
		old  string
	}
	unmountReturns struct {
		result1 error
	}
	unmountReturnsOnCall map[int]struct {
		result1 error
	}
	NsecToTimevalStub        func(nsec int64) (tv syscall.Timeval)
	nsecToTimevalMutex       sync.RWMutex
	nsecToTimevalArgsForCall []struct {
		nsec int64
	}
	nsecToTimevalReturns struct {
		result1 syscall.Timeval
	}
	nsecToTimevalReturnsOnCall map[int]struct {
		result1 syscall.Timeval
	}
	CreateStub        func(path string, mode int, perm uint32) (fd int, err error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		path string
		mode int
		perm uint32
	}
	createReturns struct {
		result1 int
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	RemoveStub        func(path string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		path string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	WstatStub        func(path string, edir []byte) (err error)
	wstatMutex       sync.RWMutex
	wstatArgsForCall []struct {
		path string
		edir []byte
	}
	wstatReturns struct {
		result1 error
	}
	wstatReturnsOnCall map[int]struct {
		result1 error
	}
	GethostnameStub        func() (name string, err error)
	gethostnameMutex       sync.RWMutex
	gethostnameArgsForCall []struct{}
	gethostnameReturns     struct {
		result1 string
		result2 error
	}
	gethostnameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetexecnameStub        func() (path string, err error)
	getexecnameMutex       sync.RWMutex
	getexecnameArgsForCall []struct{}
	getexecnameReturns     struct {
		result1 string
		result2 error
	}
	getexecnameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	StringToUTF16Stub        func(s string) []uint16
	stringToUTF16Mutex       sync.RWMutex
	stringToUTF16ArgsForCall []struct {
		s string
	}
	stringToUTF16Returns struct {
		result1 []uint16
	}
	stringToUTF16ReturnsOnCall map[int]struct {
		result1 []uint16
	}
	UTF16FromStringStub        func(s string) ([]uint16, error)
	uTF16FromStringMutex       sync.RWMutex
	uTF16FromStringArgsForCall []struct {
		s string
	}
	uTF16FromStringReturns struct {
		result1 []uint16
		result2 error
	}
	uTF16FromStringReturnsOnCall map[int]struct {
		result1 []uint16
		result2 error
	}
	UTF16ToStringStub        func(s []uint16) string
	uTF16ToStringMutex       sync.RWMutex
	uTF16ToStringArgsForCall []struct {
		s []uint16
	}
	uTF16ToStringReturns struct {
		result1 string
	}
	uTF16ToStringReturnsOnCall map[int]struct {
		result1 string
	}
	StringToUTF16PtrStub        func(s string) *uint16
	stringToUTF16PtrMutex       sync.RWMutex
	stringToUTF16PtrArgsForCall []struct {
		s string
	}
	stringToUTF16PtrReturns struct {
		result1 *uint16
	}
	stringToUTF16PtrReturnsOnCall map[int]struct {
		result1 *uint16
	}
	UTF16PtrFromStringStub        func(s string) (*uint16, error)
	uTF16PtrFromStringMutex       sync.RWMutex
	uTF16PtrFromStringArgsForCall []struct {
		s string
	}
	uTF16PtrFromStringReturns struct {
		result1 *uint16
		result2 error
	}
	uTF16PtrFromStringReturnsOnCall map[int]struct {
		result1 *uint16
		result2 error
	}
	FormatMessageStub        func(flags uint32, msgsrc uint32, msgid uint32, langid uint32, buf []uint16, args *byte) (n uint32, err error)
	formatMessageMutex       sync.RWMutex
	formatMessageArgsForCall []struct {
		flags  uint32
		msgsrc uint32
		msgid  uint32
		langid uint32
		buf    []uint16
		args   *byte
	}
	formatMessageReturns struct {
		result1 uint32
		result2 error
	}
	formatMessageReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	NewCallbackStub        func(fn interface{}) uintptr
	newCallbackMutex       sync.RWMutex
	newCallbackArgsForCall []struct {
		fn interface{}
	}
	newCallbackReturns struct {
		result1 uintptr
	}
	newCallbackReturnsOnCall map[int]struct {
		result1 uintptr
	}
	NewCallbackCDeclStub        func(fn interface{}) uintptr
	newCallbackCDeclMutex       sync.RWMutex
	newCallbackCDeclArgsForCall []struct {
		fn interface{}
	}
	newCallbackCDeclReturns struct {
		result1 uintptr
	}
	newCallbackCDeclReturnsOnCall map[int]struct {
		result1 uintptr
	}
	ComputerNameStub        func() (name string, err error)
	computerNameMutex       sync.RWMutex
	computerNameArgsForCall []struct{}
	computerNameReturns     struct {
		result1 string
		result2 error
	}
	computerNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	LoadCancelIoExStub        func() error
	loadCancelIoExMutex       sync.RWMutex
	loadCancelIoExArgsForCall []struct{}
	loadCancelIoExReturns     struct {
		result1 error
	}
	loadCancelIoExReturnsOnCall map[int]struct {
		result1 error
	}
	LoadSetFileCompletionNotificationModesStub        func() error
	loadSetFileCompletionNotificationModesMutex       sync.RWMutex
	loadSetFileCompletionNotificationModesArgsForCall []struct{}
	loadSetFileCompletionNotificationModesReturns     struct {
		result1 error
	}
	loadSetFileCompletionNotificationModesReturnsOnCall map[int]struct {
		result1 error
	}
	WSASendtoStub        func(s syscall.Handle, bufs *syscall.WSABuf, bufcnt uint32, sent *uint32, flags uint32, to syscall.Sockaddr, overlapped *syscall.Overlapped, croutine *byte) (err error)
	wSASendtoMutex       sync.RWMutex
	wSASendtoArgsForCall []struct {
		s          syscall.Handle
		bufs       *syscall.WSABuf
		bufcnt     uint32
		sent       *uint32
		flags      uint32
		to         syscall.Sockaddr
		overlapped *syscall.Overlapped
		croutine   *byte
	}
	wSASendtoReturns struct {
		result1 error
	}
	wSASendtoReturnsOnCall map[int]struct {
		result1 error
	}
	LoadGetAddrInfoStub        func() error
	loadGetAddrInfoMutex       sync.RWMutex
	loadGetAddrInfoArgsForCall []struct{}
	loadGetAddrInfoReturns     struct {
		result1 error
	}
	loadGetAddrInfoReturnsOnCall map[int]struct {
		result1 error
	}
	LoadConnectExStub        func() error
	loadConnectExMutex       sync.RWMutex
	loadConnectExArgsForCall []struct{}
	loadConnectExReturns     struct {
		result1 error
	}
	loadConnectExReturnsOnCall map[int]struct {
		result1 error
	}
	ConnectExStub        func(fd syscall.Handle, sa syscall.Sockaddr, sendBuf *byte, sendDataLen uint32, bytesSent *uint32, overlapped *syscall.Overlapped) error
	connectExMutex       sync.RWMutex
	connectExArgsForCall []struct {
		fd          syscall.Handle
		sa          syscall.Sockaddr
		sendBuf     *byte
		sendDataLen uint32
		bytesSent   *uint32
		overlapped  *syscall.Overlapped
	}
	connectExReturns struct {
		result1 error
	}
	connectExReturnsOnCall map[int]struct {
		result1 error
	}
	TimespecToNsecStub        func(ts syscall.Timespec) int64
	timespecToNsecMutex       sync.RWMutex
	timespecToNsecArgsForCall []struct {
		ts syscall.Timespec
	}
	timespecToNsecReturns struct {
		result1 int64
	}
	timespecToNsecReturnsOnCall map[int]struct {
		result1 int64
	}
	NsecToTimespecStub        func(nsec int64) (ts syscall.Timespec)
	nsecToTimespecMutex       sync.RWMutex
	nsecToTimespecArgsForCall []struct {
		nsec int64
	}
	nsecToTimespecReturns struct {
		result1 syscall.Timespec
	}
	nsecToTimespecReturnsOnCall map[int]struct {
		result1 syscall.Timespec
	}
	FindFirstFileStub        func(name *uint16, data *syscall.Win32finddata) (handle syscall.Handle, err error)
	findFirstFileMutex       sync.RWMutex
	findFirstFileArgsForCall []struct {
		name *uint16
		data *syscall.Win32finddata
	}
	findFirstFileReturns struct {
		result1 syscall.Handle
		result2 error
	}
	findFirstFileReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	FindNextFileStub        func(handle syscall.Handle, data *syscall.Win32finddata) (err error)
	findNextFileMutex       sync.RWMutex
	findNextFileArgsForCall []struct {
		handle syscall.Handle
		data   *syscall.Win32finddata
	}
	findNextFileReturns struct {
		result1 error
	}
	findNextFileReturnsOnCall map[int]struct {
		result1 error
	}
	LoadCreateSymbolicLinkStub        func() error
	loadCreateSymbolicLinkMutex       sync.RWMutex
	loadCreateSymbolicLinkArgsForCall []struct{}
	loadCreateSymbolicLinkReturns     struct {
		result1 error
	}
	loadCreateSymbolicLinkReturnsOnCall map[int]struct {
		result1 error
	}
	TimevalToNsecStub        func(tv syscall.Timeval) int64
	timevalToNsecMutex       sync.RWMutex
	timevalToNsecArgsForCall []struct {
		tv syscall.Timeval
	}
	timevalToNsecReturns struct {
		result1 int64
	}
	timevalToNsecReturnsOnCall map[int]struct {
		result1 int64
	}
	AdjtimeStub        func(delta *syscall.Timeval, olddelta *syscall.Timeval) (err error)
	adjtimeMutex       sync.RWMutex
	adjtimeArgsForCall []struct {
		delta    *syscall.Timeval
		olddelta *syscall.Timeval
	}
	adjtimeReturns struct {
		result1 error
	}
	adjtimeReturnsOnCall map[int]struct {
		result1 error
	}
	ChflagsStub        func(path string, flags int) (err error)
	chflagsMutex       sync.RWMutex
	chflagsArgsForCall []struct {
		path  string
		flags int
	}
	chflagsReturns struct {
		result1 error
	}
	chflagsReturnsOnCall map[int]struct {
		result1 error
	}
	ChrootStub        func(path string) (err error)
	chrootMutex       sync.RWMutex
	chrootArgsForCall []struct {
		path string
	}
	chrootReturns struct {
		result1 error
	}
	chrootReturnsOnCall map[int]struct {
		result1 error
	}
	ExchangedataStub        func(path1 string, path2 string, options int) (err error)
	exchangedataMutex       sync.RWMutex
	exchangedataArgsForCall []struct {
		path1   string
		path2   string
		options int
	}
	exchangedataReturns struct {
		result1 error
	}
	exchangedataReturnsOnCall map[int]struct {
		result1 error
	}
	FchflagsStub        func(fd int, flags int) (err error)
	fchflagsMutex       sync.RWMutex
	fchflagsArgsForCall []struct {
		fd    int
		flags int
	}
	fchflagsReturns struct {
		result1 error
	}
	fchflagsReturnsOnCall map[int]struct {
		result1 error
	}
	FlockStub        func(fd int, how int) (err error)
	flockMutex       sync.RWMutex
	flockArgsForCall []struct {
		fd  int
		how int
	}
	flockReturns struct {
		result1 error
	}
	flockReturnsOnCall map[int]struct {
		result1 error
	}
	FpathconfStub        func(fd int, name int) (val int, err error)
	fpathconfMutex       sync.RWMutex
	fpathconfArgsForCall []struct {
		fd   int
		name int
	}
	fpathconfReturns struct {
		result1 int
		result2 error
	}
	fpathconfReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetdtablesizeStub        func() (size int)
	getdtablesizeMutex       sync.RWMutex
	getdtablesizeArgsForCall []struct{}
	getdtablesizeReturns     struct {
		result1 int
	}
	getdtablesizeReturnsOnCall map[int]struct {
		result1 int
	}
	GetpgidStub        func(pid int) (pgid int, err error)
	getpgidMutex       sync.RWMutex
	getpgidArgsForCall []struct {
		pid int
	}
	getpgidReturns struct {
		result1 int
		result2 error
	}
	getpgidReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetpriorityStub        func(which int, who int) (prio int, err error)
	getpriorityMutex       sync.RWMutex
	getpriorityArgsForCall []struct {
		which int
		who   int
	}
	getpriorityReturns struct {
		result1 int
		result2 error
	}
	getpriorityReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetrusageStub        func(who int, rusage *syscall.Rusage) (err error)
	getrusageMutex       sync.RWMutex
	getrusageArgsForCall []struct {
		who    int
		rusage *syscall.Rusage
	}
	getrusageReturns struct {
		result1 error
	}
	getrusageReturnsOnCall map[int]struct {
		result1 error
	}
	GetsidStub        func(pid int) (sid int, err error)
	getsidMutex       sync.RWMutex
	getsidArgsForCall []struct {
		pid int
	}
	getsidReturns struct {
		result1 int
		result2 error
	}
	getsidReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	IssetugidStub        func() (tainted bool)
	issetugidMutex       sync.RWMutex
	issetugidArgsForCall []struct{}
	issetugidReturns     struct {
		result1 bool
	}
	issetugidReturnsOnCall map[int]struct {
		result1 bool
	}
	KqueueStub        func() (fd int, err error)
	kqueueMutex       sync.RWMutex
	kqueueArgsForCall []struct{}
	kqueueReturns     struct {
		result1 int
		result2 error
	}
	kqueueReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	MlockStub        func(b []byte) (err error)
	mlockMutex       sync.RWMutex
	mlockArgsForCall []struct {
		b []byte
	}
	mlockReturns struct {
		result1 error
	}
	mlockReturnsOnCall map[int]struct {
		result1 error
	}
	MlockallStub        func(flags int) (err error)
	mlockallMutex       sync.RWMutex
	mlockallArgsForCall []struct {
		flags int
	}
	mlockallReturns struct {
		result1 error
	}
	mlockallReturnsOnCall map[int]struct {
		result1 error
	}
	MprotectStub        func(b []byte, prot int) (err error)
	mprotectMutex       sync.RWMutex
	mprotectArgsForCall []struct {
		b    []byte
		prot int
	}
	mprotectReturns struct {
		result1 error
	}
	mprotectReturnsOnCall map[int]struct {
		result1 error
	}
	MunlockStub        func(b []byte) (err error)
	munlockMutex       sync.RWMutex
	munlockArgsForCall []struct {
		b []byte
	}
	munlockReturns struct {
		result1 error
	}
	munlockReturnsOnCall map[int]struct {
		result1 error
	}
	MunlockallStub        func() (err error)
	munlockallMutex       sync.RWMutex
	munlockallArgsForCall []struct{}
	munlockallReturns     struct {
		result1 error
	}
	munlockallReturnsOnCall map[int]struct {
		result1 error
	}
	PathconfStub        func(path string, name int) (val int, err error)
	pathconfMutex       sync.RWMutex
	pathconfArgsForCall []struct {
		path string
		name int
	}
	pathconfReturns struct {
		result1 int
		result2 error
	}
	pathconfReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	RevokeStub        func(path string) (err error)
	revokeMutex       sync.RWMutex
	revokeArgsForCall []struct {
		path string
	}
	revokeReturns struct {
		result1 error
	}
	revokeReturnsOnCall map[int]struct {
		result1 error
	}
	SelectStub        func(n int, r *syscall.FdSet, w *syscall.FdSet, e *syscall.FdSet, timeout *syscall.Timeval) (err error)
	selectMutex       sync.RWMutex
	selectArgsForCall []struct {
		n       int
		r       *syscall.FdSet
		w       *syscall.FdSet
		e       *syscall.FdSet
		timeout *syscall.Timeval
	}
	selectReturns struct {
		result1 error
	}
	selectReturnsOnCall map[int]struct {
		result1 error
	}
	SetegidStub        func(egid int) (err error)
	setegidMutex       sync.RWMutex
	setegidArgsForCall []struct {
		egid int
	}
	setegidReturns struct {
		result1 error
	}
	setegidReturnsOnCall map[int]struct {
		result1 error
	}
	SeteuidStub        func(euid int) (err error)
	seteuidMutex       sync.RWMutex
	seteuidArgsForCall []struct {
		euid int
	}
	seteuidReturns struct {
		result1 error
	}
	seteuidReturnsOnCall map[int]struct {
		result1 error
	}
	SetloginStub        func(name string) (err error)
	setloginMutex       sync.RWMutex
	setloginArgsForCall []struct {
		name string
	}
	setloginReturns struct {
		result1 error
	}
	setloginReturnsOnCall map[int]struct {
		result1 error
	}
	SetpgidStub        func(pid int, pgid int) (err error)
	setpgidMutex       sync.RWMutex
	setpgidArgsForCall []struct {
		pid  int
		pgid int
	}
	setpgidReturns struct {
		result1 error
	}
	setpgidReturnsOnCall map[int]struct {
		result1 error
	}
	SetpriorityStub        func(which int, who int, prio int) (err error)
	setpriorityMutex       sync.RWMutex
	setpriorityArgsForCall []struct {
		which int
		who   int
		prio  int
	}
	setpriorityReturns struct {
		result1 error
	}
	setpriorityReturnsOnCall map[int]struct {
		result1 error
	}
	SetprivexecStub        func(flag int) (err error)
	setprivexecMutex       sync.RWMutex
	setprivexecArgsForCall []struct {
		flag int
	}
	setprivexecReturns struct {
		result1 error
	}
	setprivexecReturnsOnCall map[int]struct {
		result1 error
	}
	SetregidStub        func(rgid int, egid int) (err error)
	setregidMutex       sync.RWMutex
	setregidArgsForCall []struct {
		rgid int
		egid int
	}
	setregidReturns struct {
		result1 error
	}
	setregidReturnsOnCall map[int]struct {
		result1 error
	}
	SetreuidStub        func(ruid int, euid int) (err error)
	setreuidMutex       sync.RWMutex
	setreuidArgsForCall []struct {
		ruid int
		euid int
	}
	setreuidReturns struct {
		result1 error
	}
	setreuidReturnsOnCall map[int]struct {
		result1 error
	}
	SetsidStub        func() (pid int, err error)
	setsidMutex       sync.RWMutex
	setsidArgsForCall []struct{}
	setsidReturns     struct {
		result1 int
		result2 error
	}
	setsidReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SettimeofdayStub        func(tp *syscall.Timeval) (err error)
	settimeofdayMutex       sync.RWMutex
	settimeofdayArgsForCall []struct {
		tp *syscall.Timeval
	}
	settimeofdayReturns struct {
		result1 error
	}
	settimeofdayReturnsOnCall map[int]struct {
		result1 error
	}
	SyncStub        func() (err error)
	syncMutex       sync.RWMutex
	syncArgsForCall []struct{}
	syncReturns     struct {
		result1 error
	}
	syncReturnsOnCall map[int]struct {
		result1 error
	}
	UmaskStub        func(newmask int) (oldmask int)
	umaskMutex       sync.RWMutex
	umaskArgsForCall []struct {
		newmask int
	}
	umaskReturns struct {
		result1 int
	}
	umaskReturnsOnCall map[int]struct {
		result1 int
	}
	UndeleteStub        func(path string) (err error)
	undeleteMutex       sync.RWMutex
	undeleteArgsForCall []struct {
		path string
	}
	undeleteReturns struct {
		result1 error
	}
	undeleteReturnsOnCall map[int]struct {
		result1 error
	}
	NanosleepStub        func(time *syscall.Timespec, leftover *syscall.Timespec) (err error)
	nanosleepMutex       sync.RWMutex
	nanosleepArgsForCall []struct {
		time     *syscall.Timespec
		leftover *syscall.Timespec
	}
	nanosleepReturns struct {
		result1 error
	}
	nanosleepReturnsOnCall map[int]struct {
		result1 error
	}
	AcctStub        func(path string) (err error)
	acctMutex       sync.RWMutex
	acctArgsForCall []struct {
		path string
	}
	acctReturns struct {
		result1 error
	}
	acctReturnsOnCall map[int]struct {
		result1 error
	}
	AdjtimexStub        func(buf *syscall.Timex) (state int, err error)
	adjtimexMutex       sync.RWMutex
	adjtimexArgsForCall []struct {
		buf *syscall.Timex
	}
	adjtimexReturns struct {
		result1 int
		result2 error
	}
	adjtimexReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	Dup3Stub        func(oldfd int, newfd int, flags int) (err error)
	dup3Mutex       sync.RWMutex
	dup3ArgsForCall []struct {
		oldfd int
		newfd int
		flags int
	}
	dup3Returns struct {
		result1 error
	}
	dup3ReturnsOnCall map[int]struct {
		result1 error
	}
	EpollCreateStub        func(size int) (fd int, err error)
	epollCreateMutex       sync.RWMutex
	epollCreateArgsForCall []struct {
		size int
	}
	epollCreateReturns struct {
		result1 int
		result2 error
	}
	epollCreateReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	EpollCreate1Stub        func(flag int) (fd int, err error)
	epollCreate1Mutex       sync.RWMutex
	epollCreate1ArgsForCall []struct {
		flag int
	}
	epollCreate1Returns struct {
		result1 int
		result2 error
	}
	epollCreate1ReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	EpollCtlStub        func(epfd int, op int, fd int, event *syscall.EpollEvent) (err error)
	epollCtlMutex       sync.RWMutex
	epollCtlArgsForCall []struct {
		epfd  int
		op    int
		fd    int
		event *syscall.EpollEvent
	}
	epollCtlReturns struct {
		result1 error
	}
	epollCtlReturnsOnCall map[int]struct {
		result1 error
	}
	EpollWaitStub        func(epfd int, events []syscall.EpollEvent, msec int) (n int, err error)
	epollWaitMutex       sync.RWMutex
	epollWaitArgsForCall []struct {
		epfd   int
		events []syscall.EpollEvent
		msec   int
	}
	epollWaitReturns struct {
		result1 int
		result2 error
	}
	epollWaitReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	FaccessatStub        func(dirfd int, path string, mode uint32, flags int) (err error)
	faccessatMutex       sync.RWMutex
	faccessatArgsForCall []struct {
		dirfd int
		path  string
		mode  uint32
		flags int
	}
	faccessatReturns struct {
		result1 error
	}
	faccessatReturnsOnCall map[int]struct {
		result1 error
	}
	FallocateStub        func(fd int, mode uint32, off int64, len int64) (err error)
	fallocateMutex       sync.RWMutex
	fallocateArgsForCall []struct {
		fd   int
		mode uint32
		off  int64
		len  int64
	}
	fallocateReturns struct {
		result1 error
	}
	fallocateReturnsOnCall map[int]struct {
		result1 error
	}
	FchmodatStub        func(dirfd int, path string, mode uint32, flags int) (err error)
	fchmodatMutex       sync.RWMutex
	fchmodatArgsForCall []struct {
		dirfd int
		path  string
		mode  uint32
		flags int
	}
	fchmodatReturns struct {
		result1 error
	}
	fchmodatReturnsOnCall map[int]struct {
		result1 error
	}
	FchownatStub        func(dirfd int, path string, uid int, gid int, flags int) (err error)
	fchownatMutex       sync.RWMutex
	fchownatArgsForCall []struct {
		dirfd int
		path  string
		uid   int
		gid   int
		flags int
	}
	fchownatReturns struct {
		result1 error
	}
	fchownatReturnsOnCall map[int]struct {
		result1 error
	}
	FdatasyncStub        func(fd int) (err error)
	fdatasyncMutex       sync.RWMutex
	fdatasyncArgsForCall []struct {
		fd int
	}
	fdatasyncReturns struct {
		result1 error
	}
	fdatasyncReturnsOnCall map[int]struct {
		result1 error
	}
	GetdentsStub        func(fd int, buf []byte) (n int, err error)
	getdentsMutex       sync.RWMutex
	getdentsArgsForCall []struct {
		fd  int
		buf []byte
	}
	getdentsReturns struct {
		result1 int
		result2 error
	}
	getdentsReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GettidStub        func() (tid int)
	gettidMutex       sync.RWMutex
	gettidArgsForCall []struct{}
	gettidReturns     struct {
		result1 int
	}
	gettidReturnsOnCall map[int]struct {
		result1 int
	}
	GetxattrStub        func(path string, attr string, dest []byte) (sz int, err error)
	getxattrMutex       sync.RWMutex
	getxattrArgsForCall []struct {
		path string
		attr string
		dest []byte
	}
	getxattrReturns struct {
		result1 int
		result2 error
	}
	getxattrReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	InotifyAddWatchStub        func(fd int, pathname string, mask uint32) (watchdesc int, err error)
	inotifyAddWatchMutex       sync.RWMutex
	inotifyAddWatchArgsForCall []struct {
		fd       int
		pathname string
		mask     uint32
	}
	inotifyAddWatchReturns struct {
		result1 int
		result2 error
	}
	inotifyAddWatchReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	InotifyInit1Stub        func(flags int) (fd int, err error)
	inotifyInit1Mutex       sync.RWMutex
	inotifyInit1ArgsForCall []struct {
		flags int
	}
	inotifyInit1Returns struct {
		result1 int
		result2 error
	}
	inotifyInit1ReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	InotifyRmWatchStub        func(fd int, watchdesc uint32) (success int, err error)
	inotifyRmWatchMutex       sync.RWMutex
	inotifyRmWatchArgsForCall []struct {
		fd        int
		watchdesc uint32
	}
	inotifyRmWatchReturns struct {
		result1 int
		result2 error
	}
	inotifyRmWatchReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	KlogctlStub        func(typ int, buf []byte) (n int, err error)
	klogctlMutex       sync.RWMutex
	klogctlArgsForCall []struct {
		typ int
		buf []byte
	}
	klogctlReturns struct {
		result1 int
		result2 error
	}
	klogctlReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	ListxattrStub        func(path string, dest []byte) (sz int, err error)
	listxattrMutex       sync.RWMutex
	listxattrArgsForCall []struct {
		path string
		dest []byte
	}
	listxattrReturns struct {
		result1 int
		result2 error
	}
	listxattrReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	MkdiratStub        func(dirfd int, path string, mode uint32) (err error)
	mkdiratMutex       sync.RWMutex
	mkdiratArgsForCall []struct {
		dirfd int
		path  string
		mode  uint32
	}
	mkdiratReturns struct {
		result1 error
	}
	mkdiratReturnsOnCall map[int]struct {
		result1 error
	}
	MknodatStub        func(dirfd int, path string, mode uint32, dev int) (err error)
	mknodatMutex       sync.RWMutex
	mknodatArgsForCall []struct {
		dirfd int
		path  string
		mode  uint32
		dev   int
	}
	mknodatReturns struct {
		result1 error
	}
	mknodatReturnsOnCall map[int]struct {
		result1 error
	}
	PauseStub        func() (err error)
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct{}
	pauseReturns     struct {
		result1 error
	}
	pauseReturnsOnCall map[int]struct {
		result1 error
	}
	PivotRootStub        func(newroot string, putold string) (err error)
	pivotRootMutex       sync.RWMutex
	pivotRootArgsForCall []struct {
		newroot string
		putold  string
	}
	pivotRootReturns struct {
		result1 error
	}
	pivotRootReturnsOnCall map[int]struct {
		result1 error
	}
	RemovexattrStub        func(path string, attr string) (err error)
	removexattrMutex       sync.RWMutex
	removexattrArgsForCall []struct {
		path string
		attr string
	}
	removexattrReturns struct {
		result1 error
	}
	removexattrReturnsOnCall map[int]struct {
		result1 error
	}
	RenameatStub        func(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)
	renameatMutex       sync.RWMutex
	renameatArgsForCall []struct {
		olddirfd int
		oldpath  string
		newdirfd int
		newpath  string
	}
	renameatReturns struct {
		result1 error
	}
	renameatReturnsOnCall map[int]struct {
		result1 error
	}
	SetdomainnameStub        func(p []byte) (err error)
	setdomainnameMutex       sync.RWMutex
	setdomainnameArgsForCall []struct {
		p []byte
	}
	setdomainnameReturns struct {
		result1 error
	}
	setdomainnameReturnsOnCall map[int]struct {
		result1 error
	}
	SethostnameStub        func(p []byte) (err error)
	sethostnameMutex       sync.RWMutex
	sethostnameArgsForCall []struct {
		p []byte
	}
	sethostnameReturns struct {
		result1 error
	}
	sethostnameReturnsOnCall map[int]struct {
		result1 error
	}
	SetxattrStub        func(path string, attr string, data []byte, flags int) (err error)
	setxattrMutex       sync.RWMutex
	setxattrArgsForCall []struct {
		path  string
		attr  string
		data  []byte
		flags int
	}
	setxattrReturns struct {
		result1 error
	}
	setxattrReturnsOnCall map[int]struct {
		result1 error
	}
	SysinfoStub        func(info *syscall.Sysinfo_t) (err error)
	sysinfoMutex       sync.RWMutex
	sysinfoArgsForCall []struct {
		info *syscall.Sysinfo_t
	}
	sysinfoReturns struct {
		result1 error
	}
	sysinfoReturnsOnCall map[int]struct {
		result1 error
	}
	TeeStub        func(rfd int, wfd int, len int, flags int) (n int64, err error)
	teeMutex       sync.RWMutex
	teeArgsForCall []struct {
		rfd   int
		wfd   int
		len   int
		flags int
	}
	teeReturns struct {
		result1 int64
		result2 error
	}
	teeReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	TgkillStub        func(tgid int, tid int, sig syscall.Signal) (err error)
	tgkillMutex       sync.RWMutex
	tgkillArgsForCall []struct {
		tgid int
		tid  int
		sig  syscall.Signal
	}
	tgkillReturns struct {
		result1 error
	}
	tgkillReturnsOnCall map[int]struct {
		result1 error
	}
	TimesStub        func(tms *syscall.Tms) (ticks uintptr, err error)
	timesMutex       sync.RWMutex
	timesArgsForCall []struct {
		tms *syscall.Tms
	}
	timesReturns struct {
		result1 uintptr
		result2 error
	}
	timesReturnsOnCall map[int]struct {
		result1 uintptr
		result2 error
	}
	UnameStub        func(buf *syscall.Utsname) (err error)
	unameMutex       sync.RWMutex
	unameArgsForCall []struct {
		buf *syscall.Utsname
	}
	unameReturns struct {
		result1 error
	}
	unameReturnsOnCall map[int]struct {
		result1 error
	}
	UnshareStub        func(flags int) (err error)
	unshareMutex       sync.RWMutex
	unshareArgsForCall []struct {
		flags int
	}
	unshareReturns struct {
		result1 error
	}
	unshareReturnsOnCall map[int]struct {
		result1 error
	}
	UstatStub        func(dev int, ubuf *syscall.Ustat_t) (err error)
	ustatMutex       sync.RWMutex
	ustatArgsForCall []struct {
		dev  int
		ubuf *syscall.Ustat_t
	}
	ustatReturns struct {
		result1 error
	}
	ustatReturnsOnCall map[int]struct {
		result1 error
	}
	UtimeStub        func(path string, buf *syscall.Utimbuf) (err error)
	utimeMutex       sync.RWMutex
	utimeArgsForCall []struct {
		path string
		buf  *syscall.Utimbuf
	}
	utimeReturns struct {
		result1 error
	}
	utimeReturnsOnCall map[int]struct {
		result1 error
	}
	MadviseStub        func(b []byte, advice int) (err error)
	madviseMutex       sync.RWMutex
	madviseArgsForCall []struct {
		b      []byte
		advice int
	}
	madviseReturns struct {
		result1 error
	}
	madviseReturnsOnCall map[int]struct {
		result1 error
	}
	SetfsgidStub        func(gid int) (err error)
	setfsgidMutex       sync.RWMutex
	setfsgidArgsForCall []struct {
		gid int
	}
	setfsgidReturns struct {
		result1 error
	}
	setfsgidReturnsOnCall map[int]struct {
		result1 error
	}
	SetfsuidStub        func(uid int) (err error)
	setfsuidMutex       sync.RWMutex
	setfsuidArgsForCall []struct {
		uid int
	}
	setfsuidReturns struct {
		result1 error
	}
	setfsuidReturnsOnCall map[int]struct {
		result1 error
	}
	SetresgidStub        func(rgid int, egid int, sgid int) (err error)
	setresgidMutex       sync.RWMutex
	setresgidArgsForCall []struct {
		rgid int
		egid int
		sgid int
	}
	setresgidReturns struct {
		result1 error
	}
	setresgidReturnsOnCall map[int]struct {
		result1 error
	}
	SetresuidStub        func(ruid int, euid int, suid int) (err error)
	setresuidMutex       sync.RWMutex
	setresuidArgsForCall []struct {
		ruid int
		euid int
		suid int
	}
	setresuidReturns struct {
		result1 error
	}
	setresuidReturnsOnCall map[int]struct {
		result1 error
	}
	SpliceStub        func(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)
	spliceMutex       sync.RWMutex
	spliceArgsForCall []struct {
		rfd   int
		roff  *int64
		wfd   int
		woff  *int64
		len   int
		flags int
	}
	spliceReturns struct {
		result1 int
		result2 error
	}
	spliceReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	SyncFileRangeStub        func(fd int, off int64, n int64, flags int) (err error)
	syncFileRangeMutex       sync.RWMutex
	syncFileRangeArgsForCall []struct {
		fd    int
		off   int64
		n     int64
		flags int
	}
	syncFileRangeReturns struct {
		result1 error
	}
	syncFileRangeReturnsOnCall map[int]struct {
		result1 error
	}
	FstatatStub        func(fd int, path string, stat *syscall.Stat_t, flags int) (err error)
	fstatatMutex       sync.RWMutex
	fstatatArgsForCall []struct {
		fd    int
		path  string
		stat  *syscall.Stat_t
		flags int
	}
	fstatatReturns struct {
		result1 error
	}
	fstatatReturnsOnCall map[int]struct {
		result1 error
	}
	FwstatStub        func(fd int, edir []byte) (err error)
	fwstatMutex       sync.RWMutex
	fwstatArgsForCall []struct {
		fd   int
		edir []byte
	}
	fwstatReturns struct {
		result1 error
	}
	fwstatReturnsOnCall map[int]struct {
		result1 error
	}
	GetLastErrorStub        func() (lasterr error)
	getLastErrorMutex       sync.RWMutex
	getLastErrorArgsForCall []struct{}
	getLastErrorReturns     struct {
		result1 error
	}
	getLastErrorReturnsOnCall map[int]struct {
		result1 error
	}
	LoadLibraryStub        func(libname string) (handle syscall.Handle, err error)
	loadLibraryMutex       sync.RWMutex
	loadLibraryArgsForCall []struct {
		libname string
	}
	loadLibraryReturns struct {
		result1 syscall.Handle
		result2 error
	}
	loadLibraryReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	FreeLibraryStub        func(handle syscall.Handle) (err error)
	freeLibraryMutex       sync.RWMutex
	freeLibraryArgsForCall []struct {
		handle syscall.Handle
	}
	freeLibraryReturns struct {
		result1 error
	}
	freeLibraryReturnsOnCall map[int]struct {
		result1 error
	}
	GetProcAddressStub        func(module syscall.Handle, procname string) (proc uintptr, err error)
	getProcAddressMutex       sync.RWMutex
	getProcAddressArgsForCall []struct {
		module   syscall.Handle
		procname string
	}
	getProcAddressReturns struct {
		result1 uintptr
		result2 error
	}
	getProcAddressReturnsOnCall map[int]struct {
		result1 uintptr
		result2 error
	}
	GetVersionStub        func() (ver uint32, err error)
	getVersionMutex       sync.RWMutex
	getVersionArgsForCall []struct{}
	getVersionReturns     struct {
		result1 uint32
		result2 error
	}
	getVersionReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	ExitProcessStub        func(exitcode uint32)
	exitProcessMutex       sync.RWMutex
	exitProcessArgsForCall []struct {
		exitcode uint32
	}
	CreateFileStub        func(name *uint16, access uint32, mode uint32, sa *syscall.SecurityAttributes, createmode uint32, attrs uint32, templatefile int32) (handle syscall.Handle, err error)
	createFileMutex       sync.RWMutex
	createFileArgsForCall []struct {
		name         *uint16
		access       uint32
		mode         uint32
		sa           *syscall.SecurityAttributes
		createmode   uint32
		attrs        uint32
		templatefile int32
	}
	createFileReturns struct {
		result1 syscall.Handle
		result2 error
	}
	createFileReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	ReadFileStub        func(handle syscall.Handle, buf []byte, done *uint32, overlapped *syscall.Overlapped) (err error)
	readFileMutex       sync.RWMutex
	readFileArgsForCall []struct {
		handle     syscall.Handle
		buf        []byte
		done       *uint32
		overlapped *syscall.Overlapped
	}
	readFileReturns struct {
		result1 error
	}
	readFileReturnsOnCall map[int]struct {
		result1 error
	}
	WriteFileStub        func(handle syscall.Handle, buf []byte, done *uint32, overlapped *syscall.Overlapped) (err error)
	writeFileMutex       sync.RWMutex
	writeFileArgsForCall []struct {
		handle     syscall.Handle
		buf        []byte
		done       *uint32
		overlapped *syscall.Overlapped
	}
	writeFileReturns struct {
		result1 error
	}
	writeFileReturnsOnCall map[int]struct {
		result1 error
	}
	SetFilePointerStub        func(handle syscall.Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, err error)
	setFilePointerMutex       sync.RWMutex
	setFilePointerArgsForCall []struct {
		handle        syscall.Handle
		lowoffset     int32
		highoffsetptr *int32
		whence        uint32
	}
	setFilePointerReturns struct {
		result1 uint32
		result2 error
	}
	setFilePointerReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	CloseHandleStub        func(handle syscall.Handle) (err error)
	closeHandleMutex       sync.RWMutex
	closeHandleArgsForCall []struct {
		handle syscall.Handle
	}
	closeHandleReturns struct {
		result1 error
	}
	closeHandleReturnsOnCall map[int]struct {
		result1 error
	}
	GetStdHandleStub        func(stdhandle int) (handle syscall.Handle, err error)
	getStdHandleMutex       sync.RWMutex
	getStdHandleArgsForCall []struct {
		stdhandle int
	}
	getStdHandleReturns struct {
		result1 syscall.Handle
		result2 error
	}
	getStdHandleReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	FindCloseStub        func(handle syscall.Handle) (err error)
	findCloseMutex       sync.RWMutex
	findCloseArgsForCall []struct {
		handle syscall.Handle
	}
	findCloseReturns struct {
		result1 error
	}
	findCloseReturnsOnCall map[int]struct {
		result1 error
	}
	GetFileInformationByHandleStub        func(handle syscall.Handle, data *syscall.ByHandleFileInformation) (err error)
	getFileInformationByHandleMutex       sync.RWMutex
	getFileInformationByHandleArgsForCall []struct {
		handle syscall.Handle
		data   *syscall.ByHandleFileInformation
	}
	getFileInformationByHandleReturns struct {
		result1 error
	}
	getFileInformationByHandleReturnsOnCall map[int]struct {
		result1 error
	}
	GetCurrentDirectoryStub        func(buflen uint32, buf *uint16) (n uint32, err error)
	getCurrentDirectoryMutex       sync.RWMutex
	getCurrentDirectoryArgsForCall []struct {
		buflen uint32
		buf    *uint16
	}
	getCurrentDirectoryReturns struct {
		result1 uint32
		result2 error
	}
	getCurrentDirectoryReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	SetCurrentDirectoryStub        func(path *uint16) (err error)
	setCurrentDirectoryMutex       sync.RWMutex
	setCurrentDirectoryArgsForCall []struct {
		path *uint16
	}
	setCurrentDirectoryReturns struct {
		result1 error
	}
	setCurrentDirectoryReturnsOnCall map[int]struct {
		result1 error
	}
	CreateDirectoryStub        func(path *uint16, sa *syscall.SecurityAttributes) (err error)
	createDirectoryMutex       sync.RWMutex
	createDirectoryArgsForCall []struct {
		path *uint16
		sa   *syscall.SecurityAttributes
	}
	createDirectoryReturns struct {
		result1 error
	}
	createDirectoryReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveDirectoryStub        func(path *uint16) (err error)
	removeDirectoryMutex       sync.RWMutex
	removeDirectoryArgsForCall []struct {
		path *uint16
	}
	removeDirectoryReturns struct {
		result1 error
	}
	removeDirectoryReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteFileStub        func(path *uint16) (err error)
	deleteFileMutex       sync.RWMutex
	deleteFileArgsForCall []struct {
		path *uint16
	}
	deleteFileReturns struct {
		result1 error
	}
	deleteFileReturnsOnCall map[int]struct {
		result1 error
	}
	MoveFileStub        func(from *uint16, to *uint16) (err error)
	moveFileMutex       sync.RWMutex
	moveFileArgsForCall []struct {
		from *uint16
		to   *uint16
	}
	moveFileReturns struct {
		result1 error
	}
	moveFileReturnsOnCall map[int]struct {
		result1 error
	}
	GetComputerNameStub        func(buf *uint16, n *uint32) (err error)
	getComputerNameMutex       sync.RWMutex
	getComputerNameArgsForCall []struct {
		buf *uint16
		n   *uint32
	}
	getComputerNameReturns struct {
		result1 error
	}
	getComputerNameReturnsOnCall map[int]struct {
		result1 error
	}
	SetEndOfFileStub        func(handle syscall.Handle) (err error)
	setEndOfFileMutex       sync.RWMutex
	setEndOfFileArgsForCall []struct {
		handle syscall.Handle
	}
	setEndOfFileReturns struct {
		result1 error
	}
	setEndOfFileReturnsOnCall map[int]struct {
		result1 error
	}
	GetSystemTimeAsFileTimeStub        func(time *syscall.Filetime)
	getSystemTimeAsFileTimeMutex       sync.RWMutex
	getSystemTimeAsFileTimeArgsForCall []struct {
		time *syscall.Filetime
	}
	GetTimeZoneInformationStub        func(tzi *syscall.Timezoneinformation) (rc uint32, err error)
	getTimeZoneInformationMutex       sync.RWMutex
	getTimeZoneInformationArgsForCall []struct {
		tzi *syscall.Timezoneinformation
	}
	getTimeZoneInformationReturns struct {
		result1 uint32
		result2 error
	}
	getTimeZoneInformationReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	CreateIoCompletionPortStub        func(filehandle syscall.Handle, cphandle syscall.Handle, key uint32, threadcnt uint32) (handle syscall.Handle, err error)
	createIoCompletionPortMutex       sync.RWMutex
	createIoCompletionPortArgsForCall []struct {
		filehandle syscall.Handle
		cphandle   syscall.Handle
		key        uint32
		threadcnt  uint32
	}
	createIoCompletionPortReturns struct {
		result1 syscall.Handle
		result2 error
	}
	createIoCompletionPortReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	GetQueuedCompletionStatusStub        func(cphandle syscall.Handle, qty *uint32, key *uint32, overlapped **syscall.Overlapped, timeout uint32) (err error)
	getQueuedCompletionStatusMutex       sync.RWMutex
	getQueuedCompletionStatusArgsForCall []struct {
		cphandle   syscall.Handle
		qty        *uint32
		key        *uint32
		overlapped **syscall.Overlapped
		timeout    uint32
	}
	getQueuedCompletionStatusReturns struct {
		result1 error
	}
	getQueuedCompletionStatusReturnsOnCall map[int]struct {
		result1 error
	}
	PostQueuedCompletionStatusStub        func(cphandle syscall.Handle, qty uint32, key uint32, overlapped *syscall.Overlapped) (err error)
	postQueuedCompletionStatusMutex       sync.RWMutex
	postQueuedCompletionStatusArgsForCall []struct {
		cphandle   syscall.Handle
		qty        uint32
		key        uint32
		overlapped *syscall.Overlapped
	}
	postQueuedCompletionStatusReturns struct {
		result1 error
	}
	postQueuedCompletionStatusReturnsOnCall map[int]struct {
		result1 error
	}
	CancelIoStub        func(s syscall.Handle) (err error)
	cancelIoMutex       sync.RWMutex
	cancelIoArgsForCall []struct {
		s syscall.Handle
	}
	cancelIoReturns struct {
		result1 error
	}
	cancelIoReturnsOnCall map[int]struct {
		result1 error
	}
	CancelIoExStub        func(s syscall.Handle, o *syscall.Overlapped) (err error)
	cancelIoExMutex       sync.RWMutex
	cancelIoExArgsForCall []struct {
		s syscall.Handle
		o *syscall.Overlapped
	}
	cancelIoExReturns struct {
		result1 error
	}
	cancelIoExReturnsOnCall map[int]struct {
		result1 error
	}
	CreateProcessStub        func(appName *uint16, commandLine *uint16, procSecurity *syscall.SecurityAttributes, threadSecurity *syscall.SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *syscall.StartupInfo, outProcInfo *syscall.ProcessInformation) (err error)
	createProcessMutex       sync.RWMutex
	createProcessArgsForCall []struct {
		appName        *uint16
		commandLine    *uint16
		procSecurity   *syscall.SecurityAttributes
		threadSecurity *syscall.SecurityAttributes
		inheritHandles bool
		creationFlags  uint32
		env            *uint16
		currentDir     *uint16
		startupInfo    *syscall.StartupInfo
		outProcInfo    *syscall.ProcessInformation
	}
	createProcessReturns struct {
		result1 error
	}
	createProcessReturnsOnCall map[int]struct {
		result1 error
	}
	OpenProcessStub        func(da uint32, inheritHandle bool, pid uint32) (handle syscall.Handle, err error)
	openProcessMutex       sync.RWMutex
	openProcessArgsForCall []struct {
		da            uint32
		inheritHandle bool
		pid           uint32
	}
	openProcessReturns struct {
		result1 syscall.Handle
		result2 error
	}
	openProcessReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	TerminateProcessStub        func(handle syscall.Handle, exitcode uint32) (err error)
	terminateProcessMutex       sync.RWMutex
	terminateProcessArgsForCall []struct {
		handle   syscall.Handle
		exitcode uint32
	}
	terminateProcessReturns struct {
		result1 error
	}
	terminateProcessReturnsOnCall map[int]struct {
		result1 error
	}
	GetExitCodeProcessStub        func(handle syscall.Handle, exitcode *uint32) (err error)
	getExitCodeProcessMutex       sync.RWMutex
	getExitCodeProcessArgsForCall []struct {
		handle   syscall.Handle
		exitcode *uint32
	}
	getExitCodeProcessReturns struct {
		result1 error
	}
	getExitCodeProcessReturnsOnCall map[int]struct {
		result1 error
	}
	GetStartupInfoStub        func(startupInfo *syscall.StartupInfo) (err error)
	getStartupInfoMutex       sync.RWMutex
	getStartupInfoArgsForCall []struct {
		startupInfo *syscall.StartupInfo
	}
	getStartupInfoReturns struct {
		result1 error
	}
	getStartupInfoReturnsOnCall map[int]struct {
		result1 error
	}
	GetCurrentProcessStub        func() (pseudoHandle syscall.Handle, err error)
	getCurrentProcessMutex       sync.RWMutex
	getCurrentProcessArgsForCall []struct{}
	getCurrentProcessReturns     struct {
		result1 syscall.Handle
		result2 error
	}
	getCurrentProcessReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	GetProcessTimesStub        func(handle syscall.Handle, creationTime *syscall.Filetime, exitTime *syscall.Filetime, kernelTime *syscall.Filetime, userTime *syscall.Filetime) (err error)
	getProcessTimesMutex       sync.RWMutex
	getProcessTimesArgsForCall []struct {
		handle       syscall.Handle
		creationTime *syscall.Filetime
		exitTime     *syscall.Filetime
		kernelTime   *syscall.Filetime
		userTime     *syscall.Filetime
	}
	getProcessTimesReturns struct {
		result1 error
	}
	getProcessTimesReturnsOnCall map[int]struct {
		result1 error
	}
	DuplicateHandleStub        func(hSourceProcessHandle syscall.Handle, hSourceHandle syscall.Handle, hTargetProcessHandle syscall.Handle, lpTargetHandle *syscall.Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error)
	duplicateHandleMutex       sync.RWMutex
	duplicateHandleArgsForCall []struct {
		hSourceProcessHandle syscall.Handle
		hSourceHandle        syscall.Handle
		hTargetProcessHandle syscall.Handle
		lpTargetHandle       *syscall.Handle
		dwDesiredAccess      uint32
		bInheritHandle       bool
		dwOptions            uint32
	}
	duplicateHandleReturns struct {
		result1 error
	}
	duplicateHandleReturnsOnCall map[int]struct {
		result1 error
	}
	WaitForSingleObjectStub        func(handle syscall.Handle, waitMilliseconds uint32) (event uint32, err error)
	waitForSingleObjectMutex       sync.RWMutex
	waitForSingleObjectArgsForCall []struct {
		handle           syscall.Handle
		waitMilliseconds uint32
	}
	waitForSingleObjectReturns struct {
		result1 uint32
		result2 error
	}
	waitForSingleObjectReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	GetTempPathStub        func(buflen uint32, buf *uint16) (n uint32, err error)
	getTempPathMutex       sync.RWMutex
	getTempPathArgsForCall []struct {
		buflen uint32
		buf    *uint16
	}
	getTempPathReturns struct {
		result1 uint32
		result2 error
	}
	getTempPathReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	CreatePipeStub        func(readhandle *syscall.Handle, writehandle *syscall.Handle, sa *syscall.SecurityAttributes, size uint32) (err error)
	createPipeMutex       sync.RWMutex
	createPipeArgsForCall []struct {
		readhandle  *syscall.Handle
		writehandle *syscall.Handle
		sa          *syscall.SecurityAttributes
		size        uint32
	}
	createPipeReturns struct {
		result1 error
	}
	createPipeReturnsOnCall map[int]struct {
		result1 error
	}
	GetFileTypeStub        func(filehandle syscall.Handle) (n uint32, err error)
	getFileTypeMutex       sync.RWMutex
	getFileTypeArgsForCall []struct {
		filehandle syscall.Handle
	}
	getFileTypeReturns struct {
		result1 uint32
		result2 error
	}
	getFileTypeReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	CryptAcquireContextStub        func(provhandle *syscall.Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error)
	cryptAcquireContextMutex       sync.RWMutex
	cryptAcquireContextArgsForCall []struct {
		provhandle *syscall.Handle
		container  *uint16
		provider   *uint16
		provtype   uint32
		flags      uint32
	}
	cryptAcquireContextReturns struct {
		result1 error
	}
	cryptAcquireContextReturnsOnCall map[int]struct {
		result1 error
	}
	CryptReleaseContextStub        func(provhandle syscall.Handle, flags uint32) (err error)
	cryptReleaseContextMutex       sync.RWMutex
	cryptReleaseContextArgsForCall []struct {
		provhandle syscall.Handle
		flags      uint32
	}
	cryptReleaseContextReturns struct {
		result1 error
	}
	cryptReleaseContextReturnsOnCall map[int]struct {
		result1 error
	}
	CryptGenRandomStub        func(provhandle syscall.Handle, buflen uint32, buf *byte) (err error)
	cryptGenRandomMutex       sync.RWMutex
	cryptGenRandomArgsForCall []struct {
		provhandle syscall.Handle
		buflen     uint32
		buf        *byte
	}
	cryptGenRandomReturns struct {
		result1 error
	}
	cryptGenRandomReturnsOnCall map[int]struct {
		result1 error
	}
	GetEnvironmentStringsStub        func() (envs *uint16, err error)
	getEnvironmentStringsMutex       sync.RWMutex
	getEnvironmentStringsArgsForCall []struct{}
	getEnvironmentStringsReturns     struct {
		result1 *uint16
		result2 error
	}
	getEnvironmentStringsReturnsOnCall map[int]struct {
		result1 *uint16
		result2 error
	}
	FreeEnvironmentStringsStub        func(envs *uint16) (err error)
	freeEnvironmentStringsMutex       sync.RWMutex
	freeEnvironmentStringsArgsForCall []struct {
		envs *uint16
	}
	freeEnvironmentStringsReturns struct {
		result1 error
	}
	freeEnvironmentStringsReturnsOnCall map[int]struct {
		result1 error
	}
	GetEnvironmentVariableStub        func(name *uint16, buffer *uint16, size uint32) (n uint32, err error)
	getEnvironmentVariableMutex       sync.RWMutex
	getEnvironmentVariableArgsForCall []struct {
		name   *uint16
		buffer *uint16
		size   uint32
	}
	getEnvironmentVariableReturns struct {
		result1 uint32
		result2 error
	}
	getEnvironmentVariableReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	SetEnvironmentVariableStub        func(name *uint16, value *uint16) (err error)
	setEnvironmentVariableMutex       sync.RWMutex
	setEnvironmentVariableArgsForCall []struct {
		name  *uint16
		value *uint16
	}
	setEnvironmentVariableReturns struct {
		result1 error
	}
	setEnvironmentVariableReturnsOnCall map[int]struct {
		result1 error
	}
	SetFileTimeStub        func(handle syscall.Handle, ctime *syscall.Filetime, atime *syscall.Filetime, wtime *syscall.Filetime) (err error)
	setFileTimeMutex       sync.RWMutex
	setFileTimeArgsForCall []struct {
		handle syscall.Handle
		ctime  *syscall.Filetime
		atime  *syscall.Filetime
		wtime  *syscall.Filetime
	}
	setFileTimeReturns struct {
		result1 error
	}
	setFileTimeReturnsOnCall map[int]struct {
		result1 error
	}
	GetFileAttributesStub        func(name *uint16) (attrs uint32, err error)
	getFileAttributesMutex       sync.RWMutex
	getFileAttributesArgsForCall []struct {
		name *uint16
	}
	getFileAttributesReturns struct {
		result1 uint32
		result2 error
	}
	getFileAttributesReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	SetFileAttributesStub        func(name *uint16, attrs uint32) (err error)
	setFileAttributesMutex       sync.RWMutex
	setFileAttributesArgsForCall []struct {
		name  *uint16
		attrs uint32
	}
	setFileAttributesReturns struct {
		result1 error
	}
	setFileAttributesReturnsOnCall map[int]struct {
		result1 error
	}
	GetFileAttributesExStub        func(name *uint16, level uint32, info *byte) (err error)
	getFileAttributesExMutex       sync.RWMutex
	getFileAttributesExArgsForCall []struct {
		name  *uint16
		level uint32
		info  *byte
	}
	getFileAttributesExReturns struct {
		result1 error
	}
	getFileAttributesExReturnsOnCall map[int]struct {
		result1 error
	}
	GetCommandLineStub        func() (cmd *uint16)
	getCommandLineMutex       sync.RWMutex
	getCommandLineArgsForCall []struct{}
	getCommandLineReturns     struct {
		result1 *uint16
	}
	getCommandLineReturnsOnCall map[int]struct {
		result1 *uint16
	}
	CommandLineToArgvStub        func(cmd *uint16, argc *int32) (argv *[8192]*[8192]uint16, err error)
	commandLineToArgvMutex       sync.RWMutex
	commandLineToArgvArgsForCall []struct {
		cmd  *uint16
		argc *int32
	}
	commandLineToArgvReturns struct {
		result1 *[8192]*[8192]uint16
		result2 error
	}
	commandLineToArgvReturnsOnCall map[int]struct {
		result1 *[8192]*[8192]uint16
		result2 error
	}
	LocalFreeStub        func(hmem syscall.Handle) (handle syscall.Handle, err error)
	localFreeMutex       sync.RWMutex
	localFreeArgsForCall []struct {
		hmem syscall.Handle
	}
	localFreeReturns struct {
		result1 syscall.Handle
		result2 error
	}
	localFreeReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	SetHandleInformationStub        func(handle syscall.Handle, mask uint32, flags uint32) (err error)
	setHandleInformationMutex       sync.RWMutex
	setHandleInformationArgsForCall []struct {
		handle syscall.Handle
		mask   uint32
		flags  uint32
	}
	setHandleInformationReturns struct {
		result1 error
	}
	setHandleInformationReturnsOnCall map[int]struct {
		result1 error
	}
	FlushFileBuffersStub        func(handle syscall.Handle) (err error)
	flushFileBuffersMutex       sync.RWMutex
	flushFileBuffersArgsForCall []struct {
		handle syscall.Handle
	}
	flushFileBuffersReturns struct {
		result1 error
	}
	flushFileBuffersReturnsOnCall map[int]struct {
		result1 error
	}
	GetFullPathNameStub        func(path *uint16, buflen uint32, buf *uint16, fname **uint16) (n uint32, err error)
	getFullPathNameMutex       sync.RWMutex
	getFullPathNameArgsForCall []struct {
		path   *uint16
		buflen uint32
		buf    *uint16
		fname  **uint16
	}
	getFullPathNameReturns struct {
		result1 uint32
		result2 error
	}
	getFullPathNameReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	GetLongPathNameStub        func(path *uint16, buf *uint16, buflen uint32) (n uint32, err error)
	getLongPathNameMutex       sync.RWMutex
	getLongPathNameArgsForCall []struct {
		path   *uint16
		buf    *uint16
		buflen uint32
	}
	getLongPathNameReturns struct {
		result1 uint32
		result2 error
	}
	getLongPathNameReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	GetShortPathNameStub        func(longpath *uint16, shortpath *uint16, buflen uint32) (n uint32, err error)
	getShortPathNameMutex       sync.RWMutex
	getShortPathNameArgsForCall []struct {
		longpath  *uint16
		shortpath *uint16
		buflen    uint32
	}
	getShortPathNameReturns struct {
		result1 uint32
		result2 error
	}
	getShortPathNameReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	CreateFileMappingStub        func(fhandle syscall.Handle, sa *syscall.SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle syscall.Handle, err error)
	createFileMappingMutex       sync.RWMutex
	createFileMappingArgsForCall []struct {
		fhandle     syscall.Handle
		sa          *syscall.SecurityAttributes
		prot        uint32
		maxSizeHigh uint32
		maxSizeLow  uint32
		name        *uint16
	}
	createFileMappingReturns struct {
		result1 syscall.Handle
		result2 error
	}
	createFileMappingReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	MapViewOfFileStub        func(handle syscall.Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, err error)
	mapViewOfFileMutex       sync.RWMutex
	mapViewOfFileArgsForCall []struct {
		handle     syscall.Handle
		access     uint32
		offsetHigh uint32
		offsetLow  uint32
		length     uintptr
	}
	mapViewOfFileReturns struct {
		result1 uintptr
		result2 error
	}
	mapViewOfFileReturnsOnCall map[int]struct {
		result1 uintptr
		result2 error
	}
	UnmapViewOfFileStub        func(addr uintptr) (err error)
	unmapViewOfFileMutex       sync.RWMutex
	unmapViewOfFileArgsForCall []struct {
		addr uintptr
	}
	unmapViewOfFileReturns struct {
		result1 error
	}
	unmapViewOfFileReturnsOnCall map[int]struct {
		result1 error
	}
	FlushViewOfFileStub        func(addr uintptr, length uintptr) (err error)
	flushViewOfFileMutex       sync.RWMutex
	flushViewOfFileArgsForCall []struct {
		addr   uintptr
		length uintptr
	}
	flushViewOfFileReturns struct {
		result1 error
	}
	flushViewOfFileReturnsOnCall map[int]struct {
		result1 error
	}
	VirtualLockStub        func(addr uintptr, length uintptr) (err error)
	virtualLockMutex       sync.RWMutex
	virtualLockArgsForCall []struct {
		addr   uintptr
		length uintptr
	}
	virtualLockReturns struct {
		result1 error
	}
	virtualLockReturnsOnCall map[int]struct {
		result1 error
	}
	VirtualUnlockStub        func(addr uintptr, length uintptr) (err error)
	virtualUnlockMutex       sync.RWMutex
	virtualUnlockArgsForCall []struct {
		addr   uintptr
		length uintptr
	}
	virtualUnlockReturns struct {
		result1 error
	}
	virtualUnlockReturnsOnCall map[int]struct {
		result1 error
	}
	TransmitFileStub        func(s syscall.Handle, handle syscall.Handle, bytesToWrite uint32, bytsPerSend uint32, overlapped *syscall.Overlapped, transmitFileBuf *syscall.TransmitFileBuffers, flags uint32) (err error)
	transmitFileMutex       sync.RWMutex
	transmitFileArgsForCall []struct {
		s               syscall.Handle
		handle          syscall.Handle
		bytesToWrite    uint32
		bytsPerSend     uint32
		overlapped      *syscall.Overlapped
		transmitFileBuf *syscall.TransmitFileBuffers
		flags           uint32
	}
	transmitFileReturns struct {
		result1 error
	}
	transmitFileReturnsOnCall map[int]struct {
		result1 error
	}
	ReadDirectoryChangesStub        func(handle syscall.Handle, buf *byte, buflen uint32, watchSubTree bool, mask uint32, retlen *uint32, overlapped *syscall.Overlapped, completionRoutine uintptr) (err error)
	readDirectoryChangesMutex       sync.RWMutex
	readDirectoryChangesArgsForCall []struct {
		handle            syscall.Handle
		buf               *byte
		buflen            uint32
		watchSubTree      bool
		mask              uint32
		retlen            *uint32
		overlapped        *syscall.Overlapped
		completionRoutine uintptr
	}
	readDirectoryChangesReturns struct {
		result1 error
	}
	readDirectoryChangesReturnsOnCall map[int]struct {
		result1 error
	}
	CertOpenSystemStoreStub        func(hprov syscall.Handle, name *uint16) (store syscall.Handle, err error)
	certOpenSystemStoreMutex       sync.RWMutex
	certOpenSystemStoreArgsForCall []struct {
		hprov syscall.Handle
		name  *uint16
	}
	certOpenSystemStoreReturns struct {
		result1 syscall.Handle
		result2 error
	}
	certOpenSystemStoreReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	CertOpenStoreStub        func(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle syscall.Handle, err error)
	certOpenStoreMutex       sync.RWMutex
	certOpenStoreArgsForCall []struct {
		storeProvider          uintptr
		msgAndCertEncodingType uint32
		cryptProv              uintptr
		flags                  uint32
		para                   uintptr
	}
	certOpenStoreReturns struct {
		result1 syscall.Handle
		result2 error
	}
	certOpenStoreReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	CertEnumCertificatesInStoreStub        func(store syscall.Handle, prevContext *syscall.CertContext) (context *syscall.CertContext, err error)
	certEnumCertificatesInStoreMutex       sync.RWMutex
	certEnumCertificatesInStoreArgsForCall []struct {
		store       syscall.Handle
		prevContext *syscall.CertContext
	}
	certEnumCertificatesInStoreReturns struct {
		result1 *syscall.CertContext
		result2 error
	}
	certEnumCertificatesInStoreReturnsOnCall map[int]struct {
		result1 *syscall.CertContext
		result2 error
	}
	CertAddCertificateContextToStoreStub        func(store syscall.Handle, certContext *syscall.CertContext, addDisposition uint32, storeContext **syscall.CertContext) (err error)
	certAddCertificateContextToStoreMutex       sync.RWMutex
	certAddCertificateContextToStoreArgsForCall []struct {
		store          syscall.Handle
		certContext    *syscall.CertContext
		addDisposition uint32
		storeContext   **syscall.CertContext
	}
	certAddCertificateContextToStoreReturns struct {
		result1 error
	}
	certAddCertificateContextToStoreReturnsOnCall map[int]struct {
		result1 error
	}
	CertCloseStoreStub        func(store syscall.Handle, flags uint32) (err error)
	certCloseStoreMutex       sync.RWMutex
	certCloseStoreArgsForCall []struct {
		store syscall.Handle
		flags uint32
	}
	certCloseStoreReturns struct {
		result1 error
	}
	certCloseStoreReturnsOnCall map[int]struct {
		result1 error
	}
	CertGetCertificateChainStub        func(engine syscall.Handle, leaf *syscall.CertContext, time *syscall.Filetime, additionalStore syscall.Handle, para *syscall.CertChainPara, flags uint32, reserved uintptr, chainCtx **syscall.CertChainContext) (err error)
	certGetCertificateChainMutex       sync.RWMutex
	certGetCertificateChainArgsForCall []struct {
		engine          syscall.Handle
		leaf            *syscall.CertContext
		time            *syscall.Filetime
		additionalStore syscall.Handle
		para            *syscall.CertChainPara
		flags           uint32
		reserved        uintptr
		chainCtx        **syscall.CertChainContext
	}
	certGetCertificateChainReturns struct {
		result1 error
	}
	certGetCertificateChainReturnsOnCall map[int]struct {
		result1 error
	}
	CertFreeCertificateChainStub        func(ctx *syscall.CertChainContext)
	certFreeCertificateChainMutex       sync.RWMutex
	certFreeCertificateChainArgsForCall []struct {
		ctx *syscall.CertChainContext
	}
	CertCreateCertificateContextStub        func(certEncodingType uint32, certEncoded *byte, encodedLen uint32) (context *syscall.CertContext, err error)
	certCreateCertificateContextMutex       sync.RWMutex
	certCreateCertificateContextArgsForCall []struct {
		certEncodingType uint32
		certEncoded      *byte
		encodedLen       uint32
	}
	certCreateCertificateContextReturns struct {
		result1 *syscall.CertContext
		result2 error
	}
	certCreateCertificateContextReturnsOnCall map[int]struct {
		result1 *syscall.CertContext
		result2 error
	}
	CertFreeCertificateContextStub        func(ctx *syscall.CertContext) (err error)
	certFreeCertificateContextMutex       sync.RWMutex
	certFreeCertificateContextArgsForCall []struct {
		ctx *syscall.CertContext
	}
	certFreeCertificateContextReturns struct {
		result1 error
	}
	certFreeCertificateContextReturnsOnCall map[int]struct {
		result1 error
	}
	CertVerifyCertificateChainPolicyStub        func(policyOID uintptr, chain *syscall.CertChainContext, para *syscall.CertChainPolicyPara, status *syscall.CertChainPolicyStatus) (err error)
	certVerifyCertificateChainPolicyMutex       sync.RWMutex
	certVerifyCertificateChainPolicyArgsForCall []struct {
		policyOID uintptr
		chain     *syscall.CertChainContext
		para      *syscall.CertChainPolicyPara
		status    *syscall.CertChainPolicyStatus
	}
	certVerifyCertificateChainPolicyReturns struct {
		result1 error
	}
	certVerifyCertificateChainPolicyReturnsOnCall map[int]struct {
		result1 error
	}
	RegOpenKeyExStub        func(key syscall.Handle, subkey *uint16, options uint32, desiredAccess uint32, result *syscall.Handle) (regerrno error)
	regOpenKeyExMutex       sync.RWMutex
	regOpenKeyExArgsForCall []struct {
		key           syscall.Handle
		subkey        *uint16
		options       uint32
		desiredAccess uint32
		result        *syscall.Handle
	}
	regOpenKeyExReturns struct {
		result1 error
	}
	regOpenKeyExReturnsOnCall map[int]struct {
		result1 error
	}
	RegCloseKeyStub        func(key syscall.Handle) (regerrno error)
	regCloseKeyMutex       sync.RWMutex
	regCloseKeyArgsForCall []struct {
		key syscall.Handle
	}
	regCloseKeyReturns struct {
		result1 error
	}
	regCloseKeyReturnsOnCall map[int]struct {
		result1 error
	}
	RegQueryInfoKeyStub        func(key syscall.Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *syscall.Filetime) (regerrno error)
	regQueryInfoKeyMutex       sync.RWMutex
	regQueryInfoKeyArgsForCall []struct {
		key             syscall.Handle
		class           *uint16
		classLen        *uint32
		reserved        *uint32
		subkeysLen      *uint32
		maxSubkeyLen    *uint32
		maxClassLen     *uint32
		valuesLen       *uint32
		maxValueNameLen *uint32
		maxValueLen     *uint32
		saLen           *uint32
		lastWriteTime   *syscall.Filetime
	}
	regQueryInfoKeyReturns struct {
		result1 error
	}
	regQueryInfoKeyReturnsOnCall map[int]struct {
		result1 error
	}
	RegEnumKeyExStub        func(key syscall.Handle, index uint32, name *uint16, nameLen *uint32, reserved *uint32, class *uint16, classLen *uint32, lastWriteTime *syscall.Filetime) (regerrno error)
	regEnumKeyExMutex       sync.RWMutex
	regEnumKeyExArgsForCall []struct {
		key           syscall.Handle
		index         uint32
		name          *uint16
		nameLen       *uint32
		reserved      *uint32
		class         *uint16
		classLen      *uint32
		lastWriteTime *syscall.Filetime
	}
	regEnumKeyExReturns struct {
		result1 error
	}
	regEnumKeyExReturnsOnCall map[int]struct {
		result1 error
	}
	RegQueryValueExStub        func(key syscall.Handle, name *uint16, reserved *uint32, valtype *uint32, buf *byte, buflen *uint32) (regerrno error)
	regQueryValueExMutex       sync.RWMutex
	regQueryValueExArgsForCall []struct {
		key      syscall.Handle
		name     *uint16
		reserved *uint32
		valtype  *uint32
		buf      *byte
		buflen   *uint32
	}
	regQueryValueExReturns struct {
		result1 error
	}
	regQueryValueExReturnsOnCall map[int]struct {
		result1 error
	}
	GetConsoleModeStub        func(console syscall.Handle, mode *uint32) (err error)
	getConsoleModeMutex       sync.RWMutex
	getConsoleModeArgsForCall []struct {
		console syscall.Handle
		mode    *uint32
	}
	getConsoleModeReturns struct {
		result1 error
	}
	getConsoleModeReturnsOnCall map[int]struct {
		result1 error
	}
	WriteConsoleStub        func(console syscall.Handle, buf *uint16, towrite uint32, written *uint32, reserved *byte) (err error)
	writeConsoleMutex       sync.RWMutex
	writeConsoleArgsForCall []struct {
		console  syscall.Handle
		buf      *uint16
		towrite  uint32
		written  *uint32
		reserved *byte
	}
	writeConsoleReturns struct {
		result1 error
	}
	writeConsoleReturnsOnCall map[int]struct {
		result1 error
	}
	ReadConsoleStub        func(console syscall.Handle, buf *uint16, toread uint32, read *uint32, inputControl *byte) (err error)
	readConsoleMutex       sync.RWMutex
	readConsoleArgsForCall []struct {
		console      syscall.Handle
		buf          *uint16
		toread       uint32
		read         *uint32
		inputControl *byte
	}
	readConsoleReturns struct {
		result1 error
	}
	readConsoleReturnsOnCall map[int]struct {
		result1 error
	}
	CreateToolhelp32SnapshotStub        func(flags uint32, processId uint32) (handle syscall.Handle, err error)
	createToolhelp32SnapshotMutex       sync.RWMutex
	createToolhelp32SnapshotArgsForCall []struct {
		flags     uint32
		processId uint32
	}
	createToolhelp32SnapshotReturns struct {
		result1 syscall.Handle
		result2 error
	}
	createToolhelp32SnapshotReturnsOnCall map[int]struct {
		result1 syscall.Handle
		result2 error
	}
	Process32FirstStub        func(snapshot syscall.Handle, procEntry *syscall.ProcessEntry32) (err error)
	process32FirstMutex       sync.RWMutex
	process32FirstArgsForCall []struct {
		snapshot  syscall.Handle
		procEntry *syscall.ProcessEntry32
	}
	process32FirstReturns struct {
		result1 error
	}
	process32FirstReturnsOnCall map[int]struct {
		result1 error
	}
	Process32NextStub        func(snapshot syscall.Handle, procEntry *syscall.ProcessEntry32) (err error)
	process32NextMutex       sync.RWMutex
	process32NextArgsForCall []struct {
		snapshot  syscall.Handle
		procEntry *syscall.ProcessEntry32
	}
	process32NextReturns struct {
		result1 error
	}
	process32NextReturnsOnCall map[int]struct {
		result1 error
	}
	DeviceIoControlStub        func(handle syscall.Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *syscall.Overlapped) (err error)
	deviceIoControlMutex       sync.RWMutex
	deviceIoControlArgsForCall []struct {
		handle        syscall.Handle
		ioControlCode uint32
		inBuffer      *byte
		inBufferSize  uint32
		outBuffer     *byte
		outBufferSize uint32
		bytesReturned *uint32
		overlapped    *syscall.Overlapped
	}
	deviceIoControlReturns struct {
		result1 error
	}
	deviceIoControlReturnsOnCall map[int]struct {
		result1 error
	}
	CreateSymbolicLinkStub        func(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error)
	createSymbolicLinkMutex       sync.RWMutex
	createSymbolicLinkArgsForCall []struct {
		symlinkfilename *uint16
		targetfilename  *uint16
		flags           uint32
	}
	createSymbolicLinkReturns struct {
		result1 error
	}
	createSymbolicLinkReturnsOnCall map[int]struct {
		result1 error
	}
	CreateHardLinkStub        func(filename *uint16, existingfilename *uint16, reserved uintptr) (err error)
	createHardLinkMutex       sync.RWMutex
	createHardLinkArgsForCall []struct {
		filename         *uint16
		existingfilename *uint16
		reserved         uintptr
	}
	createHardLinkReturns struct {
		result1 error
	}
	createHardLinkReturnsOnCall map[int]struct {
		result1 error
	}
	WSAStartupStub        func(verreq uint32, data *syscall.WSAData) (sockerr error)
	wSAStartupMutex       sync.RWMutex
	wSAStartupArgsForCall []struct {
		verreq uint32
		data   *syscall.WSAData
	}
	wSAStartupReturns struct {
		result1 error
	}
	wSAStartupReturnsOnCall map[int]struct {
		result1 error
	}
	WSACleanupStub        func() (err error)
	wSACleanupMutex       sync.RWMutex
	wSACleanupArgsForCall []struct{}
	wSACleanupReturns     struct {
		result1 error
	}
	wSACleanupReturnsOnCall map[int]struct {
		result1 error
	}
	WSAIoctlStub        func(s syscall.Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *syscall.Overlapped, completionRoutine uintptr) (err error)
	wSAIoctlMutex       sync.RWMutex
	wSAIoctlArgsForCall []struct {
		s                 syscall.Handle
		iocc              uint32
		inbuf             *byte
		cbif              uint32
		outbuf            *byte
		cbob              uint32
		cbbr              *uint32
		overlapped        *syscall.Overlapped
		completionRoutine uintptr
	}
	wSAIoctlReturns struct {
		result1 error
	}
	wSAIoctlReturnsOnCall map[int]struct {
		result1 error
	}
	SetsockoptStub        func(s syscall.Handle, level int32, optname int32, optval *byte, optlen int32) (err error)
	setsockoptMutex       sync.RWMutex
	setsockoptArgsForCall []struct {
		s       syscall.Handle
		level   int32
		optname int32
		optval  *byte
		optlen  int32
	}
	setsockoptReturns struct {
		result1 error
	}
	setsockoptReturnsOnCall map[int]struct {
		result1 error
	}
	GetsockoptStub        func(s syscall.Handle, level int32, optname int32, optval *byte, optlen *int32) (err error)
	getsockoptMutex       sync.RWMutex
	getsockoptArgsForCall []struct {
		s       syscall.Handle
		level   int32
		optname int32
		optval  *byte
		optlen  *int32
	}
	getsockoptReturns struct {
		result1 error
	}
	getsockoptReturnsOnCall map[int]struct {
		result1 error
	}
	ClosesocketStub        func(s syscall.Handle) (err error)
	closesocketMutex       sync.RWMutex
	closesocketArgsForCall []struct {
		s syscall.Handle
	}
	closesocketReturns struct {
		result1 error
	}
	closesocketReturnsOnCall map[int]struct {
		result1 error
	}
	AcceptExStub        func(ls syscall.Handle, as syscall.Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *syscall.Overlapped) (err error)
	acceptExMutex       sync.RWMutex
	acceptExArgsForCall []struct {
		ls         syscall.Handle
		as         syscall.Handle
		buf        *byte
		rxdatalen  uint32
		laddrlen   uint32
		raddrlen   uint32
		recvd      *uint32
		overlapped *syscall.Overlapped
	}
	acceptExReturns struct {
		result1 error
	}
	acceptExReturnsOnCall map[int]struct {
		result1 error
	}
	GetAcceptExSockaddrsStub        func(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **syscall.RawSockaddrAny, lrsalen *int32, rrsa **syscall.RawSockaddrAny, rrsalen *int32)
	getAcceptExSockaddrsMutex       sync.RWMutex
	getAcceptExSockaddrsArgsForCall []struct {
		buf       *byte
		rxdatalen uint32
		laddrlen  uint32
		raddrlen  uint32
		lrsa      **syscall.RawSockaddrAny
		lrsalen   *int32
		rrsa      **syscall.RawSockaddrAny
		rrsalen   *int32
	}
	WSARecvStub        func(s syscall.Handle, bufs *syscall.WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *syscall.Overlapped, croutine *byte) (err error)
	wSARecvMutex       sync.RWMutex
	wSARecvArgsForCall []struct {
		s          syscall.Handle
		bufs       *syscall.WSABuf
		bufcnt     uint32
		recvd      *uint32
		flags      *uint32
		overlapped *syscall.Overlapped
		croutine   *byte
	}
	wSARecvReturns struct {
		result1 error
	}
	wSARecvReturnsOnCall map[int]struct {
		result1 error
	}
	WSASendStub        func(s syscall.Handle, bufs *syscall.WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *syscall.Overlapped, croutine *byte) (err error)
	wSASendMutex       sync.RWMutex
	wSASendArgsForCall []struct {
		s          syscall.Handle
		bufs       *syscall.WSABuf
		bufcnt     uint32
		sent       *uint32
		flags      uint32
		overlapped *syscall.Overlapped
		croutine   *byte
	}
	wSASendReturns struct {
		result1 error
	}
	wSASendReturnsOnCall map[int]struct {
		result1 error
	}
	WSARecvFromStub        func(s syscall.Handle, bufs *syscall.WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, from *syscall.RawSockaddrAny, fromlen *int32, overlapped *syscall.Overlapped, croutine *byte) (err error)
	wSARecvFromMutex       sync.RWMutex
	wSARecvFromArgsForCall []struct {
		s          syscall.Handle
		bufs       *syscall.WSABuf
		bufcnt     uint32
		recvd      *uint32
		flags      *uint32
		from       *syscall.RawSockaddrAny
		fromlen    *int32
		overlapped *syscall.Overlapped
		croutine   *byte
	}
	wSARecvFromReturns struct {
		result1 error
	}
	wSARecvFromReturnsOnCall map[int]struct {
		result1 error
	}
	WSASendToStub        func(s syscall.Handle, bufs *syscall.WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *syscall.RawSockaddrAny, tolen int32, overlapped *syscall.Overlapped, croutine *byte) (err error)
	wSASendToMutex       sync.RWMutex
	wSASendToArgsForCall []struct {
		s          syscall.Handle
		bufs       *syscall.WSABuf
		bufcnt     uint32
		sent       *uint32
		flags      uint32
		to         *syscall.RawSockaddrAny
		tolen      int32
		overlapped *syscall.Overlapped
		croutine   *byte
	}
	wSASendToReturns struct {
		result1 error
	}
	wSASendToReturnsOnCall map[int]struct {
		result1 error
	}
	GetHostByNameStub        func(name string) (h *syscall.Hostent, err error)
	getHostByNameMutex       sync.RWMutex
	getHostByNameArgsForCall []struct {
		name string
	}
	getHostByNameReturns struct {
		result1 *syscall.Hostent
		result2 error
	}
	getHostByNameReturnsOnCall map[int]struct {
		result1 *syscall.Hostent
		result2 error
	}
	GetServByNameStub        func(name string, proto string) (s *syscall.Servent, err error)
	getServByNameMutex       sync.RWMutex
	getServByNameArgsForCall []struct {
		name  string
		proto string
	}
	getServByNameReturns struct {
		result1 *syscall.Servent
		result2 error
	}
	getServByNameReturnsOnCall map[int]struct {
		result1 *syscall.Servent
		result2 error
	}
	NtohsStub        func(netshort uint16) (u uint16)
	ntohsMutex       sync.RWMutex
	ntohsArgsForCall []struct {
		netshort uint16
	}
	ntohsReturns struct {
		result1 uint16
	}
	ntohsReturnsOnCall map[int]struct {
		result1 uint16
	}
	GetProtoByNameStub        func(name string) (p *syscall.Protoent, err error)
	getProtoByNameMutex       sync.RWMutex
	getProtoByNameArgsForCall []struct {
		name string
	}
	getProtoByNameReturns struct {
		result1 *syscall.Protoent
		result2 error
	}
	getProtoByNameReturnsOnCall map[int]struct {
		result1 *syscall.Protoent
		result2 error
	}
	DnsQueryStub        func(name string, qtype uint16, options uint32, extra *byte, qrs **syscall.DNSRecord, pr *byte) (status error)
	dnsQueryMutex       sync.RWMutex
	dnsQueryArgsForCall []struct {
		name    string
		qtype   uint16
		options uint32
		extra   *byte
		qrs     **syscall.DNSRecord
		pr      *byte
	}
	dnsQueryReturns struct {
		result1 error
	}
	dnsQueryReturnsOnCall map[int]struct {
		result1 error
	}
	DnsRecordListFreeStub        func(rl *syscall.DNSRecord, freetype uint32)
	dnsRecordListFreeMutex       sync.RWMutex
	dnsRecordListFreeArgsForCall []struct {
		rl       *syscall.DNSRecord
		freetype uint32
	}
	DnsNameCompareStub        func(name1 *uint16, name2 *uint16) (same bool)
	dnsNameCompareMutex       sync.RWMutex
	dnsNameCompareArgsForCall []struct {
		name1 *uint16
		name2 *uint16
	}
	dnsNameCompareReturns struct {
		result1 bool
	}
	dnsNameCompareReturnsOnCall map[int]struct {
		result1 bool
	}
	GetAddrInfoWStub        func(nodename *uint16, servicename *uint16, hints *syscall.AddrinfoW, result **syscall.AddrinfoW) (sockerr error)
	getAddrInfoWMutex       sync.RWMutex
	getAddrInfoWArgsForCall []struct {
		nodename    *uint16
		servicename *uint16
		hints       *syscall.AddrinfoW
		result      **syscall.AddrinfoW
	}
	getAddrInfoWReturns struct {
		result1 error
	}
	getAddrInfoWReturnsOnCall map[int]struct {
		result1 error
	}
	FreeAddrInfoWStub        func(addrinfo *syscall.AddrinfoW)
	freeAddrInfoWMutex       sync.RWMutex
	freeAddrInfoWArgsForCall []struct {
		addrinfo *syscall.AddrinfoW
	}
	GetIfEntryStub        func(pIfRow *syscall.MibIfRow) (errcode error)
	getIfEntryMutex       sync.RWMutex
	getIfEntryArgsForCall []struct {
		pIfRow *syscall.MibIfRow
	}
	getIfEntryReturns struct {
		result1 error
	}
	getIfEntryReturnsOnCall map[int]struct {
		result1 error
	}
	GetAdaptersInfoStub        func(ai *syscall.IpAdapterInfo, ol *uint32) (errcode error)
	getAdaptersInfoMutex       sync.RWMutex
	getAdaptersInfoArgsForCall []struct {
		ai *syscall.IpAdapterInfo
		ol *uint32
	}
	getAdaptersInfoReturns struct {
		result1 error
	}
	getAdaptersInfoReturnsOnCall map[int]struct {
		result1 error
	}
	SetFileCompletionNotificationModesStub        func(handle syscall.Handle, flags uint8) (err error)
	setFileCompletionNotificationModesMutex       sync.RWMutex
	setFileCompletionNotificationModesArgsForCall []struct {
		handle syscall.Handle
		flags  uint8
	}
	setFileCompletionNotificationModesReturns struct {
		result1 error
	}
	setFileCompletionNotificationModesReturnsOnCall map[int]struct {
		result1 error
	}
	WSAEnumProtocolsStub        func(protocols *int32, protocolBuffer *syscall.WSAProtocolInfo, bufferLength *uint32) (n int32, err error)
	wSAEnumProtocolsMutex       sync.RWMutex
	wSAEnumProtocolsArgsForCall []struct {
		protocols      *int32
		protocolBuffer *syscall.WSAProtocolInfo
		bufferLength   *uint32
	}
	wSAEnumProtocolsReturns struct {
		result1 int32
		result2 error
	}
	wSAEnumProtocolsReturnsOnCall map[int]struct {
		result1 int32
		result2 error
	}
	TranslateNameStub        func(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error)
	translateNameMutex       sync.RWMutex
	translateNameArgsForCall []struct {
		accName           *uint16
		accNameFormat     uint32
		desiredNameFormat uint32
		translatedName    *uint16
		nSize             *uint32
	}
	translateNameReturns struct {
		result1 error
	}
	translateNameReturnsOnCall map[int]struct {
		result1 error
	}
	GetUserNameExStub        func(nameFormat uint32, nameBuffre *uint16, nSize *uint32) (err error)
	getUserNameExMutex       sync.RWMutex
	getUserNameExArgsForCall []struct {
		nameFormat uint32
		nameBuffre *uint16
		nSize      *uint32
	}
	getUserNameExReturns struct {
		result1 error
	}
	getUserNameExReturnsOnCall map[int]struct {
		result1 error
	}
	NetUserGetInfoStub        func(serverName *uint16, userName *uint16, level uint32, buf **byte) (neterr error)
	netUserGetInfoMutex       sync.RWMutex
	netUserGetInfoArgsForCall []struct {
		serverName *uint16
		userName   *uint16
		level      uint32
		buf        **byte
	}
	netUserGetInfoReturns struct {
		result1 error
	}
	netUserGetInfoReturnsOnCall map[int]struct {
		result1 error
	}
	NetGetJoinInformationStub        func(server *uint16, name **uint16, bufType *uint32) (neterr error)
	netGetJoinInformationMutex       sync.RWMutex
	netGetJoinInformationArgsForCall []struct {
		server  *uint16
		name    **uint16
		bufType *uint32
	}
	netGetJoinInformationReturns struct {
		result1 error
	}
	netGetJoinInformationReturnsOnCall map[int]struct {
		result1 error
	}
	NetApiBufferFreeStub        func(buf *byte) (neterr error)
	netApiBufferFreeMutex       sync.RWMutex
	netApiBufferFreeArgsForCall []struct {
		buf *byte
	}
	netApiBufferFreeReturns struct {
		result1 error
	}
	netApiBufferFreeReturnsOnCall map[int]struct {
		result1 error
	}
	LookupAccountSidStub        func(systemName *uint16, sid *syscall.SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error)
	lookupAccountSidMutex       sync.RWMutex
	lookupAccountSidArgsForCall []struct {
		systemName        *uint16
		sid               *syscall.SID
		name              *uint16
		nameLen           *uint32
		refdDomainName    *uint16
		refdDomainNameLen *uint32
		use               *uint32
	}
	lookupAccountSidReturns struct {
		result1 error
	}
	lookupAccountSidReturnsOnCall map[int]struct {
		result1 error
	}
	LookupAccountNameStub        func(systemName *uint16, accountName *uint16, sid *syscall.SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error)
	lookupAccountNameMutex       sync.RWMutex
	lookupAccountNameArgsForCall []struct {
		systemName        *uint16
		accountName       *uint16
		sid               *syscall.SID
		sidLen            *uint32
		refdDomainName    *uint16
		refdDomainNameLen *uint32
		use               *uint32
	}
	lookupAccountNameReturns struct {
		result1 error
	}
	lookupAccountNameReturnsOnCall map[int]struct {
		result1 error
	}
	ConvertSidToStringSidStub        func(sid *syscall.SID, stringSid **uint16) (err error)
	convertSidToStringSidMutex       sync.RWMutex
	convertSidToStringSidArgsForCall []struct {
		sid       *syscall.SID
		stringSid **uint16
	}
	convertSidToStringSidReturns struct {
		result1 error
	}
	convertSidToStringSidReturnsOnCall map[int]struct {
		result1 error
	}
	ConvertStringSidToSidStub        func(stringSid *uint16, sid **syscall.SID) (err error)
	convertStringSidToSidMutex       sync.RWMutex
	convertStringSidToSidArgsForCall []struct {
		stringSid *uint16
		sid       **syscall.SID
	}
	convertStringSidToSidReturns struct {
		result1 error
	}
	convertStringSidToSidReturnsOnCall map[int]struct {
		result1 error
	}
	GetLengthSidStub        func(sid *syscall.SID) (len uint32)
	getLengthSidMutex       sync.RWMutex
	getLengthSidArgsForCall []struct {
		sid *syscall.SID
	}
	getLengthSidReturns struct {
		result1 uint32
	}
	getLengthSidReturnsOnCall map[int]struct {
		result1 uint32
	}
	CopySidStub        func(destSidLen uint32, destSid *syscall.SID, srcSid *syscall.SID) (err error)
	copySidMutex       sync.RWMutex
	copySidArgsForCall []struct {
		destSidLen uint32
		destSid    *syscall.SID
		srcSid     *syscall.SID
	}
	copySidReturns struct {
		result1 error
	}
	copySidReturnsOnCall map[int]struct {
		result1 error
	}
	OpenProcessTokenStub        func(h syscall.Handle, access uint32, token *syscall.Token) (err error)
	openProcessTokenMutex       sync.RWMutex
	openProcessTokenArgsForCall []struct {
		h      syscall.Handle
		access uint32
		token  *syscall.Token
	}
	openProcessTokenReturns struct {
		result1 error
	}
	openProcessTokenReturnsOnCall map[int]struct {
		result1 error
	}
	GetTokenInformationStub        func(t syscall.Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error)
	getTokenInformationMutex       sync.RWMutex
	getTokenInformationArgsForCall []struct {
		t           syscall.Token
		infoClass   uint32
		info        *byte
		infoLen     uint32
		returnedLen *uint32
	}
	getTokenInformationReturns struct {
		result1 error
	}
	getTokenInformationReturnsOnCall map[int]struct {
		result1 error
	}
	GetUserProfileDirectoryStub        func(t syscall.Token, dir *uint16, dirLen *uint32) (err error)
	getUserProfileDirectoryMutex       sync.RWMutex
	getUserProfileDirectoryArgsForCall []struct {
		t      syscall.Token
		dir    *uint16
		dirLen *uint32
	}
	getUserProfileDirectoryReturns struct {
		result1 error
	}
	getUserProfileDirectoryReturnsOnCall map[int]struct {
		result1 error
	}
	NsecToFiletimeStub        func(nsec int64) (ft syscall.Filetime)
	nsecToFiletimeMutex       sync.RWMutex
	nsecToFiletimeArgsForCall []struct {
		nsec int64
	}
	nsecToFiletimeReturns struct {
		result1 syscall.Filetime
	}
	nsecToFiletimeReturnsOnCall map[int]struct {
		result1 syscall.Filetime
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSyscall) BpfStmt(code int, k int) *syscall.BpfInsn {
	fake.bpfStmtMutex.Lock()
	ret, specificReturn := fake.bpfStmtReturnsOnCall[len(fake.bpfStmtArgsForCall)]
	fake.bpfStmtArgsForCall = append(fake.bpfStmtArgsForCall, struct {
		code int
		k    int
	}{code, k})
	fake.recordInvocation("BpfStmt", []interface{}{code, k})
	fake.bpfStmtMutex.Unlock()
	if fake.BpfStmtStub != nil {
		return fake.BpfStmtStub(code, k)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bpfStmtReturns.result1
}

func (fake *FakeSyscall) BpfStmtCallCount() int {
	fake.bpfStmtMutex.RLock()
	defer fake.bpfStmtMutex.RUnlock()
	return len(fake.bpfStmtArgsForCall)
}

func (fake *FakeSyscall) BpfStmtArgsForCall(i int) (int, int) {
	fake.bpfStmtMutex.RLock()
	defer fake.bpfStmtMutex.RUnlock()
	return fake.bpfStmtArgsForCall[i].code, fake.bpfStmtArgsForCall[i].k
}

func (fake *FakeSyscall) BpfStmtReturns(result1 *syscall.BpfInsn) {
	fake.BpfStmtStub = nil
	fake.bpfStmtReturns = struct {
		result1 *syscall.BpfInsn
	}{result1}
}

func (fake *FakeSyscall) BpfStmtReturnsOnCall(i int, result1 *syscall.BpfInsn) {
	fake.BpfStmtStub = nil
	if fake.bpfStmtReturnsOnCall == nil {
		fake.bpfStmtReturnsOnCall = make(map[int]struct {
			result1 *syscall.BpfInsn
		})
	}
	fake.bpfStmtReturnsOnCall[i] = struct {
		result1 *syscall.BpfInsn
	}{result1}
}

func (fake *FakeSyscall) BpfJump(code int, k int, jt int, jf int) *syscall.BpfInsn {
	fake.bpfJumpMutex.Lock()
	ret, specificReturn := fake.bpfJumpReturnsOnCall[len(fake.bpfJumpArgsForCall)]
	fake.bpfJumpArgsForCall = append(fake.bpfJumpArgsForCall, struct {
		code int
		k    int
		jt   int
		jf   int
	}{code, k, jt, jf})
	fake.recordInvocation("BpfJump", []interface{}{code, k, jt, jf})
	fake.bpfJumpMutex.Unlock()
	if fake.BpfJumpStub != nil {
		return fake.BpfJumpStub(code, k, jt, jf)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bpfJumpReturns.result1
}

func (fake *FakeSyscall) BpfJumpCallCount() int {
	fake.bpfJumpMutex.RLock()
	defer fake.bpfJumpMutex.RUnlock()
	return len(fake.bpfJumpArgsForCall)
}

func (fake *FakeSyscall) BpfJumpArgsForCall(i int) (int, int, int, int) {
	fake.bpfJumpMutex.RLock()
	defer fake.bpfJumpMutex.RUnlock()
	return fake.bpfJumpArgsForCall[i].code, fake.bpfJumpArgsForCall[i].k, fake.bpfJumpArgsForCall[i].jt, fake.bpfJumpArgsForCall[i].jf
}

func (fake *FakeSyscall) BpfJumpReturns(result1 *syscall.BpfInsn) {
	fake.BpfJumpStub = nil
	fake.bpfJumpReturns = struct {
		result1 *syscall.BpfInsn
	}{result1}
}

func (fake *FakeSyscall) BpfJumpReturnsOnCall(i int, result1 *syscall.BpfInsn) {
	fake.BpfJumpStub = nil
	if fake.bpfJumpReturnsOnCall == nil {
		fake.bpfJumpReturnsOnCall = make(map[int]struct {
			result1 *syscall.BpfInsn
		})
	}
	fake.bpfJumpReturnsOnCall[i] = struct {
		result1 *syscall.BpfInsn
	}{result1}
}

func (fake *FakeSyscall) BpfBuflen(fd int) (int, error) {
	fake.bpfBuflenMutex.Lock()
	ret, specificReturn := fake.bpfBuflenReturnsOnCall[len(fake.bpfBuflenArgsForCall)]
	fake.bpfBuflenArgsForCall = append(fake.bpfBuflenArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("BpfBuflen", []interface{}{fd})
	fake.bpfBuflenMutex.Unlock()
	if fake.BpfBuflenStub != nil {
		return fake.BpfBuflenStub(fd)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.bpfBuflenReturns.result1, fake.bpfBuflenReturns.result2
}

func (fake *FakeSyscall) BpfBuflenCallCount() int {
	fake.bpfBuflenMutex.RLock()
	defer fake.bpfBuflenMutex.RUnlock()
	return len(fake.bpfBuflenArgsForCall)
}

func (fake *FakeSyscall) BpfBuflenArgsForCall(i int) int {
	fake.bpfBuflenMutex.RLock()
	defer fake.bpfBuflenMutex.RUnlock()
	return fake.bpfBuflenArgsForCall[i].fd
}

func (fake *FakeSyscall) BpfBuflenReturns(result1 int, result2 error) {
	fake.BpfBuflenStub = nil
	fake.bpfBuflenReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) BpfBuflenReturnsOnCall(i int, result1 int, result2 error) {
	fake.BpfBuflenStub = nil
	if fake.bpfBuflenReturnsOnCall == nil {
		fake.bpfBuflenReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.bpfBuflenReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetBpfBuflen(fd int, l int) (int, error) {
	fake.setBpfBuflenMutex.Lock()
	ret, specificReturn := fake.setBpfBuflenReturnsOnCall[len(fake.setBpfBuflenArgsForCall)]
	fake.setBpfBuflenArgsForCall = append(fake.setBpfBuflenArgsForCall, struct {
		fd int
		l  int
	}{fd, l})
	fake.recordInvocation("SetBpfBuflen", []interface{}{fd, l})
	fake.setBpfBuflenMutex.Unlock()
	if fake.SetBpfBuflenStub != nil {
		return fake.SetBpfBuflenStub(fd, l)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setBpfBuflenReturns.result1, fake.setBpfBuflenReturns.result2
}

func (fake *FakeSyscall) SetBpfBuflenCallCount() int {
	fake.setBpfBuflenMutex.RLock()
	defer fake.setBpfBuflenMutex.RUnlock()
	return len(fake.setBpfBuflenArgsForCall)
}

func (fake *FakeSyscall) SetBpfBuflenArgsForCall(i int) (int, int) {
	fake.setBpfBuflenMutex.RLock()
	defer fake.setBpfBuflenMutex.RUnlock()
	return fake.setBpfBuflenArgsForCall[i].fd, fake.setBpfBuflenArgsForCall[i].l
}

func (fake *FakeSyscall) SetBpfBuflenReturns(result1 int, result2 error) {
	fake.SetBpfBuflenStub = nil
	fake.setBpfBuflenReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetBpfBuflenReturnsOnCall(i int, result1 int, result2 error) {
	fake.SetBpfBuflenStub = nil
	if fake.setBpfBuflenReturnsOnCall == nil {
		fake.setBpfBuflenReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.setBpfBuflenReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) BpfDatalink(fd int) (int, error) {
	fake.bpfDatalinkMutex.Lock()
	ret, specificReturn := fake.bpfDatalinkReturnsOnCall[len(fake.bpfDatalinkArgsForCall)]
	fake.bpfDatalinkArgsForCall = append(fake.bpfDatalinkArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("BpfDatalink", []interface{}{fd})
	fake.bpfDatalinkMutex.Unlock()
	if fake.BpfDatalinkStub != nil {
		return fake.BpfDatalinkStub(fd)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.bpfDatalinkReturns.result1, fake.bpfDatalinkReturns.result2
}

func (fake *FakeSyscall) BpfDatalinkCallCount() int {
	fake.bpfDatalinkMutex.RLock()
	defer fake.bpfDatalinkMutex.RUnlock()
	return len(fake.bpfDatalinkArgsForCall)
}

func (fake *FakeSyscall) BpfDatalinkArgsForCall(i int) int {
	fake.bpfDatalinkMutex.RLock()
	defer fake.bpfDatalinkMutex.RUnlock()
	return fake.bpfDatalinkArgsForCall[i].fd
}

func (fake *FakeSyscall) BpfDatalinkReturns(result1 int, result2 error) {
	fake.BpfDatalinkStub = nil
	fake.bpfDatalinkReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) BpfDatalinkReturnsOnCall(i int, result1 int, result2 error) {
	fake.BpfDatalinkStub = nil
	if fake.bpfDatalinkReturnsOnCall == nil {
		fake.bpfDatalinkReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.bpfDatalinkReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetBpfDatalink(fd int, t int) (int, error) {
	fake.setBpfDatalinkMutex.Lock()
	ret, specificReturn := fake.setBpfDatalinkReturnsOnCall[len(fake.setBpfDatalinkArgsForCall)]
	fake.setBpfDatalinkArgsForCall = append(fake.setBpfDatalinkArgsForCall, struct {
		fd int
		t  int
	}{fd, t})
	fake.recordInvocation("SetBpfDatalink", []interface{}{fd, t})
	fake.setBpfDatalinkMutex.Unlock()
	if fake.SetBpfDatalinkStub != nil {
		return fake.SetBpfDatalinkStub(fd, t)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setBpfDatalinkReturns.result1, fake.setBpfDatalinkReturns.result2
}

func (fake *FakeSyscall) SetBpfDatalinkCallCount() int {
	fake.setBpfDatalinkMutex.RLock()
	defer fake.setBpfDatalinkMutex.RUnlock()
	return len(fake.setBpfDatalinkArgsForCall)
}

func (fake *FakeSyscall) SetBpfDatalinkArgsForCall(i int) (int, int) {
	fake.setBpfDatalinkMutex.RLock()
	defer fake.setBpfDatalinkMutex.RUnlock()
	return fake.setBpfDatalinkArgsForCall[i].fd, fake.setBpfDatalinkArgsForCall[i].t
}

func (fake *FakeSyscall) SetBpfDatalinkReturns(result1 int, result2 error) {
	fake.SetBpfDatalinkStub = nil
	fake.setBpfDatalinkReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetBpfDatalinkReturnsOnCall(i int, result1 int, result2 error) {
	fake.SetBpfDatalinkStub = nil
	if fake.setBpfDatalinkReturnsOnCall == nil {
		fake.setBpfDatalinkReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.setBpfDatalinkReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetBpfPromisc(fd int, m int) error {
	fake.setBpfPromiscMutex.Lock()
	ret, specificReturn := fake.setBpfPromiscReturnsOnCall[len(fake.setBpfPromiscArgsForCall)]
	fake.setBpfPromiscArgsForCall = append(fake.setBpfPromiscArgsForCall, struct {
		fd int
		m  int
	}{fd, m})
	fake.recordInvocation("SetBpfPromisc", []interface{}{fd, m})
	fake.setBpfPromiscMutex.Unlock()
	if fake.SetBpfPromiscStub != nil {
		return fake.SetBpfPromiscStub(fd, m)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setBpfPromiscReturns.result1
}

func (fake *FakeSyscall) SetBpfPromiscCallCount() int {
	fake.setBpfPromiscMutex.RLock()
	defer fake.setBpfPromiscMutex.RUnlock()
	return len(fake.setBpfPromiscArgsForCall)
}

func (fake *FakeSyscall) SetBpfPromiscArgsForCall(i int) (int, int) {
	fake.setBpfPromiscMutex.RLock()
	defer fake.setBpfPromiscMutex.RUnlock()
	return fake.setBpfPromiscArgsForCall[i].fd, fake.setBpfPromiscArgsForCall[i].m
}

func (fake *FakeSyscall) SetBpfPromiscReturns(result1 error) {
	fake.SetBpfPromiscStub = nil
	fake.setBpfPromiscReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetBpfPromiscReturnsOnCall(i int, result1 error) {
	fake.SetBpfPromiscStub = nil
	if fake.setBpfPromiscReturnsOnCall == nil {
		fake.setBpfPromiscReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setBpfPromiscReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FlushBpf(fd int) error {
	fake.flushBpfMutex.Lock()
	ret, specificReturn := fake.flushBpfReturnsOnCall[len(fake.flushBpfArgsForCall)]
	fake.flushBpfArgsForCall = append(fake.flushBpfArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("FlushBpf", []interface{}{fd})
	fake.flushBpfMutex.Unlock()
	if fake.FlushBpfStub != nil {
		return fake.FlushBpfStub(fd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.flushBpfReturns.result1
}

func (fake *FakeSyscall) FlushBpfCallCount() int {
	fake.flushBpfMutex.RLock()
	defer fake.flushBpfMutex.RUnlock()
	return len(fake.flushBpfArgsForCall)
}

func (fake *FakeSyscall) FlushBpfArgsForCall(i int) int {
	fake.flushBpfMutex.RLock()
	defer fake.flushBpfMutex.RUnlock()
	return fake.flushBpfArgsForCall[i].fd
}

func (fake *FakeSyscall) FlushBpfReturns(result1 error) {
	fake.FlushBpfStub = nil
	fake.flushBpfReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FlushBpfReturnsOnCall(i int, result1 error) {
	fake.FlushBpfStub = nil
	if fake.flushBpfReturnsOnCall == nil {
		fake.flushBpfReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.flushBpfReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) BpfInterface(fd int, name string) (string, error) {
	fake.bpfInterfaceMutex.Lock()
	ret, specificReturn := fake.bpfInterfaceReturnsOnCall[len(fake.bpfInterfaceArgsForCall)]
	fake.bpfInterfaceArgsForCall = append(fake.bpfInterfaceArgsForCall, struct {
		fd   int
		name string
	}{fd, name})
	fake.recordInvocation("BpfInterface", []interface{}{fd, name})
	fake.bpfInterfaceMutex.Unlock()
	if fake.BpfInterfaceStub != nil {
		return fake.BpfInterfaceStub(fd, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.bpfInterfaceReturns.result1, fake.bpfInterfaceReturns.result2
}

func (fake *FakeSyscall) BpfInterfaceCallCount() int {
	fake.bpfInterfaceMutex.RLock()
	defer fake.bpfInterfaceMutex.RUnlock()
	return len(fake.bpfInterfaceArgsForCall)
}

func (fake *FakeSyscall) BpfInterfaceArgsForCall(i int) (int, string) {
	fake.bpfInterfaceMutex.RLock()
	defer fake.bpfInterfaceMutex.RUnlock()
	return fake.bpfInterfaceArgsForCall[i].fd, fake.bpfInterfaceArgsForCall[i].name
}

func (fake *FakeSyscall) BpfInterfaceReturns(result1 string, result2 error) {
	fake.BpfInterfaceStub = nil
	fake.bpfInterfaceReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) BpfInterfaceReturnsOnCall(i int, result1 string, result2 error) {
	fake.BpfInterfaceStub = nil
	if fake.bpfInterfaceReturnsOnCall == nil {
		fake.bpfInterfaceReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.bpfInterfaceReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetBpfInterface(fd int, name string) error {
	fake.setBpfInterfaceMutex.Lock()
	ret, specificReturn := fake.setBpfInterfaceReturnsOnCall[len(fake.setBpfInterfaceArgsForCall)]
	fake.setBpfInterfaceArgsForCall = append(fake.setBpfInterfaceArgsForCall, struct {
		fd   int
		name string
	}{fd, name})
	fake.recordInvocation("SetBpfInterface", []interface{}{fd, name})
	fake.setBpfInterfaceMutex.Unlock()
	if fake.SetBpfInterfaceStub != nil {
		return fake.SetBpfInterfaceStub(fd, name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setBpfInterfaceReturns.result1
}

func (fake *FakeSyscall) SetBpfInterfaceCallCount() int {
	fake.setBpfInterfaceMutex.RLock()
	defer fake.setBpfInterfaceMutex.RUnlock()
	return len(fake.setBpfInterfaceArgsForCall)
}

func (fake *FakeSyscall) SetBpfInterfaceArgsForCall(i int) (int, string) {
	fake.setBpfInterfaceMutex.RLock()
	defer fake.setBpfInterfaceMutex.RUnlock()
	return fake.setBpfInterfaceArgsForCall[i].fd, fake.setBpfInterfaceArgsForCall[i].name
}

func (fake *FakeSyscall) SetBpfInterfaceReturns(result1 error) {
	fake.SetBpfInterfaceStub = nil
	fake.setBpfInterfaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetBpfInterfaceReturnsOnCall(i int, result1 error) {
	fake.SetBpfInterfaceStub = nil
	if fake.setBpfInterfaceReturnsOnCall == nil {
		fake.setBpfInterfaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setBpfInterfaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) BpfTimeout(fd int) (*syscall.Timeval, error) {
	fake.bpfTimeoutMutex.Lock()
	ret, specificReturn := fake.bpfTimeoutReturnsOnCall[len(fake.bpfTimeoutArgsForCall)]
	fake.bpfTimeoutArgsForCall = append(fake.bpfTimeoutArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("BpfTimeout", []interface{}{fd})
	fake.bpfTimeoutMutex.Unlock()
	if fake.BpfTimeoutStub != nil {
		return fake.BpfTimeoutStub(fd)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.bpfTimeoutReturns.result1, fake.bpfTimeoutReturns.result2
}

func (fake *FakeSyscall) BpfTimeoutCallCount() int {
	fake.bpfTimeoutMutex.RLock()
	defer fake.bpfTimeoutMutex.RUnlock()
	return len(fake.bpfTimeoutArgsForCall)
}

func (fake *FakeSyscall) BpfTimeoutArgsForCall(i int) int {
	fake.bpfTimeoutMutex.RLock()
	defer fake.bpfTimeoutMutex.RUnlock()
	return fake.bpfTimeoutArgsForCall[i].fd
}

func (fake *FakeSyscall) BpfTimeoutReturns(result1 *syscall.Timeval, result2 error) {
	fake.BpfTimeoutStub = nil
	fake.bpfTimeoutReturns = struct {
		result1 *syscall.Timeval
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) BpfTimeoutReturnsOnCall(i int, result1 *syscall.Timeval, result2 error) {
	fake.BpfTimeoutStub = nil
	if fake.bpfTimeoutReturnsOnCall == nil {
		fake.bpfTimeoutReturnsOnCall = make(map[int]struct {
			result1 *syscall.Timeval
			result2 error
		})
	}
	fake.bpfTimeoutReturnsOnCall[i] = struct {
		result1 *syscall.Timeval
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetBpfTimeout(fd int, tv *syscall.Timeval) error {
	fake.setBpfTimeoutMutex.Lock()
	ret, specificReturn := fake.setBpfTimeoutReturnsOnCall[len(fake.setBpfTimeoutArgsForCall)]
	fake.setBpfTimeoutArgsForCall = append(fake.setBpfTimeoutArgsForCall, struct {
		fd int
		tv *syscall.Timeval
	}{fd, tv})
	fake.recordInvocation("SetBpfTimeout", []interface{}{fd, tv})
	fake.setBpfTimeoutMutex.Unlock()
	if fake.SetBpfTimeoutStub != nil {
		return fake.SetBpfTimeoutStub(fd, tv)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setBpfTimeoutReturns.result1
}

func (fake *FakeSyscall) SetBpfTimeoutCallCount() int {
	fake.setBpfTimeoutMutex.RLock()
	defer fake.setBpfTimeoutMutex.RUnlock()
	return len(fake.setBpfTimeoutArgsForCall)
}

func (fake *FakeSyscall) SetBpfTimeoutArgsForCall(i int) (int, *syscall.Timeval) {
	fake.setBpfTimeoutMutex.RLock()
	defer fake.setBpfTimeoutMutex.RUnlock()
	return fake.setBpfTimeoutArgsForCall[i].fd, fake.setBpfTimeoutArgsForCall[i].tv
}

func (fake *FakeSyscall) SetBpfTimeoutReturns(result1 error) {
	fake.SetBpfTimeoutStub = nil
	fake.setBpfTimeoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetBpfTimeoutReturnsOnCall(i int, result1 error) {
	fake.SetBpfTimeoutStub = nil
	if fake.setBpfTimeoutReturnsOnCall == nil {
		fake.setBpfTimeoutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setBpfTimeoutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) BpfStats(fd int) (*syscall.BpfStat, error) {
	fake.bpfStatsMutex.Lock()
	ret, specificReturn := fake.bpfStatsReturnsOnCall[len(fake.bpfStatsArgsForCall)]
	fake.bpfStatsArgsForCall = append(fake.bpfStatsArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("BpfStats", []interface{}{fd})
	fake.bpfStatsMutex.Unlock()
	if fake.BpfStatsStub != nil {
		return fake.BpfStatsStub(fd)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.bpfStatsReturns.result1, fake.bpfStatsReturns.result2
}

func (fake *FakeSyscall) BpfStatsCallCount() int {
	fake.bpfStatsMutex.RLock()
	defer fake.bpfStatsMutex.RUnlock()
	return len(fake.bpfStatsArgsForCall)
}

func (fake *FakeSyscall) BpfStatsArgsForCall(i int) int {
	fake.bpfStatsMutex.RLock()
	defer fake.bpfStatsMutex.RUnlock()
	return fake.bpfStatsArgsForCall[i].fd
}

func (fake *FakeSyscall) BpfStatsReturns(result1 *syscall.BpfStat, result2 error) {
	fake.BpfStatsStub = nil
	fake.bpfStatsReturns = struct {
		result1 *syscall.BpfStat
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) BpfStatsReturnsOnCall(i int, result1 *syscall.BpfStat, result2 error) {
	fake.BpfStatsStub = nil
	if fake.bpfStatsReturnsOnCall == nil {
		fake.bpfStatsReturnsOnCall = make(map[int]struct {
			result1 *syscall.BpfStat
			result2 error
		})
	}
	fake.bpfStatsReturnsOnCall[i] = struct {
		result1 *syscall.BpfStat
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetBpfImmediate(fd int, m int) error {
	fake.setBpfImmediateMutex.Lock()
	ret, specificReturn := fake.setBpfImmediateReturnsOnCall[len(fake.setBpfImmediateArgsForCall)]
	fake.setBpfImmediateArgsForCall = append(fake.setBpfImmediateArgsForCall, struct {
		fd int
		m  int
	}{fd, m})
	fake.recordInvocation("SetBpfImmediate", []interface{}{fd, m})
	fake.setBpfImmediateMutex.Unlock()
	if fake.SetBpfImmediateStub != nil {
		return fake.SetBpfImmediateStub(fd, m)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setBpfImmediateReturns.result1
}

func (fake *FakeSyscall) SetBpfImmediateCallCount() int {
	fake.setBpfImmediateMutex.RLock()
	defer fake.setBpfImmediateMutex.RUnlock()
	return len(fake.setBpfImmediateArgsForCall)
}

func (fake *FakeSyscall) SetBpfImmediateArgsForCall(i int) (int, int) {
	fake.setBpfImmediateMutex.RLock()
	defer fake.setBpfImmediateMutex.RUnlock()
	return fake.setBpfImmediateArgsForCall[i].fd, fake.setBpfImmediateArgsForCall[i].m
}

func (fake *FakeSyscall) SetBpfImmediateReturns(result1 error) {
	fake.SetBpfImmediateStub = nil
	fake.setBpfImmediateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetBpfImmediateReturnsOnCall(i int, result1 error) {
	fake.SetBpfImmediateStub = nil
	if fake.setBpfImmediateReturnsOnCall == nil {
		fake.setBpfImmediateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setBpfImmediateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetBpf(fd int, i []syscall.BpfInsn) error {
	var iCopy []syscall.BpfInsn
	if i != nil {
		iCopy = make([]syscall.BpfInsn, len(i))
		copy(iCopy, i)
	}
	fake.setBpfMutex.Lock()
	ret, specificReturn := fake.setBpfReturnsOnCall[len(fake.setBpfArgsForCall)]
	fake.setBpfArgsForCall = append(fake.setBpfArgsForCall, struct {
		fd int
		i  []syscall.BpfInsn
	}{fd, iCopy})
	fake.recordInvocation("SetBpf", []interface{}{fd, iCopy})
	fake.setBpfMutex.Unlock()
	if fake.SetBpfStub != nil {
		return fake.SetBpfStub(fd, i)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setBpfReturns.result1
}

func (fake *FakeSyscall) SetBpfCallCount() int {
	fake.setBpfMutex.RLock()
	defer fake.setBpfMutex.RUnlock()
	return len(fake.setBpfArgsForCall)
}

func (fake *FakeSyscall) SetBpfArgsForCall(i int) (int, []syscall.BpfInsn) {
	fake.setBpfMutex.RLock()
	defer fake.setBpfMutex.RUnlock()
	return fake.setBpfArgsForCall[i].fd, fake.setBpfArgsForCall[i].i
}

func (fake *FakeSyscall) SetBpfReturns(result1 error) {
	fake.SetBpfStub = nil
	fake.setBpfReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetBpfReturnsOnCall(i int, result1 error) {
	fake.SetBpfStub = nil
	if fake.setBpfReturnsOnCall == nil {
		fake.setBpfReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setBpfReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CheckBpfVersion(fd int) error {
	fake.checkBpfVersionMutex.Lock()
	ret, specificReturn := fake.checkBpfVersionReturnsOnCall[len(fake.checkBpfVersionArgsForCall)]
	fake.checkBpfVersionArgsForCall = append(fake.checkBpfVersionArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("CheckBpfVersion", []interface{}{fd})
	fake.checkBpfVersionMutex.Unlock()
	if fake.CheckBpfVersionStub != nil {
		return fake.CheckBpfVersionStub(fd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.checkBpfVersionReturns.result1
}

func (fake *FakeSyscall) CheckBpfVersionCallCount() int {
	fake.checkBpfVersionMutex.RLock()
	defer fake.checkBpfVersionMutex.RUnlock()
	return len(fake.checkBpfVersionArgsForCall)
}

func (fake *FakeSyscall) CheckBpfVersionArgsForCall(i int) int {
	fake.checkBpfVersionMutex.RLock()
	defer fake.checkBpfVersionMutex.RUnlock()
	return fake.checkBpfVersionArgsForCall[i].fd
}

func (fake *FakeSyscall) CheckBpfVersionReturns(result1 error) {
	fake.CheckBpfVersionStub = nil
	fake.checkBpfVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CheckBpfVersionReturnsOnCall(i int, result1 error) {
	fake.CheckBpfVersionStub = nil
	if fake.checkBpfVersionReturnsOnCall == nil {
		fake.checkBpfVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkBpfVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) BpfHeadercmpl(fd int) (int, error) {
	fake.bpfHeadercmplMutex.Lock()
	ret, specificReturn := fake.bpfHeadercmplReturnsOnCall[len(fake.bpfHeadercmplArgsForCall)]
	fake.bpfHeadercmplArgsForCall = append(fake.bpfHeadercmplArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("BpfHeadercmpl", []interface{}{fd})
	fake.bpfHeadercmplMutex.Unlock()
	if fake.BpfHeadercmplStub != nil {
		return fake.BpfHeadercmplStub(fd)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.bpfHeadercmplReturns.result1, fake.bpfHeadercmplReturns.result2
}

func (fake *FakeSyscall) BpfHeadercmplCallCount() int {
	fake.bpfHeadercmplMutex.RLock()
	defer fake.bpfHeadercmplMutex.RUnlock()
	return len(fake.bpfHeadercmplArgsForCall)
}

func (fake *FakeSyscall) BpfHeadercmplArgsForCall(i int) int {
	fake.bpfHeadercmplMutex.RLock()
	defer fake.bpfHeadercmplMutex.RUnlock()
	return fake.bpfHeadercmplArgsForCall[i].fd
}

func (fake *FakeSyscall) BpfHeadercmplReturns(result1 int, result2 error) {
	fake.BpfHeadercmplStub = nil
	fake.bpfHeadercmplReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) BpfHeadercmplReturnsOnCall(i int, result1 int, result2 error) {
	fake.BpfHeadercmplStub = nil
	if fake.bpfHeadercmplReturnsOnCall == nil {
		fake.bpfHeadercmplReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.bpfHeadercmplReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetBpfHeadercmpl(fd int, f int) error {
	fake.setBpfHeadercmplMutex.Lock()
	ret, specificReturn := fake.setBpfHeadercmplReturnsOnCall[len(fake.setBpfHeadercmplArgsForCall)]
	fake.setBpfHeadercmplArgsForCall = append(fake.setBpfHeadercmplArgsForCall, struct {
		fd int
		f  int
	}{fd, f})
	fake.recordInvocation("SetBpfHeadercmpl", []interface{}{fd, f})
	fake.setBpfHeadercmplMutex.Unlock()
	if fake.SetBpfHeadercmplStub != nil {
		return fake.SetBpfHeadercmplStub(fd, f)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setBpfHeadercmplReturns.result1
}

func (fake *FakeSyscall) SetBpfHeadercmplCallCount() int {
	fake.setBpfHeadercmplMutex.RLock()
	defer fake.setBpfHeadercmplMutex.RUnlock()
	return len(fake.setBpfHeadercmplArgsForCall)
}

func (fake *FakeSyscall) SetBpfHeadercmplArgsForCall(i int) (int, int) {
	fake.setBpfHeadercmplMutex.RLock()
	defer fake.setBpfHeadercmplMutex.RUnlock()
	return fake.setBpfHeadercmplArgsForCall[i].fd, fake.setBpfHeadercmplArgsForCall[i].f
}

func (fake *FakeSyscall) SetBpfHeadercmplReturns(result1 error) {
	fake.SetBpfHeadercmplStub = nil
	fake.setBpfHeadercmplReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetBpfHeadercmplReturnsOnCall(i int, result1 error) {
	fake.SetBpfHeadercmplStub = nil
	if fake.setBpfHeadercmplReturnsOnCall == nil {
		fake.setBpfHeadercmplReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setBpfHeadercmplReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UnmarshalDir(b []byte) (*syscall.Dir, error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.unmarshalDirMutex.Lock()
	ret, specificReturn := fake.unmarshalDirReturnsOnCall[len(fake.unmarshalDirArgsForCall)]
	fake.unmarshalDirArgsForCall = append(fake.unmarshalDirArgsForCall, struct {
		b []byte
	}{bCopy})
	fake.recordInvocation("UnmarshalDir", []interface{}{bCopy})
	fake.unmarshalDirMutex.Unlock()
	if fake.UnmarshalDirStub != nil {
		return fake.UnmarshalDirStub(b)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.unmarshalDirReturns.result1, fake.unmarshalDirReturns.result2
}

func (fake *FakeSyscall) UnmarshalDirCallCount() int {
	fake.unmarshalDirMutex.RLock()
	defer fake.unmarshalDirMutex.RUnlock()
	return len(fake.unmarshalDirArgsForCall)
}

func (fake *FakeSyscall) UnmarshalDirArgsForCall(i int) []byte {
	fake.unmarshalDirMutex.RLock()
	defer fake.unmarshalDirMutex.RUnlock()
	return fake.unmarshalDirArgsForCall[i].b
}

func (fake *FakeSyscall) UnmarshalDirReturns(result1 *syscall.Dir, result2 error) {
	fake.UnmarshalDirStub = nil
	fake.unmarshalDirReturns = struct {
		result1 *syscall.Dir
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) UnmarshalDirReturnsOnCall(i int, result1 *syscall.Dir, result2 error) {
	fake.UnmarshalDirStub = nil
	if fake.unmarshalDirReturnsOnCall == nil {
		fake.unmarshalDirReturnsOnCall = make(map[int]struct {
			result1 *syscall.Dir
			result2 error
		})
	}
	fake.unmarshalDirReturnsOnCall[i] = struct {
		result1 *syscall.Dir
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseDirent(buf []byte, max int, names []string) (consumed int, count int, newnames []string) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	var namesCopy []string
	if names != nil {
		namesCopy = make([]string, len(names))
		copy(namesCopy, names)
	}
	fake.parseDirentMutex.Lock()
	ret, specificReturn := fake.parseDirentReturnsOnCall[len(fake.parseDirentArgsForCall)]
	fake.parseDirentArgsForCall = append(fake.parseDirentArgsForCall, struct {
		buf   []byte
		max   int
		names []string
	}{bufCopy, max, namesCopy})
	fake.recordInvocation("ParseDirent", []interface{}{bufCopy, max, namesCopy})
	fake.parseDirentMutex.Unlock()
	if fake.ParseDirentStub != nil {
		return fake.ParseDirentStub(buf, max, names)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.parseDirentReturns.result1, fake.parseDirentReturns.result2, fake.parseDirentReturns.result3
}

func (fake *FakeSyscall) ParseDirentCallCount() int {
	fake.parseDirentMutex.RLock()
	defer fake.parseDirentMutex.RUnlock()
	return len(fake.parseDirentArgsForCall)
}

func (fake *FakeSyscall) ParseDirentArgsForCall(i int) ([]byte, int, []string) {
	fake.parseDirentMutex.RLock()
	defer fake.parseDirentMutex.RUnlock()
	return fake.parseDirentArgsForCall[i].buf, fake.parseDirentArgsForCall[i].max, fake.parseDirentArgsForCall[i].names
}

func (fake *FakeSyscall) ParseDirentReturns(result1 int, result2 int, result3 []string) {
	fake.ParseDirentStub = nil
	fake.parseDirentReturns = struct {
		result1 int
		result2 int
		result3 []string
	}{result1, result2, result3}
}

func (fake *FakeSyscall) ParseDirentReturnsOnCall(i int, result1 int, result2 int, result3 []string) {
	fake.ParseDirentStub = nil
	if fake.parseDirentReturnsOnCall == nil {
		fake.parseDirentReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 []string
		})
	}
	fake.parseDirentReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 []string
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Syscall(trap uintptr, nargs uintptr, a1 uintptr, a2 uintptr, a3 uintptr) (r1, r2 uintptr, err syscall.Errno) {
	fake.syscallMutex.Lock()
	ret, specificReturn := fake.syscallReturnsOnCall[len(fake.syscallArgsForCall)]
	fake.syscallArgsForCall = append(fake.syscallArgsForCall, struct {
		trap  uintptr
		nargs uintptr
		a1    uintptr
		a2    uintptr
		a3    uintptr
	}{trap, nargs, a1, a2, a3})
	fake.recordInvocation("Syscall", []interface{}{trap, nargs, a1, a2, a3})
	fake.syscallMutex.Unlock()
	if fake.SyscallStub != nil {
		return fake.SyscallStub(trap, nargs, a1, a2, a3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.syscallReturns.result1, fake.syscallReturns.result2, fake.syscallReturns.result3
}

func (fake *FakeSyscall) SyscallCallCount() int {
	fake.syscallMutex.RLock()
	defer fake.syscallMutex.RUnlock()
	return len(fake.syscallArgsForCall)
}

func (fake *FakeSyscall) SyscallArgsForCall(i int) (uintptr, uintptr, uintptr, uintptr, uintptr) {
	fake.syscallMutex.RLock()
	defer fake.syscallMutex.RUnlock()
	return fake.syscallArgsForCall[i].trap, fake.syscallArgsForCall[i].nargs, fake.syscallArgsForCall[i].a1, fake.syscallArgsForCall[i].a2, fake.syscallArgsForCall[i].a3
}

func (fake *FakeSyscall) SyscallReturns(result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.SyscallStub = nil
	fake.syscallReturns = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) SyscallReturnsOnCall(i int, result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.SyscallStub = nil
	if fake.syscallReturnsOnCall == nil {
		fake.syscallReturnsOnCall = make(map[int]struct {
			result1 uintptr
			result2 uintptr
			result3 syscall.Errno
		})
	}
	fake.syscallReturnsOnCall[i] = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Syscall6(trap uintptr, nargs uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) (r1, r2 uintptr, err syscall.Errno) {
	fake.syscall6Mutex.Lock()
	ret, specificReturn := fake.syscall6ReturnsOnCall[len(fake.syscall6ArgsForCall)]
	fake.syscall6ArgsForCall = append(fake.syscall6ArgsForCall, struct {
		trap  uintptr
		nargs uintptr
		a1    uintptr
		a2    uintptr
		a3    uintptr
		a4    uintptr
		a5    uintptr
		a6    uintptr
	}{trap, nargs, a1, a2, a3, a4, a5, a6})
	fake.recordInvocation("Syscall6", []interface{}{trap, nargs, a1, a2, a3, a4, a5, a6})
	fake.syscall6Mutex.Unlock()
	if fake.Syscall6Stub != nil {
		return fake.Syscall6Stub(trap, nargs, a1, a2, a3, a4, a5, a6)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.syscall6Returns.result1, fake.syscall6Returns.result2, fake.syscall6Returns.result3
}

func (fake *FakeSyscall) Syscall6CallCount() int {
	fake.syscall6Mutex.RLock()
	defer fake.syscall6Mutex.RUnlock()
	return len(fake.syscall6ArgsForCall)
}

func (fake *FakeSyscall) Syscall6ArgsForCall(i int) (uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) {
	fake.syscall6Mutex.RLock()
	defer fake.syscall6Mutex.RUnlock()
	return fake.syscall6ArgsForCall[i].trap, fake.syscall6ArgsForCall[i].nargs, fake.syscall6ArgsForCall[i].a1, fake.syscall6ArgsForCall[i].a2, fake.syscall6ArgsForCall[i].a3, fake.syscall6ArgsForCall[i].a4, fake.syscall6ArgsForCall[i].a5, fake.syscall6ArgsForCall[i].a6
}

func (fake *FakeSyscall) Syscall6Returns(result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.Syscall6Stub = nil
	fake.syscall6Returns = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Syscall6ReturnsOnCall(i int, result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.Syscall6Stub = nil
	if fake.syscall6ReturnsOnCall == nil {
		fake.syscall6ReturnsOnCall = make(map[int]struct {
			result1 uintptr
			result2 uintptr
			result3 syscall.Errno
		})
	}
	fake.syscall6ReturnsOnCall[i] = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Syscall9(trap uintptr, nargs uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr, a7 uintptr, a8 uintptr, a9 uintptr) (r1, r2 uintptr, err syscall.Errno) {
	fake.syscall9Mutex.Lock()
	ret, specificReturn := fake.syscall9ReturnsOnCall[len(fake.syscall9ArgsForCall)]
	fake.syscall9ArgsForCall = append(fake.syscall9ArgsForCall, struct {
		trap  uintptr
		nargs uintptr
		a1    uintptr
		a2    uintptr
		a3    uintptr
		a4    uintptr
		a5    uintptr
		a6    uintptr
		a7    uintptr
		a8    uintptr
		a9    uintptr
	}{trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9})
	fake.recordInvocation("Syscall9", []interface{}{trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9})
	fake.syscall9Mutex.Unlock()
	if fake.Syscall9Stub != nil {
		return fake.Syscall9Stub(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.syscall9Returns.result1, fake.syscall9Returns.result2, fake.syscall9Returns.result3
}

func (fake *FakeSyscall) Syscall9CallCount() int {
	fake.syscall9Mutex.RLock()
	defer fake.syscall9Mutex.RUnlock()
	return len(fake.syscall9ArgsForCall)
}

func (fake *FakeSyscall) Syscall9ArgsForCall(i int) (uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) {
	fake.syscall9Mutex.RLock()
	defer fake.syscall9Mutex.RUnlock()
	return fake.syscall9ArgsForCall[i].trap, fake.syscall9ArgsForCall[i].nargs, fake.syscall9ArgsForCall[i].a1, fake.syscall9ArgsForCall[i].a2, fake.syscall9ArgsForCall[i].a3, fake.syscall9ArgsForCall[i].a4, fake.syscall9ArgsForCall[i].a5, fake.syscall9ArgsForCall[i].a6, fake.syscall9ArgsForCall[i].a7, fake.syscall9ArgsForCall[i].a8, fake.syscall9ArgsForCall[i].a9
}

func (fake *FakeSyscall) Syscall9Returns(result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.Syscall9Stub = nil
	fake.syscall9Returns = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Syscall9ReturnsOnCall(i int, result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.Syscall9Stub = nil
	if fake.syscall9ReturnsOnCall == nil {
		fake.syscall9ReturnsOnCall = make(map[int]struct {
			result1 uintptr
			result2 uintptr
			result3 syscall.Errno
		})
	}
	fake.syscall9ReturnsOnCall[i] = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Syscall12(trap uintptr, nargs uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr, a7 uintptr, a8 uintptr, a9 uintptr, a10 uintptr, a11 uintptr, a12 uintptr) (r1, r2 uintptr, err syscall.Errno) {
	fake.syscall12Mutex.Lock()
	ret, specificReturn := fake.syscall12ReturnsOnCall[len(fake.syscall12ArgsForCall)]
	fake.syscall12ArgsForCall = append(fake.syscall12ArgsForCall, struct {
		trap  uintptr
		nargs uintptr
		a1    uintptr
		a2    uintptr
		a3    uintptr
		a4    uintptr
		a5    uintptr
		a6    uintptr
		a7    uintptr
		a8    uintptr
		a9    uintptr
		a10   uintptr
		a11   uintptr
		a12   uintptr
	}{trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12})
	fake.recordInvocation("Syscall12", []interface{}{trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12})
	fake.syscall12Mutex.Unlock()
	if fake.Syscall12Stub != nil {
		return fake.Syscall12Stub(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.syscall12Returns.result1, fake.syscall12Returns.result2, fake.syscall12Returns.result3
}

func (fake *FakeSyscall) Syscall12CallCount() int {
	fake.syscall12Mutex.RLock()
	defer fake.syscall12Mutex.RUnlock()
	return len(fake.syscall12ArgsForCall)
}

func (fake *FakeSyscall) Syscall12ArgsForCall(i int) (uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) {
	fake.syscall12Mutex.RLock()
	defer fake.syscall12Mutex.RUnlock()
	return fake.syscall12ArgsForCall[i].trap, fake.syscall12ArgsForCall[i].nargs, fake.syscall12ArgsForCall[i].a1, fake.syscall12ArgsForCall[i].a2, fake.syscall12ArgsForCall[i].a3, fake.syscall12ArgsForCall[i].a4, fake.syscall12ArgsForCall[i].a5, fake.syscall12ArgsForCall[i].a6, fake.syscall12ArgsForCall[i].a7, fake.syscall12ArgsForCall[i].a8, fake.syscall12ArgsForCall[i].a9, fake.syscall12ArgsForCall[i].a10, fake.syscall12ArgsForCall[i].a11, fake.syscall12ArgsForCall[i].a12
}

func (fake *FakeSyscall) Syscall12Returns(result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.Syscall12Stub = nil
	fake.syscall12Returns = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Syscall12ReturnsOnCall(i int, result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.Syscall12Stub = nil
	if fake.syscall12ReturnsOnCall == nil {
		fake.syscall12ReturnsOnCall = make(map[int]struct {
			result1 uintptr
			result2 uintptr
			result3 syscall.Errno
		})
	}
	fake.syscall12ReturnsOnCall[i] = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Syscall15(trap uintptr, nargs uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr, a7 uintptr, a8 uintptr, a9 uintptr, a10 uintptr, a11 uintptr, a12 uintptr, a13 uintptr, a14 uintptr, a15 uintptr) (r1, r2 uintptr, err syscall.Errno) {
	fake.syscall15Mutex.Lock()
	ret, specificReturn := fake.syscall15ReturnsOnCall[len(fake.syscall15ArgsForCall)]
	fake.syscall15ArgsForCall = append(fake.syscall15ArgsForCall, struct {
		trap  uintptr
		nargs uintptr
		a1    uintptr
		a2    uintptr
		a3    uintptr
		a4    uintptr
		a5    uintptr
		a6    uintptr
		a7    uintptr
		a8    uintptr
		a9    uintptr
		a10   uintptr
		a11   uintptr
		a12   uintptr
		a13   uintptr
		a14   uintptr
		a15   uintptr
	}{trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15})
	fake.recordInvocation("Syscall15", []interface{}{trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15})
	fake.syscall15Mutex.Unlock()
	if fake.Syscall15Stub != nil {
		return fake.Syscall15Stub(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.syscall15Returns.result1, fake.syscall15Returns.result2, fake.syscall15Returns.result3
}

func (fake *FakeSyscall) Syscall15CallCount() int {
	fake.syscall15Mutex.RLock()
	defer fake.syscall15Mutex.RUnlock()
	return len(fake.syscall15ArgsForCall)
}

func (fake *FakeSyscall) Syscall15ArgsForCall(i int) (uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) {
	fake.syscall15Mutex.RLock()
	defer fake.syscall15Mutex.RUnlock()
	return fake.syscall15ArgsForCall[i].trap, fake.syscall15ArgsForCall[i].nargs, fake.syscall15ArgsForCall[i].a1, fake.syscall15ArgsForCall[i].a2, fake.syscall15ArgsForCall[i].a3, fake.syscall15ArgsForCall[i].a4, fake.syscall15ArgsForCall[i].a5, fake.syscall15ArgsForCall[i].a6, fake.syscall15ArgsForCall[i].a7, fake.syscall15ArgsForCall[i].a8, fake.syscall15ArgsForCall[i].a9, fake.syscall15ArgsForCall[i].a10, fake.syscall15ArgsForCall[i].a11, fake.syscall15ArgsForCall[i].a12, fake.syscall15ArgsForCall[i].a13, fake.syscall15ArgsForCall[i].a14, fake.syscall15ArgsForCall[i].a15
}

func (fake *FakeSyscall) Syscall15Returns(result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.Syscall15Stub = nil
	fake.syscall15Returns = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Syscall15ReturnsOnCall(i int, result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.Syscall15Stub = nil
	if fake.syscall15ReturnsOnCall == nil {
		fake.syscall15ReturnsOnCall = make(map[int]struct {
			result1 uintptr
			result2 uintptr
			result3 syscall.Errno
		})
	}
	fake.syscall15ReturnsOnCall[i] = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) LoadDLL(name string) (*syscall.DLL, error) {
	fake.loadDLLMutex.Lock()
	ret, specificReturn := fake.loadDLLReturnsOnCall[len(fake.loadDLLArgsForCall)]
	fake.loadDLLArgsForCall = append(fake.loadDLLArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("LoadDLL", []interface{}{name})
	fake.loadDLLMutex.Unlock()
	if fake.LoadDLLStub != nil {
		return fake.LoadDLLStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.loadDLLReturns.result1, fake.loadDLLReturns.result2
}

func (fake *FakeSyscall) LoadDLLCallCount() int {
	fake.loadDLLMutex.RLock()
	defer fake.loadDLLMutex.RUnlock()
	return len(fake.loadDLLArgsForCall)
}

func (fake *FakeSyscall) LoadDLLArgsForCall(i int) string {
	fake.loadDLLMutex.RLock()
	defer fake.loadDLLMutex.RUnlock()
	return fake.loadDLLArgsForCall[i].name
}

func (fake *FakeSyscall) LoadDLLReturns(result1 *syscall.DLL, result2 error) {
	fake.LoadDLLStub = nil
	fake.loadDLLReturns = struct {
		result1 *syscall.DLL
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) LoadDLLReturnsOnCall(i int, result1 *syscall.DLL, result2 error) {
	fake.LoadDLLStub = nil
	if fake.loadDLLReturnsOnCall == nil {
		fake.loadDLLReturnsOnCall = make(map[int]struct {
			result1 *syscall.DLL
			result2 error
		})
	}
	fake.loadDLLReturnsOnCall[i] = struct {
		result1 *syscall.DLL
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) MustLoadDLL(name string) *syscall.DLL {
	fake.mustLoadDLLMutex.Lock()
	ret, specificReturn := fake.mustLoadDLLReturnsOnCall[len(fake.mustLoadDLLArgsForCall)]
	fake.mustLoadDLLArgsForCall = append(fake.mustLoadDLLArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("MustLoadDLL", []interface{}{name})
	fake.mustLoadDLLMutex.Unlock()
	if fake.MustLoadDLLStub != nil {
		return fake.MustLoadDLLStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mustLoadDLLReturns.result1
}

func (fake *FakeSyscall) MustLoadDLLCallCount() int {
	fake.mustLoadDLLMutex.RLock()
	defer fake.mustLoadDLLMutex.RUnlock()
	return len(fake.mustLoadDLLArgsForCall)
}

func (fake *FakeSyscall) MustLoadDLLArgsForCall(i int) string {
	fake.mustLoadDLLMutex.RLock()
	defer fake.mustLoadDLLMutex.RUnlock()
	return fake.mustLoadDLLArgsForCall[i].name
}

func (fake *FakeSyscall) MustLoadDLLReturns(result1 *syscall.DLL) {
	fake.MustLoadDLLStub = nil
	fake.mustLoadDLLReturns = struct {
		result1 *syscall.DLL
	}{result1}
}

func (fake *FakeSyscall) MustLoadDLLReturnsOnCall(i int, result1 *syscall.DLL) {
	fake.MustLoadDLLStub = nil
	if fake.mustLoadDLLReturnsOnCall == nil {
		fake.mustLoadDLLReturnsOnCall = make(map[int]struct {
			result1 *syscall.DLL
		})
	}
	fake.mustLoadDLLReturnsOnCall[i] = struct {
		result1 *syscall.DLL
	}{result1}
}

func (fake *FakeSyscall) NewLazyDLL(name string) *syscall.LazyDLL {
	fake.newLazyDLLMutex.Lock()
	ret, specificReturn := fake.newLazyDLLReturnsOnCall[len(fake.newLazyDLLArgsForCall)]
	fake.newLazyDLLArgsForCall = append(fake.newLazyDLLArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("NewLazyDLL", []interface{}{name})
	fake.newLazyDLLMutex.Unlock()
	if fake.NewLazyDLLStub != nil {
		return fake.NewLazyDLLStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newLazyDLLReturns.result1
}

func (fake *FakeSyscall) NewLazyDLLCallCount() int {
	fake.newLazyDLLMutex.RLock()
	defer fake.newLazyDLLMutex.RUnlock()
	return len(fake.newLazyDLLArgsForCall)
}

func (fake *FakeSyscall) NewLazyDLLArgsForCall(i int) string {
	fake.newLazyDLLMutex.RLock()
	defer fake.newLazyDLLMutex.RUnlock()
	return fake.newLazyDLLArgsForCall[i].name
}

func (fake *FakeSyscall) NewLazyDLLReturns(result1 *syscall.LazyDLL) {
	fake.NewLazyDLLStub = nil
	fake.newLazyDLLReturns = struct {
		result1 *syscall.LazyDLL
	}{result1}
}

func (fake *FakeSyscall) NewLazyDLLReturnsOnCall(i int, result1 *syscall.LazyDLL) {
	fake.NewLazyDLLStub = nil
	if fake.newLazyDLLReturnsOnCall == nil {
		fake.newLazyDLLReturnsOnCall = make(map[int]struct {
			result1 *syscall.LazyDLL
		})
	}
	fake.newLazyDLLReturnsOnCall[i] = struct {
		result1 *syscall.LazyDLL
	}{result1}
}

func (fake *FakeSyscall) Getenv(key string) (value string, found bool) {
	fake.getenvMutex.Lock()
	ret, specificReturn := fake.getenvReturnsOnCall[len(fake.getenvArgsForCall)]
	fake.getenvArgsForCall = append(fake.getenvArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("Getenv", []interface{}{key})
	fake.getenvMutex.Unlock()
	if fake.GetenvStub != nil {
		return fake.GetenvStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getenvReturns.result1, fake.getenvReturns.result2
}

func (fake *FakeSyscall) GetenvCallCount() int {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return len(fake.getenvArgsForCall)
}

func (fake *FakeSyscall) GetenvArgsForCall(i int) string {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return fake.getenvArgsForCall[i].key
}

func (fake *FakeSyscall) GetenvReturns(result1 string, result2 bool) {
	fake.GetenvStub = nil
	fake.getenvReturns = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeSyscall) GetenvReturnsOnCall(i int, result1 string, result2 bool) {
	fake.GetenvStub = nil
	if fake.getenvReturnsOnCall == nil {
		fake.getenvReturnsOnCall = make(map[int]struct {
			result1 string
			result2 bool
		})
	}
	fake.getenvReturnsOnCall[i] = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeSyscall) Setenv(key string, value string) error {
	fake.setenvMutex.Lock()
	ret, specificReturn := fake.setenvReturnsOnCall[len(fake.setenvArgsForCall)]
	fake.setenvArgsForCall = append(fake.setenvArgsForCall, struct {
		key   string
		value string
	}{key, value})
	fake.recordInvocation("Setenv", []interface{}{key, value})
	fake.setenvMutex.Unlock()
	if fake.SetenvStub != nil {
		return fake.SetenvStub(key, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setenvReturns.result1
}

func (fake *FakeSyscall) SetenvCallCount() int {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	return len(fake.setenvArgsForCall)
}

func (fake *FakeSyscall) SetenvArgsForCall(i int) (string, string) {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	return fake.setenvArgsForCall[i].key, fake.setenvArgsForCall[i].value
}

func (fake *FakeSyscall) SetenvReturns(result1 error) {
	fake.SetenvStub = nil
	fake.setenvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetenvReturnsOnCall(i int, result1 error) {
	fake.SetenvStub = nil
	if fake.setenvReturnsOnCall == nil {
		fake.setenvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setenvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Clearenv() {
	fake.clearenvMutex.Lock()
	fake.clearenvArgsForCall = append(fake.clearenvArgsForCall, struct{}{})
	fake.recordInvocation("Clearenv", []interface{}{})
	fake.clearenvMutex.Unlock()
	if fake.ClearenvStub != nil {
		fake.ClearenvStub()
	}
}

func (fake *FakeSyscall) ClearenvCallCount() int {
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	return len(fake.clearenvArgsForCall)
}

func (fake *FakeSyscall) Unsetenv(key string) error {
	fake.unsetenvMutex.Lock()
	ret, specificReturn := fake.unsetenvReturnsOnCall[len(fake.unsetenvArgsForCall)]
	fake.unsetenvArgsForCall = append(fake.unsetenvArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("Unsetenv", []interface{}{key})
	fake.unsetenvMutex.Unlock()
	if fake.UnsetenvStub != nil {
		return fake.UnsetenvStub(key)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unsetenvReturns.result1
}

func (fake *FakeSyscall) UnsetenvCallCount() int {
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	return len(fake.unsetenvArgsForCall)
}

func (fake *FakeSyscall) UnsetenvArgsForCall(i int) string {
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	return fake.unsetenvArgsForCall[i].key
}

func (fake *FakeSyscall) UnsetenvReturns(result1 error) {
	fake.UnsetenvStub = nil
	fake.unsetenvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UnsetenvReturnsOnCall(i int, result1 error) {
	fake.UnsetenvStub = nil
	if fake.unsetenvReturnsOnCall == nil {
		fake.unsetenvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unsetenvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Environ() []string {
	fake.environMutex.Lock()
	ret, specificReturn := fake.environReturnsOnCall[len(fake.environArgsForCall)]
	fake.environArgsForCall = append(fake.environArgsForCall, struct{}{})
	fake.recordInvocation("Environ", []interface{}{})
	fake.environMutex.Unlock()
	if fake.EnvironStub != nil {
		return fake.EnvironStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.environReturns.result1
}

func (fake *FakeSyscall) EnvironCallCount() int {
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	return len(fake.environArgsForCall)
}

func (fake *FakeSyscall) EnvironReturns(result1 []string) {
	fake.EnvironStub = nil
	fake.environReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeSyscall) EnvironReturnsOnCall(i int, result1 []string) {
	fake.EnvironStub = nil
	if fake.environReturnsOnCall == nil {
		fake.environReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.environReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeSyscall) StringSlicePtr(ss []string) []*byte {
	var ssCopy []string
	if ss != nil {
		ssCopy = make([]string, len(ss))
		copy(ssCopy, ss)
	}
	fake.stringSlicePtrMutex.Lock()
	ret, specificReturn := fake.stringSlicePtrReturnsOnCall[len(fake.stringSlicePtrArgsForCall)]
	fake.stringSlicePtrArgsForCall = append(fake.stringSlicePtrArgsForCall, struct {
		ss []string
	}{ssCopy})
	fake.recordInvocation("StringSlicePtr", []interface{}{ssCopy})
	fake.stringSlicePtrMutex.Unlock()
	if fake.StringSlicePtrStub != nil {
		return fake.StringSlicePtrStub(ss)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stringSlicePtrReturns.result1
}

func (fake *FakeSyscall) StringSlicePtrCallCount() int {
	fake.stringSlicePtrMutex.RLock()
	defer fake.stringSlicePtrMutex.RUnlock()
	return len(fake.stringSlicePtrArgsForCall)
}

func (fake *FakeSyscall) StringSlicePtrArgsForCall(i int) []string {
	fake.stringSlicePtrMutex.RLock()
	defer fake.stringSlicePtrMutex.RUnlock()
	return fake.stringSlicePtrArgsForCall[i].ss
}

func (fake *FakeSyscall) StringSlicePtrReturns(result1 []*byte) {
	fake.StringSlicePtrStub = nil
	fake.stringSlicePtrReturns = struct {
		result1 []*byte
	}{result1}
}

func (fake *FakeSyscall) StringSlicePtrReturnsOnCall(i int, result1 []*byte) {
	fake.StringSlicePtrStub = nil
	if fake.stringSlicePtrReturnsOnCall == nil {
		fake.stringSlicePtrReturnsOnCall = make(map[int]struct {
			result1 []*byte
		})
	}
	fake.stringSlicePtrReturnsOnCall[i] = struct {
		result1 []*byte
	}{result1}
}

func (fake *FakeSyscall) SlicePtrFromStrings(ss []string) ([]*byte, error) {
	var ssCopy []string
	if ss != nil {
		ssCopy = make([]string, len(ss))
		copy(ssCopy, ss)
	}
	fake.slicePtrFromStringsMutex.Lock()
	ret, specificReturn := fake.slicePtrFromStringsReturnsOnCall[len(fake.slicePtrFromStringsArgsForCall)]
	fake.slicePtrFromStringsArgsForCall = append(fake.slicePtrFromStringsArgsForCall, struct {
		ss []string
	}{ssCopy})
	fake.recordInvocation("SlicePtrFromStrings", []interface{}{ssCopy})
	fake.slicePtrFromStringsMutex.Unlock()
	if fake.SlicePtrFromStringsStub != nil {
		return fake.SlicePtrFromStringsStub(ss)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.slicePtrFromStringsReturns.result1, fake.slicePtrFromStringsReturns.result2
}

func (fake *FakeSyscall) SlicePtrFromStringsCallCount() int {
	fake.slicePtrFromStringsMutex.RLock()
	defer fake.slicePtrFromStringsMutex.RUnlock()
	return len(fake.slicePtrFromStringsArgsForCall)
}

func (fake *FakeSyscall) SlicePtrFromStringsArgsForCall(i int) []string {
	fake.slicePtrFromStringsMutex.RLock()
	defer fake.slicePtrFromStringsMutex.RUnlock()
	return fake.slicePtrFromStringsArgsForCall[i].ss
}

func (fake *FakeSyscall) SlicePtrFromStringsReturns(result1 []*byte, result2 error) {
	fake.SlicePtrFromStringsStub = nil
	fake.slicePtrFromStringsReturns = struct {
		result1 []*byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SlicePtrFromStringsReturnsOnCall(i int, result1 []*byte, result2 error) {
	fake.SlicePtrFromStringsStub = nil
	if fake.slicePtrFromStringsReturnsOnCall == nil {
		fake.slicePtrFromStringsReturnsOnCall = make(map[int]struct {
			result1 []*byte
			result2 error
		})
	}
	fake.slicePtrFromStringsReturnsOnCall[i] = struct {
		result1 []*byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ForkExec(argv0 string, argv []string, attr *syscall.ProcAttr) (pid int, err error) {
	var argvCopy []string
	if argv != nil {
		argvCopy = make([]string, len(argv))
		copy(argvCopy, argv)
	}
	fake.forkExecMutex.Lock()
	ret, specificReturn := fake.forkExecReturnsOnCall[len(fake.forkExecArgsForCall)]
	fake.forkExecArgsForCall = append(fake.forkExecArgsForCall, struct {
		argv0 string
		argv  []string
		attr  *syscall.ProcAttr
	}{argv0, argvCopy, attr})
	fake.recordInvocation("ForkExec", []interface{}{argv0, argvCopy, attr})
	fake.forkExecMutex.Unlock()
	if fake.ForkExecStub != nil {
		return fake.ForkExecStub(argv0, argv, attr)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.forkExecReturns.result1, fake.forkExecReturns.result2
}

func (fake *FakeSyscall) ForkExecCallCount() int {
	fake.forkExecMutex.RLock()
	defer fake.forkExecMutex.RUnlock()
	return len(fake.forkExecArgsForCall)
}

func (fake *FakeSyscall) ForkExecArgsForCall(i int) (string, []string, *syscall.ProcAttr) {
	fake.forkExecMutex.RLock()
	defer fake.forkExecMutex.RUnlock()
	return fake.forkExecArgsForCall[i].argv0, fake.forkExecArgsForCall[i].argv, fake.forkExecArgsForCall[i].attr
}

func (fake *FakeSyscall) ForkExecReturns(result1 int, result2 error) {
	fake.ForkExecStub = nil
	fake.forkExecReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ForkExecReturnsOnCall(i int, result1 int, result2 error) {
	fake.ForkExecStub = nil
	if fake.forkExecReturnsOnCall == nil {
		fake.forkExecReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.forkExecReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) StartProcess(argv0 string, argv []string, attr *syscall.ProcAttr) (pid int, handle uintptr, err error) {
	var argvCopy []string
	if argv != nil {
		argvCopy = make([]string, len(argv))
		copy(argvCopy, argv)
	}
	fake.startProcessMutex.Lock()
	ret, specificReturn := fake.startProcessReturnsOnCall[len(fake.startProcessArgsForCall)]
	fake.startProcessArgsForCall = append(fake.startProcessArgsForCall, struct {
		argv0 string
		argv  []string
		attr  *syscall.ProcAttr
	}{argv0, argvCopy, attr})
	fake.recordInvocation("StartProcess", []interface{}{argv0, argvCopy, attr})
	fake.startProcessMutex.Unlock()
	if fake.StartProcessStub != nil {
		return fake.StartProcessStub(argv0, argv, attr)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.startProcessReturns.result1, fake.startProcessReturns.result2, fake.startProcessReturns.result3
}

func (fake *FakeSyscall) StartProcessCallCount() int {
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	return len(fake.startProcessArgsForCall)
}

func (fake *FakeSyscall) StartProcessArgsForCall(i int) (string, []string, *syscall.ProcAttr) {
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	return fake.startProcessArgsForCall[i].argv0, fake.startProcessArgsForCall[i].argv, fake.startProcessArgsForCall[i].attr
}

func (fake *FakeSyscall) StartProcessReturns(result1 int, result2 uintptr, result3 error) {
	fake.StartProcessStub = nil
	fake.startProcessReturns = struct {
		result1 int
		result2 uintptr
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSyscall) StartProcessReturnsOnCall(i int, result1 int, result2 uintptr, result3 error) {
	fake.StartProcessStub = nil
	if fake.startProcessReturnsOnCall == nil {
		fake.startProcessReturnsOnCall = make(map[int]struct {
			result1 int
			result2 uintptr
			result3 error
		})
	}
	fake.startProcessReturnsOnCall[i] = struct {
		result1 int
		result2 uintptr
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Exec(argv0 string, argv []string, envv []string) (err error) {
	var argvCopy []string
	if argv != nil {
		argvCopy = make([]string, len(argv))
		copy(argvCopy, argv)
	}
	var envvCopy []string
	if envv != nil {
		envvCopy = make([]string, len(envv))
		copy(envvCopy, envv)
	}
	fake.execMutex.Lock()
	ret, specificReturn := fake.execReturnsOnCall[len(fake.execArgsForCall)]
	fake.execArgsForCall = append(fake.execArgsForCall, struct {
		argv0 string
		argv  []string
		envv  []string
	}{argv0, argvCopy, envvCopy})
	fake.recordInvocation("Exec", []interface{}{argv0, argvCopy, envvCopy})
	fake.execMutex.Unlock()
	if fake.ExecStub != nil {
		return fake.ExecStub(argv0, argv, envv)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.execReturns.result1
}

func (fake *FakeSyscall) ExecCallCount() int {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return len(fake.execArgsForCall)
}

func (fake *FakeSyscall) ExecArgsForCall(i int) (string, []string, []string) {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return fake.execArgsForCall[i].argv0, fake.execArgsForCall[i].argv, fake.execArgsForCall[i].envv
}

func (fake *FakeSyscall) ExecReturns(result1 error) {
	fake.ExecStub = nil
	fake.execReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ExecReturnsOnCall(i int, result1 error) {
	fake.ExecStub = nil
	if fake.execReturnsOnCall == nil {
		fake.execReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WaitProcess(pid int, w *syscall.Waitmsg) (err error) {
	fake.waitProcessMutex.Lock()
	ret, specificReturn := fake.waitProcessReturnsOnCall[len(fake.waitProcessArgsForCall)]
	fake.waitProcessArgsForCall = append(fake.waitProcessArgsForCall, struct {
		pid int
		w   *syscall.Waitmsg
	}{pid, w})
	fake.recordInvocation("WaitProcess", []interface{}{pid, w})
	fake.waitProcessMutex.Unlock()
	if fake.WaitProcessStub != nil {
		return fake.WaitProcessStub(pid, w)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitProcessReturns.result1
}

func (fake *FakeSyscall) WaitProcessCallCount() int {
	fake.waitProcessMutex.RLock()
	defer fake.waitProcessMutex.RUnlock()
	return len(fake.waitProcessArgsForCall)
}

func (fake *FakeSyscall) WaitProcessArgsForCall(i int) (int, *syscall.Waitmsg) {
	fake.waitProcessMutex.RLock()
	defer fake.waitProcessMutex.RUnlock()
	return fake.waitProcessArgsForCall[i].pid, fake.waitProcessArgsForCall[i].w
}

func (fake *FakeSyscall) WaitProcessReturns(result1 error) {
	fake.WaitProcessStub = nil
	fake.waitProcessReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WaitProcessReturnsOnCall(i int, result1 error) {
	fake.WaitProcessStub = nil
	if fake.waitProcessReturnsOnCall == nil {
		fake.waitProcessReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitProcessReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CloseOnExec(fd int) {
	fake.closeOnExecMutex.Lock()
	fake.closeOnExecArgsForCall = append(fake.closeOnExecArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("CloseOnExec", []interface{}{fd})
	fake.closeOnExecMutex.Unlock()
	if fake.CloseOnExecStub != nil {
		fake.CloseOnExecStub(fd)
	}
}

func (fake *FakeSyscall) CloseOnExecCallCount() int {
	fake.closeOnExecMutex.RLock()
	defer fake.closeOnExecMutex.RUnlock()
	return len(fake.closeOnExecArgsForCall)
}

func (fake *FakeSyscall) CloseOnExecArgsForCall(i int) int {
	fake.closeOnExecMutex.RLock()
	defer fake.closeOnExecMutex.RUnlock()
	return fake.closeOnExecArgsForCall[i].fd
}

func (fake *FakeSyscall) SetNonblock(fd int, nonblocking bool) (err error) {
	fake.setNonblockMutex.Lock()
	ret, specificReturn := fake.setNonblockReturnsOnCall[len(fake.setNonblockArgsForCall)]
	fake.setNonblockArgsForCall = append(fake.setNonblockArgsForCall, struct {
		fd          int
		nonblocking bool
	}{fd, nonblocking})
	fake.recordInvocation("SetNonblock", []interface{}{fd, nonblocking})
	fake.setNonblockMutex.Unlock()
	if fake.SetNonblockStub != nil {
		return fake.SetNonblockStub(fd, nonblocking)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setNonblockReturns.result1
}

func (fake *FakeSyscall) SetNonblockCallCount() int {
	fake.setNonblockMutex.RLock()
	defer fake.setNonblockMutex.RUnlock()
	return len(fake.setNonblockArgsForCall)
}

func (fake *FakeSyscall) SetNonblockArgsForCall(i int) (int, bool) {
	fake.setNonblockMutex.RLock()
	defer fake.setNonblockMutex.RUnlock()
	return fake.setNonblockArgsForCall[i].fd, fake.setNonblockArgsForCall[i].nonblocking
}

func (fake *FakeSyscall) SetNonblockReturns(result1 error) {
	fake.SetNonblockStub = nil
	fake.setNonblockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetNonblockReturnsOnCall(i int, result1 error) {
	fake.SetNonblockStub = nil
	if fake.setNonblockReturnsOnCall == nil {
		fake.setNonblockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setNonblockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) EscapeArg(s string) string {
	fake.escapeArgMutex.Lock()
	ret, specificReturn := fake.escapeArgReturnsOnCall[len(fake.escapeArgArgsForCall)]
	fake.escapeArgArgsForCall = append(fake.escapeArgArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("EscapeArg", []interface{}{s})
	fake.escapeArgMutex.Unlock()
	if fake.EscapeArgStub != nil {
		return fake.EscapeArgStub(s)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.escapeArgReturns.result1
}

func (fake *FakeSyscall) EscapeArgCallCount() int {
	fake.escapeArgMutex.RLock()
	defer fake.escapeArgMutex.RUnlock()
	return len(fake.escapeArgArgsForCall)
}

func (fake *FakeSyscall) EscapeArgArgsForCall(i int) string {
	fake.escapeArgMutex.RLock()
	defer fake.escapeArgMutex.RUnlock()
	return fake.escapeArgArgsForCall[i].s
}

func (fake *FakeSyscall) EscapeArgReturns(result1 string) {
	fake.EscapeArgStub = nil
	fake.escapeArgReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeSyscall) EscapeArgReturnsOnCall(i int, result1 string) {
	fake.EscapeArgStub = nil
	if fake.escapeArgReturnsOnCall == nil {
		fake.escapeArgReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.escapeArgReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeSyscall) FullPath(name string) (path string, err error) {
	fake.fullPathMutex.Lock()
	ret, specificReturn := fake.fullPathReturnsOnCall[len(fake.fullPathArgsForCall)]
	fake.fullPathArgsForCall = append(fake.fullPathArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("FullPath", []interface{}{name})
	fake.fullPathMutex.Unlock()
	if fake.FullPathStub != nil {
		return fake.FullPathStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fullPathReturns.result1, fake.fullPathReturns.result2
}

func (fake *FakeSyscall) FullPathCallCount() int {
	fake.fullPathMutex.RLock()
	defer fake.fullPathMutex.RUnlock()
	return len(fake.fullPathArgsForCall)
}

func (fake *FakeSyscall) FullPathArgsForCall(i int) string {
	fake.fullPathMutex.RLock()
	defer fake.fullPathMutex.RUnlock()
	return fake.fullPathArgsForCall[i].name
}

func (fake *FakeSyscall) FullPathReturns(result1 string, result2 error) {
	fake.FullPathStub = nil
	fake.fullPathReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) FullPathReturnsOnCall(i int, result1 string, result2 error) {
	fake.FullPathStub = nil
	if fake.fullPathReturnsOnCall == nil {
		fake.fullPathReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.fullPathReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Close(fd int) error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("Close", []interface{}{fd})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub(fd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.closeReturns.result1
}

func (fake *FakeSyscall) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeSyscall) CloseArgsForCall(i int) int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return fake.closeArgsForCall[i].fd
}

func (fake *FakeSyscall) CloseReturns(result1 error) {
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CloseReturnsOnCall(i int, result1 error) {
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Dup(fd int) (int, error) {
	fake.dupMutex.Lock()
	ret, specificReturn := fake.dupReturnsOnCall[len(fake.dupArgsForCall)]
	fake.dupArgsForCall = append(fake.dupArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("Dup", []interface{}{fd})
	fake.dupMutex.Unlock()
	if fake.DupStub != nil {
		return fake.DupStub(fd)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.dupReturns.result1, fake.dupReturns.result2
}

func (fake *FakeSyscall) DupCallCount() int {
	fake.dupMutex.RLock()
	defer fake.dupMutex.RUnlock()
	return len(fake.dupArgsForCall)
}

func (fake *FakeSyscall) DupArgsForCall(i int) int {
	fake.dupMutex.RLock()
	defer fake.dupMutex.RUnlock()
	return fake.dupArgsForCall[i].fd
}

func (fake *FakeSyscall) DupReturns(result1 int, result2 error) {
	fake.DupStub = nil
	fake.dupReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) DupReturnsOnCall(i int, result1 int, result2 error) {
	fake.DupStub = nil
	if fake.dupReturnsOnCall == nil {
		fake.dupReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.dupReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Dup2(fd int, newfd int) error {
	fake.dup2Mutex.Lock()
	ret, specificReturn := fake.dup2ReturnsOnCall[len(fake.dup2ArgsForCall)]
	fake.dup2ArgsForCall = append(fake.dup2ArgsForCall, struct {
		fd    int
		newfd int
	}{fd, newfd})
	fake.recordInvocation("Dup2", []interface{}{fd, newfd})
	fake.dup2Mutex.Unlock()
	if fake.Dup2Stub != nil {
		return fake.Dup2Stub(fd, newfd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.dup2Returns.result1
}

func (fake *FakeSyscall) Dup2CallCount() int {
	fake.dup2Mutex.RLock()
	defer fake.dup2Mutex.RUnlock()
	return len(fake.dup2ArgsForCall)
}

func (fake *FakeSyscall) Dup2ArgsForCall(i int) (int, int) {
	fake.dup2Mutex.RLock()
	defer fake.dup2Mutex.RUnlock()
	return fake.dup2ArgsForCall[i].fd, fake.dup2ArgsForCall[i].newfd
}

func (fake *FakeSyscall) Dup2Returns(result1 error) {
	fake.Dup2Stub = nil
	fake.dup2Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Dup2ReturnsOnCall(i int, result1 error) {
	fake.Dup2Stub = nil
	if fake.dup2ReturnsOnCall == nil {
		fake.dup2ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dup2ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fstat(fd int, st *syscall.Stat_t) error {
	fake.fstatMutex.Lock()
	ret, specificReturn := fake.fstatReturnsOnCall[len(fake.fstatArgsForCall)]
	fake.fstatArgsForCall = append(fake.fstatArgsForCall, struct {
		fd int
		st *syscall.Stat_t
	}{fd, st})
	fake.recordInvocation("Fstat", []interface{}{fd, st})
	fake.fstatMutex.Unlock()
	if fake.FstatStub != nil {
		return fake.FstatStub(fd, st)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fstatReturns.result1
}

func (fake *FakeSyscall) FstatCallCount() int {
	fake.fstatMutex.RLock()
	defer fake.fstatMutex.RUnlock()
	return len(fake.fstatArgsForCall)
}

func (fake *FakeSyscall) FstatArgsForCall(i int) (int, *syscall.Stat_t) {
	fake.fstatMutex.RLock()
	defer fake.fstatMutex.RUnlock()
	return fake.fstatArgsForCall[i].fd, fake.fstatArgsForCall[i].st
}

func (fake *FakeSyscall) FstatReturns(result1 error) {
	fake.FstatStub = nil
	fake.fstatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FstatReturnsOnCall(i int, result1 error) {
	fake.FstatStub = nil
	if fake.fstatReturnsOnCall == nil {
		fake.fstatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fstatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Read(fd int, b []byte) (int, error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
		fd int
		b  []byte
	}{fd, bCopy})
	fake.recordInvocation("Read", []interface{}{fd, bCopy})
	fake.readMutex.Unlock()
	if fake.ReadStub != nil {
		return fake.ReadStub(fd, b)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.readReturns.result1, fake.readReturns.result2
}

func (fake *FakeSyscall) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeSyscall) ReadArgsForCall(i int) (int, []byte) {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return fake.readArgsForCall[i].fd, fake.readArgsForCall[i].b
}

func (fake *FakeSyscall) ReadReturns(result1 int, result2 error) {
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ReadReturnsOnCall(i int, result1 int, result2 error) {
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Write(fd int, b []byte) (int, error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.writeMutex.Lock()
	ret, specificReturn := fake.writeReturnsOnCall[len(fake.writeArgsForCall)]
	fake.writeArgsForCall = append(fake.writeArgsForCall, struct {
		fd int
		b  []byte
	}{fd, bCopy})
	fake.recordInvocation("Write", []interface{}{fd, bCopy})
	fake.writeMutex.Unlock()
	if fake.WriteStub != nil {
		return fake.WriteStub(fd, b)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.writeReturns.result1, fake.writeReturns.result2
}

func (fake *FakeSyscall) WriteCallCount() int {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return len(fake.writeArgsForCall)
}

func (fake *FakeSyscall) WriteArgsForCall(i int) (int, []byte) {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return fake.writeArgsForCall[i].fd, fake.writeArgsForCall[i].b
}

func (fake *FakeSyscall) WriteReturns(result1 int, result2 error) {
	fake.WriteStub = nil
	fake.writeReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) WriteReturnsOnCall(i int, result1 int, result2 error) {
	fake.WriteStub = nil
	if fake.writeReturnsOnCall == nil {
		fake.writeReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.writeReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Pread(fd int, b []byte, offset int64) (int, error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.preadMutex.Lock()
	ret, specificReturn := fake.preadReturnsOnCall[len(fake.preadArgsForCall)]
	fake.preadArgsForCall = append(fake.preadArgsForCall, struct {
		fd     int
		b      []byte
		offset int64
	}{fd, bCopy, offset})
	fake.recordInvocation("Pread", []interface{}{fd, bCopy, offset})
	fake.preadMutex.Unlock()
	if fake.PreadStub != nil {
		return fake.PreadStub(fd, b, offset)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.preadReturns.result1, fake.preadReturns.result2
}

func (fake *FakeSyscall) PreadCallCount() int {
	fake.preadMutex.RLock()
	defer fake.preadMutex.RUnlock()
	return len(fake.preadArgsForCall)
}

func (fake *FakeSyscall) PreadArgsForCall(i int) (int, []byte, int64) {
	fake.preadMutex.RLock()
	defer fake.preadMutex.RUnlock()
	return fake.preadArgsForCall[i].fd, fake.preadArgsForCall[i].b, fake.preadArgsForCall[i].offset
}

func (fake *FakeSyscall) PreadReturns(result1 int, result2 error) {
	fake.PreadStub = nil
	fake.preadReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PreadReturnsOnCall(i int, result1 int, result2 error) {
	fake.PreadStub = nil
	if fake.preadReturnsOnCall == nil {
		fake.preadReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.preadReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Pwrite(fd int, b []byte, offset int64) (int, error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.pwriteMutex.Lock()
	ret, specificReturn := fake.pwriteReturnsOnCall[len(fake.pwriteArgsForCall)]
	fake.pwriteArgsForCall = append(fake.pwriteArgsForCall, struct {
		fd     int
		b      []byte
		offset int64
	}{fd, bCopy, offset})
	fake.recordInvocation("Pwrite", []interface{}{fd, bCopy, offset})
	fake.pwriteMutex.Unlock()
	if fake.PwriteStub != nil {
		return fake.PwriteStub(fd, b, offset)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pwriteReturns.result1, fake.pwriteReturns.result2
}

func (fake *FakeSyscall) PwriteCallCount() int {
	fake.pwriteMutex.RLock()
	defer fake.pwriteMutex.RUnlock()
	return len(fake.pwriteArgsForCall)
}

func (fake *FakeSyscall) PwriteArgsForCall(i int) (int, []byte, int64) {
	fake.pwriteMutex.RLock()
	defer fake.pwriteMutex.RUnlock()
	return fake.pwriteArgsForCall[i].fd, fake.pwriteArgsForCall[i].b, fake.pwriteArgsForCall[i].offset
}

func (fake *FakeSyscall) PwriteReturns(result1 int, result2 error) {
	fake.PwriteStub = nil
	fake.pwriteReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PwriteReturnsOnCall(i int, result1 int, result2 error) {
	fake.PwriteStub = nil
	if fake.pwriteReturnsOnCall == nil {
		fake.pwriteReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.pwriteReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Seek(fd int, offset int64, whence int) (int64, error) {
	fake.seekMutex.Lock()
	ret, specificReturn := fake.seekReturnsOnCall[len(fake.seekArgsForCall)]
	fake.seekArgsForCall = append(fake.seekArgsForCall, struct {
		fd     int
		offset int64
		whence int
	}{fd, offset, whence})
	fake.recordInvocation("Seek", []interface{}{fd, offset, whence})
	fake.seekMutex.Unlock()
	if fake.SeekStub != nil {
		return fake.SeekStub(fd, offset, whence)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.seekReturns.result1, fake.seekReturns.result2
}

func (fake *FakeSyscall) SeekCallCount() int {
	fake.seekMutex.RLock()
	defer fake.seekMutex.RUnlock()
	return len(fake.seekArgsForCall)
}

func (fake *FakeSyscall) SeekArgsForCall(i int) (int, int64, int) {
	fake.seekMutex.RLock()
	defer fake.seekMutex.RUnlock()
	return fake.seekArgsForCall[i].fd, fake.seekArgsForCall[i].offset, fake.seekArgsForCall[i].whence
}

func (fake *FakeSyscall) SeekReturns(result1 int64, result2 error) {
	fake.SeekStub = nil
	fake.seekReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SeekReturnsOnCall(i int, result1 int64, result2 error) {
	fake.SeekStub = nil
	if fake.seekReturnsOnCall == nil {
		fake.seekReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.seekReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Pipe(fd []int) error {
	var fdCopy []int
	if fd != nil {
		fdCopy = make([]int, len(fd))
		copy(fdCopy, fd)
	}
	fake.pipeMutex.Lock()
	ret, specificReturn := fake.pipeReturnsOnCall[len(fake.pipeArgsForCall)]
	fake.pipeArgsForCall = append(fake.pipeArgsForCall, struct {
		fd []int
	}{fdCopy})
	fake.recordInvocation("Pipe", []interface{}{fdCopy})
	fake.pipeMutex.Unlock()
	if fake.PipeStub != nil {
		return fake.PipeStub(fd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pipeReturns.result1
}

func (fake *FakeSyscall) PipeCallCount() int {
	fake.pipeMutex.RLock()
	defer fake.pipeMutex.RUnlock()
	return len(fake.pipeArgsForCall)
}

func (fake *FakeSyscall) PipeArgsForCall(i int) []int {
	fake.pipeMutex.RLock()
	defer fake.pipeMutex.RUnlock()
	return fake.pipeArgsForCall[i].fd
}

func (fake *FakeSyscall) PipeReturns(result1 error) {
	fake.PipeStub = nil
	fake.pipeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PipeReturnsOnCall(i int, result1 error) {
	fake.PipeStub = nil
	if fake.pipeReturnsOnCall == nil {
		fake.pipeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pipeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FcntlFlock(fd uintptr, cmd int, lk *syscall.Flock_t) error {
	fake.fcntlFlockMutex.Lock()
	ret, specificReturn := fake.fcntlFlockReturnsOnCall[len(fake.fcntlFlockArgsForCall)]
	fake.fcntlFlockArgsForCall = append(fake.fcntlFlockArgsForCall, struct {
		fd  uintptr
		cmd int
		lk  *syscall.Flock_t
	}{fd, cmd, lk})
	fake.recordInvocation("FcntlFlock", []interface{}{fd, cmd, lk})
	fake.fcntlFlockMutex.Unlock()
	if fake.FcntlFlockStub != nil {
		return fake.FcntlFlockStub(fd, cmd, lk)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fcntlFlockReturns.result1
}

func (fake *FakeSyscall) FcntlFlockCallCount() int {
	fake.fcntlFlockMutex.RLock()
	defer fake.fcntlFlockMutex.RUnlock()
	return len(fake.fcntlFlockArgsForCall)
}

func (fake *FakeSyscall) FcntlFlockArgsForCall(i int) (uintptr, int, *syscall.Flock_t) {
	fake.fcntlFlockMutex.RLock()
	defer fake.fcntlFlockMutex.RUnlock()
	return fake.fcntlFlockArgsForCall[i].fd, fake.fcntlFlockArgsForCall[i].cmd, fake.fcntlFlockArgsForCall[i].lk
}

func (fake *FakeSyscall) FcntlFlockReturns(result1 error) {
	fake.FcntlFlockStub = nil
	fake.fcntlFlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FcntlFlockReturnsOnCall(i int, result1 error) {
	fake.FcntlFlockStub = nil
	if fake.fcntlFlockReturnsOnCall == nil {
		fake.fcntlFlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fcntlFlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ReadDirent(fd int, buf []byte) (int, error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.readDirentMutex.Lock()
	ret, specificReturn := fake.readDirentReturnsOnCall[len(fake.readDirentArgsForCall)]
	fake.readDirentArgsForCall = append(fake.readDirentArgsForCall, struct {
		fd  int
		buf []byte
	}{fd, bufCopy})
	fake.recordInvocation("ReadDirent", []interface{}{fd, bufCopy})
	fake.readDirentMutex.Unlock()
	if fake.ReadDirentStub != nil {
		return fake.ReadDirentStub(fd, buf)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.readDirentReturns.result1, fake.readDirentReturns.result2
}

func (fake *FakeSyscall) ReadDirentCallCount() int {
	fake.readDirentMutex.RLock()
	defer fake.readDirentMutex.RUnlock()
	return len(fake.readDirentArgsForCall)
}

func (fake *FakeSyscall) ReadDirentArgsForCall(i int) (int, []byte) {
	fake.readDirentMutex.RLock()
	defer fake.readDirentMutex.RUnlock()
	return fake.readDirentArgsForCall[i].fd, fake.readDirentArgsForCall[i].buf
}

func (fake *FakeSyscall) ReadDirentReturns(result1 int, result2 error) {
	fake.ReadDirentStub = nil
	fake.readDirentReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ReadDirentReturnsOnCall(i int, result1 int, result2 error) {
	fake.ReadDirentStub = nil
	if fake.readDirentReturnsOnCall == nil {
		fake.readDirentReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.readDirentReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Open(path string, openmode int, perm uint32) (fd int, err error) {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		path     string
		openmode int
		perm     uint32
	}{path, openmode, perm})
	fake.recordInvocation("Open", []interface{}{path, openmode, perm})
	fake.openMutex.Unlock()
	if fake.OpenStub != nil {
		return fake.OpenStub(path, openmode, perm)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.openReturns.result1, fake.openReturns.result2
}

func (fake *FakeSyscall) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeSyscall) OpenArgsForCall(i int) (string, int, uint32) {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return fake.openArgsForCall[i].path, fake.openArgsForCall[i].openmode, fake.openArgsForCall[i].perm
}

func (fake *FakeSyscall) OpenReturns(result1 int, result2 error) {
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) OpenReturnsOnCall(i int, result1 int, result2 error) {
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Mkdir(path string, perm uint32) error {
	fake.mkdirMutex.Lock()
	ret, specificReturn := fake.mkdirReturnsOnCall[len(fake.mkdirArgsForCall)]
	fake.mkdirArgsForCall = append(fake.mkdirArgsForCall, struct {
		path string
		perm uint32
	}{path, perm})
	fake.recordInvocation("Mkdir", []interface{}{path, perm})
	fake.mkdirMutex.Unlock()
	if fake.MkdirStub != nil {
		return fake.MkdirStub(path, perm)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mkdirReturns.result1
}

func (fake *FakeSyscall) MkdirCallCount() int {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return len(fake.mkdirArgsForCall)
}

func (fake *FakeSyscall) MkdirArgsForCall(i int) (string, uint32) {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return fake.mkdirArgsForCall[i].path, fake.mkdirArgsForCall[i].perm
}

func (fake *FakeSyscall) MkdirReturns(result1 error) {
	fake.MkdirStub = nil
	fake.mkdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MkdirReturnsOnCall(i int, result1 error) {
	fake.MkdirStub = nil
	if fake.mkdirReturnsOnCall == nil {
		fake.mkdirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Getcwd(buf []byte) (n int, err error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.getcwdMutex.Lock()
	ret, specificReturn := fake.getcwdReturnsOnCall[len(fake.getcwdArgsForCall)]
	fake.getcwdArgsForCall = append(fake.getcwdArgsForCall, struct {
		buf []byte
	}{bufCopy})
	fake.recordInvocation("Getcwd", []interface{}{bufCopy})
	fake.getcwdMutex.Unlock()
	if fake.GetcwdStub != nil {
		return fake.GetcwdStub(buf)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getcwdReturns.result1, fake.getcwdReturns.result2
}

func (fake *FakeSyscall) GetcwdCallCount() int {
	fake.getcwdMutex.RLock()
	defer fake.getcwdMutex.RUnlock()
	return len(fake.getcwdArgsForCall)
}

func (fake *FakeSyscall) GetcwdArgsForCall(i int) []byte {
	fake.getcwdMutex.RLock()
	defer fake.getcwdMutex.RUnlock()
	return fake.getcwdArgsForCall[i].buf
}

func (fake *FakeSyscall) GetcwdReturns(result1 int, result2 error) {
	fake.GetcwdStub = nil
	fake.getcwdReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetcwdReturnsOnCall(i int, result1 int, result2 error) {
	fake.GetcwdStub = nil
	if fake.getcwdReturnsOnCall == nil {
		fake.getcwdReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getcwdReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Stat(path string, st *syscall.Stat_t) error {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		path string
		st   *syscall.Stat_t
	}{path, st})
	fake.recordInvocation("Stat", []interface{}{path, st})
	fake.statMutex.Unlock()
	if fake.StatStub != nil {
		return fake.StatStub(path, st)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.statReturns.result1
}

func (fake *FakeSyscall) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeSyscall) StatArgsForCall(i int) (string, *syscall.Stat_t) {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return fake.statArgsForCall[i].path, fake.statArgsForCall[i].st
}

func (fake *FakeSyscall) StatReturns(result1 error) {
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) StatReturnsOnCall(i int, result1 error) {
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Lstat(path string, st *syscall.Stat_t) error {
	fake.lstatMutex.Lock()
	ret, specificReturn := fake.lstatReturnsOnCall[len(fake.lstatArgsForCall)]
	fake.lstatArgsForCall = append(fake.lstatArgsForCall, struct {
		path string
		st   *syscall.Stat_t
	}{path, st})
	fake.recordInvocation("Lstat", []interface{}{path, st})
	fake.lstatMutex.Unlock()
	if fake.LstatStub != nil {
		return fake.LstatStub(path, st)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.lstatReturns.result1
}

func (fake *FakeSyscall) LstatCallCount() int {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	return len(fake.lstatArgsForCall)
}

func (fake *FakeSyscall) LstatArgsForCall(i int) (string, *syscall.Stat_t) {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	return fake.lstatArgsForCall[i].path, fake.lstatArgsForCall[i].st
}

func (fake *FakeSyscall) LstatReturns(result1 error) {
	fake.LstatStub = nil
	fake.lstatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LstatReturnsOnCall(i int, result1 error) {
	fake.LstatStub = nil
	if fake.lstatReturnsOnCall == nil {
		fake.lstatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.lstatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Unlink(path string) error {
	fake.unlinkMutex.Lock()
	ret, specificReturn := fake.unlinkReturnsOnCall[len(fake.unlinkArgsForCall)]
	fake.unlinkArgsForCall = append(fake.unlinkArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("Unlink", []interface{}{path})
	fake.unlinkMutex.Unlock()
	if fake.UnlinkStub != nil {
		return fake.UnlinkStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unlinkReturns.result1
}

func (fake *FakeSyscall) UnlinkCallCount() int {
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	return len(fake.unlinkArgsForCall)
}

func (fake *FakeSyscall) UnlinkArgsForCall(i int) string {
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	return fake.unlinkArgsForCall[i].path
}

func (fake *FakeSyscall) UnlinkReturns(result1 error) {
	fake.UnlinkStub = nil
	fake.unlinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UnlinkReturnsOnCall(i int, result1 error) {
	fake.UnlinkStub = nil
	if fake.unlinkReturnsOnCall == nil {
		fake.unlinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unlinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Rmdir(path string) error {
	fake.rmdirMutex.Lock()
	ret, specificReturn := fake.rmdirReturnsOnCall[len(fake.rmdirArgsForCall)]
	fake.rmdirArgsForCall = append(fake.rmdirArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("Rmdir", []interface{}{path})
	fake.rmdirMutex.Unlock()
	if fake.RmdirStub != nil {
		return fake.RmdirStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rmdirReturns.result1
}

func (fake *FakeSyscall) RmdirCallCount() int {
	fake.rmdirMutex.RLock()
	defer fake.rmdirMutex.RUnlock()
	return len(fake.rmdirArgsForCall)
}

func (fake *FakeSyscall) RmdirArgsForCall(i int) string {
	fake.rmdirMutex.RLock()
	defer fake.rmdirMutex.RUnlock()
	return fake.rmdirArgsForCall[i].path
}

func (fake *FakeSyscall) RmdirReturns(result1 error) {
	fake.RmdirStub = nil
	fake.rmdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RmdirReturnsOnCall(i int, result1 error) {
	fake.RmdirStub = nil
	if fake.rmdirReturnsOnCall == nil {
		fake.rmdirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rmdirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Chmod(path string, mode uint32) error {
	fake.chmodMutex.Lock()
	ret, specificReturn := fake.chmodReturnsOnCall[len(fake.chmodArgsForCall)]
	fake.chmodArgsForCall = append(fake.chmodArgsForCall, struct {
		path string
		mode uint32
	}{path, mode})
	fake.recordInvocation("Chmod", []interface{}{path, mode})
	fake.chmodMutex.Unlock()
	if fake.ChmodStub != nil {
		return fake.ChmodStub(path, mode)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.chmodReturns.result1
}

func (fake *FakeSyscall) ChmodCallCount() int {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	return len(fake.chmodArgsForCall)
}

func (fake *FakeSyscall) ChmodArgsForCall(i int) (string, uint32) {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	return fake.chmodArgsForCall[i].path, fake.chmodArgsForCall[i].mode
}

func (fake *FakeSyscall) ChmodReturns(result1 error) {
	fake.ChmodStub = nil
	fake.chmodReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ChmodReturnsOnCall(i int, result1 error) {
	fake.ChmodStub = nil
	if fake.chmodReturnsOnCall == nil {
		fake.chmodReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chmodReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fchmod(fd int, mode uint32) error {
	fake.fchmodMutex.Lock()
	ret, specificReturn := fake.fchmodReturnsOnCall[len(fake.fchmodArgsForCall)]
	fake.fchmodArgsForCall = append(fake.fchmodArgsForCall, struct {
		fd   int
		mode uint32
	}{fd, mode})
	fake.recordInvocation("Fchmod", []interface{}{fd, mode})
	fake.fchmodMutex.Unlock()
	if fake.FchmodStub != nil {
		return fake.FchmodStub(fd, mode)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fchmodReturns.result1
}

func (fake *FakeSyscall) FchmodCallCount() int {
	fake.fchmodMutex.RLock()
	defer fake.fchmodMutex.RUnlock()
	return len(fake.fchmodArgsForCall)
}

func (fake *FakeSyscall) FchmodArgsForCall(i int) (int, uint32) {
	fake.fchmodMutex.RLock()
	defer fake.fchmodMutex.RUnlock()
	return fake.fchmodArgsForCall[i].fd, fake.fchmodArgsForCall[i].mode
}

func (fake *FakeSyscall) FchmodReturns(result1 error) {
	fake.FchmodStub = nil
	fake.fchmodReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FchmodReturnsOnCall(i int, result1 error) {
	fake.FchmodStub = nil
	if fake.fchmodReturnsOnCall == nil {
		fake.fchmodReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fchmodReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Chown(path string, uid int, gid int) error {
	fake.chownMutex.Lock()
	ret, specificReturn := fake.chownReturnsOnCall[len(fake.chownArgsForCall)]
	fake.chownArgsForCall = append(fake.chownArgsForCall, struct {
		path string
		uid  int
		gid  int
	}{path, uid, gid})
	fake.recordInvocation("Chown", []interface{}{path, uid, gid})
	fake.chownMutex.Unlock()
	if fake.ChownStub != nil {
		return fake.ChownStub(path, uid, gid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.chownReturns.result1
}

func (fake *FakeSyscall) ChownCallCount() int {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return len(fake.chownArgsForCall)
}

func (fake *FakeSyscall) ChownArgsForCall(i int) (string, int, int) {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return fake.chownArgsForCall[i].path, fake.chownArgsForCall[i].uid, fake.chownArgsForCall[i].gid
}

func (fake *FakeSyscall) ChownReturns(result1 error) {
	fake.ChownStub = nil
	fake.chownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ChownReturnsOnCall(i int, result1 error) {
	fake.ChownStub = nil
	if fake.chownReturnsOnCall == nil {
		fake.chownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fchown(fd int, uid int, gid int) error {
	fake.fchownMutex.Lock()
	ret, specificReturn := fake.fchownReturnsOnCall[len(fake.fchownArgsForCall)]
	fake.fchownArgsForCall = append(fake.fchownArgsForCall, struct {
		fd  int
		uid int
		gid int
	}{fd, uid, gid})
	fake.recordInvocation("Fchown", []interface{}{fd, uid, gid})
	fake.fchownMutex.Unlock()
	if fake.FchownStub != nil {
		return fake.FchownStub(fd, uid, gid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fchownReturns.result1
}

func (fake *FakeSyscall) FchownCallCount() int {
	fake.fchownMutex.RLock()
	defer fake.fchownMutex.RUnlock()
	return len(fake.fchownArgsForCall)
}

func (fake *FakeSyscall) FchownArgsForCall(i int) (int, int, int) {
	fake.fchownMutex.RLock()
	defer fake.fchownMutex.RUnlock()
	return fake.fchownArgsForCall[i].fd, fake.fchownArgsForCall[i].uid, fake.fchownArgsForCall[i].gid
}

func (fake *FakeSyscall) FchownReturns(result1 error) {
	fake.FchownStub = nil
	fake.fchownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FchownReturnsOnCall(i int, result1 error) {
	fake.FchownStub = nil
	if fake.fchownReturnsOnCall == nil {
		fake.fchownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fchownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Lchown(path string, uid int, gid int) error {
	fake.lchownMutex.Lock()
	ret, specificReturn := fake.lchownReturnsOnCall[len(fake.lchownArgsForCall)]
	fake.lchownArgsForCall = append(fake.lchownArgsForCall, struct {
		path string
		uid  int
		gid  int
	}{path, uid, gid})
	fake.recordInvocation("Lchown", []interface{}{path, uid, gid})
	fake.lchownMutex.Unlock()
	if fake.LchownStub != nil {
		return fake.LchownStub(path, uid, gid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.lchownReturns.result1
}

func (fake *FakeSyscall) LchownCallCount() int {
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	return len(fake.lchownArgsForCall)
}

func (fake *FakeSyscall) LchownArgsForCall(i int) (string, int, int) {
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	return fake.lchownArgsForCall[i].path, fake.lchownArgsForCall[i].uid, fake.lchownArgsForCall[i].gid
}

func (fake *FakeSyscall) LchownReturns(result1 error) {
	fake.LchownStub = nil
	fake.lchownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LchownReturnsOnCall(i int, result1 error) {
	fake.LchownStub = nil
	if fake.lchownReturnsOnCall == nil {
		fake.lchownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.lchownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UtimesNano(path string, ts []syscall.Timespec) error {
	var tsCopy []syscall.Timespec
	if ts != nil {
		tsCopy = make([]syscall.Timespec, len(ts))
		copy(tsCopy, ts)
	}
	fake.utimesNanoMutex.Lock()
	ret, specificReturn := fake.utimesNanoReturnsOnCall[len(fake.utimesNanoArgsForCall)]
	fake.utimesNanoArgsForCall = append(fake.utimesNanoArgsForCall, struct {
		path string
		ts   []syscall.Timespec
	}{path, tsCopy})
	fake.recordInvocation("UtimesNano", []interface{}{path, tsCopy})
	fake.utimesNanoMutex.Unlock()
	if fake.UtimesNanoStub != nil {
		return fake.UtimesNanoStub(path, ts)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.utimesNanoReturns.result1
}

func (fake *FakeSyscall) UtimesNanoCallCount() int {
	fake.utimesNanoMutex.RLock()
	defer fake.utimesNanoMutex.RUnlock()
	return len(fake.utimesNanoArgsForCall)
}

func (fake *FakeSyscall) UtimesNanoArgsForCall(i int) (string, []syscall.Timespec) {
	fake.utimesNanoMutex.RLock()
	defer fake.utimesNanoMutex.RUnlock()
	return fake.utimesNanoArgsForCall[i].path, fake.utimesNanoArgsForCall[i].ts
}

func (fake *FakeSyscall) UtimesNanoReturns(result1 error) {
	fake.UtimesNanoStub = nil
	fake.utimesNanoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UtimesNanoReturnsOnCall(i int, result1 error) {
	fake.UtimesNanoStub = nil
	if fake.utimesNanoReturnsOnCall == nil {
		fake.utimesNanoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.utimesNanoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Link(path string, link string) error {
	fake.linkMutex.Lock()
	ret, specificReturn := fake.linkReturnsOnCall[len(fake.linkArgsForCall)]
	fake.linkArgsForCall = append(fake.linkArgsForCall, struct {
		path string
		link string
	}{path, link})
	fake.recordInvocation("Link", []interface{}{path, link})
	fake.linkMutex.Unlock()
	if fake.LinkStub != nil {
		return fake.LinkStub(path, link)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.linkReturns.result1
}

func (fake *FakeSyscall) LinkCallCount() int {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	return len(fake.linkArgsForCall)
}

func (fake *FakeSyscall) LinkArgsForCall(i int) (string, string) {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	return fake.linkArgsForCall[i].path, fake.linkArgsForCall[i].link
}

func (fake *FakeSyscall) LinkReturns(result1 error) {
	fake.LinkStub = nil
	fake.linkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LinkReturnsOnCall(i int, result1 error) {
	fake.LinkStub = nil
	if fake.linkReturnsOnCall == nil {
		fake.linkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.linkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Rename(from string, to string) error {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		from string
		to   string
	}{from, to})
	fake.recordInvocation("Rename", []interface{}{from, to})
	fake.renameMutex.Unlock()
	if fake.RenameStub != nil {
		return fake.RenameStub(from, to)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.renameReturns.result1
}

func (fake *FakeSyscall) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakeSyscall) RenameArgsForCall(i int) (string, string) {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return fake.renameArgsForCall[i].from, fake.renameArgsForCall[i].to
}

func (fake *FakeSyscall) RenameReturns(result1 error) {
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RenameReturnsOnCall(i int, result1 error) {
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Truncate(path string, length int64) error {
	fake.truncateMutex.Lock()
	ret, specificReturn := fake.truncateReturnsOnCall[len(fake.truncateArgsForCall)]
	fake.truncateArgsForCall = append(fake.truncateArgsForCall, struct {
		path   string
		length int64
	}{path, length})
	fake.recordInvocation("Truncate", []interface{}{path, length})
	fake.truncateMutex.Unlock()
	if fake.TruncateStub != nil {
		return fake.TruncateStub(path, length)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.truncateReturns.result1
}

func (fake *FakeSyscall) TruncateCallCount() int {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	return len(fake.truncateArgsForCall)
}

func (fake *FakeSyscall) TruncateArgsForCall(i int) (string, int64) {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	return fake.truncateArgsForCall[i].path, fake.truncateArgsForCall[i].length
}

func (fake *FakeSyscall) TruncateReturns(result1 error) {
	fake.TruncateStub = nil
	fake.truncateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) TruncateReturnsOnCall(i int, result1 error) {
	fake.TruncateStub = nil
	if fake.truncateReturnsOnCall == nil {
		fake.truncateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.truncateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Ftruncate(fd int, length int64) error {
	fake.ftruncateMutex.Lock()
	ret, specificReturn := fake.ftruncateReturnsOnCall[len(fake.ftruncateArgsForCall)]
	fake.ftruncateArgsForCall = append(fake.ftruncateArgsForCall, struct {
		fd     int
		length int64
	}{fd, length})
	fake.recordInvocation("Ftruncate", []interface{}{fd, length})
	fake.ftruncateMutex.Unlock()
	if fake.FtruncateStub != nil {
		return fake.FtruncateStub(fd, length)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ftruncateReturns.result1
}

func (fake *FakeSyscall) FtruncateCallCount() int {
	fake.ftruncateMutex.RLock()
	defer fake.ftruncateMutex.RUnlock()
	return len(fake.ftruncateArgsForCall)
}

func (fake *FakeSyscall) FtruncateArgsForCall(i int) (int, int64) {
	fake.ftruncateMutex.RLock()
	defer fake.ftruncateMutex.RUnlock()
	return fake.ftruncateArgsForCall[i].fd, fake.ftruncateArgsForCall[i].length
}

func (fake *FakeSyscall) FtruncateReturns(result1 error) {
	fake.FtruncateStub = nil
	fake.ftruncateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FtruncateReturnsOnCall(i int, result1 error) {
	fake.FtruncateStub = nil
	if fake.ftruncateReturnsOnCall == nil {
		fake.ftruncateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ftruncateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Chdir(path string) error {
	fake.chdirMutex.Lock()
	ret, specificReturn := fake.chdirReturnsOnCall[len(fake.chdirArgsForCall)]
	fake.chdirArgsForCall = append(fake.chdirArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("Chdir", []interface{}{path})
	fake.chdirMutex.Unlock()
	if fake.ChdirStub != nil {
		return fake.ChdirStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.chdirReturns.result1
}

func (fake *FakeSyscall) ChdirCallCount() int {
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	return len(fake.chdirArgsForCall)
}

func (fake *FakeSyscall) ChdirArgsForCall(i int) string {
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	return fake.chdirArgsForCall[i].path
}

func (fake *FakeSyscall) ChdirReturns(result1 error) {
	fake.ChdirStub = nil
	fake.chdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ChdirReturnsOnCall(i int, result1 error) {
	fake.ChdirStub = nil
	if fake.chdirReturnsOnCall == nil {
		fake.chdirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chdirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fchdir(fd int) error {
	fake.fchdirMutex.Lock()
	ret, specificReturn := fake.fchdirReturnsOnCall[len(fake.fchdirArgsForCall)]
	fake.fchdirArgsForCall = append(fake.fchdirArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("Fchdir", []interface{}{fd})
	fake.fchdirMutex.Unlock()
	if fake.FchdirStub != nil {
		return fake.FchdirStub(fd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fchdirReturns.result1
}

func (fake *FakeSyscall) FchdirCallCount() int {
	fake.fchdirMutex.RLock()
	defer fake.fchdirMutex.RUnlock()
	return len(fake.fchdirArgsForCall)
}

func (fake *FakeSyscall) FchdirArgsForCall(i int) int {
	fake.fchdirMutex.RLock()
	defer fake.fchdirMutex.RUnlock()
	return fake.fchdirArgsForCall[i].fd
}

func (fake *FakeSyscall) FchdirReturns(result1 error) {
	fake.FchdirStub = nil
	fake.fchdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FchdirReturnsOnCall(i int, result1 error) {
	fake.FchdirStub = nil
	if fake.fchdirReturnsOnCall == nil {
		fake.fchdirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fchdirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Readlink(path string, buf []byte) (n int, err error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.readlinkMutex.Lock()
	ret, specificReturn := fake.readlinkReturnsOnCall[len(fake.readlinkArgsForCall)]
	fake.readlinkArgsForCall = append(fake.readlinkArgsForCall, struct {
		path string
		buf  []byte
	}{path, bufCopy})
	fake.recordInvocation("Readlink", []interface{}{path, bufCopy})
	fake.readlinkMutex.Unlock()
	if fake.ReadlinkStub != nil {
		return fake.ReadlinkStub(path, buf)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.readlinkReturns.result1, fake.readlinkReturns.result2
}

func (fake *FakeSyscall) ReadlinkCallCount() int {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	return len(fake.readlinkArgsForCall)
}

func (fake *FakeSyscall) ReadlinkArgsForCall(i int) (string, []byte) {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	return fake.readlinkArgsForCall[i].path, fake.readlinkArgsForCall[i].buf
}

func (fake *FakeSyscall) ReadlinkReturns(result1 int, result2 error) {
	fake.ReadlinkStub = nil
	fake.readlinkReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ReadlinkReturnsOnCall(i int, result1 int, result2 error) {
	fake.ReadlinkStub = nil
	if fake.readlinkReturnsOnCall == nil {
		fake.readlinkReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.readlinkReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Symlink(path string, link string) error {
	fake.symlinkMutex.Lock()
	ret, specificReturn := fake.symlinkReturnsOnCall[len(fake.symlinkArgsForCall)]
	fake.symlinkArgsForCall = append(fake.symlinkArgsForCall, struct {
		path string
		link string
	}{path, link})
	fake.recordInvocation("Symlink", []interface{}{path, link})
	fake.symlinkMutex.Unlock()
	if fake.SymlinkStub != nil {
		return fake.SymlinkStub(path, link)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.symlinkReturns.result1
}

func (fake *FakeSyscall) SymlinkCallCount() int {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return len(fake.symlinkArgsForCall)
}

func (fake *FakeSyscall) SymlinkArgsForCall(i int) (string, string) {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return fake.symlinkArgsForCall[i].path, fake.symlinkArgsForCall[i].link
}

func (fake *FakeSyscall) SymlinkReturns(result1 error) {
	fake.SymlinkStub = nil
	fake.symlinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SymlinkReturnsOnCall(i int, result1 error) {
	fake.SymlinkStub = nil
	if fake.symlinkReturnsOnCall == nil {
		fake.symlinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.symlinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fsync(fd int) error {
	fake.fsyncMutex.Lock()
	ret, specificReturn := fake.fsyncReturnsOnCall[len(fake.fsyncArgsForCall)]
	fake.fsyncArgsForCall = append(fake.fsyncArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("Fsync", []interface{}{fd})
	fake.fsyncMutex.Unlock()
	if fake.FsyncStub != nil {
		return fake.FsyncStub(fd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fsyncReturns.result1
}

func (fake *FakeSyscall) FsyncCallCount() int {
	fake.fsyncMutex.RLock()
	defer fake.fsyncMutex.RUnlock()
	return len(fake.fsyncArgsForCall)
}

func (fake *FakeSyscall) FsyncArgsForCall(i int) int {
	fake.fsyncMutex.RLock()
	defer fake.fsyncMutex.RUnlock()
	return fake.fsyncArgsForCall[i].fd
}

func (fake *FakeSyscall) FsyncReturns(result1 error) {
	fake.FsyncStub = nil
	fake.fsyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FsyncReturnsOnCall(i int, result1 error) {
	fake.FsyncStub = nil
	if fake.fsyncReturnsOnCall == nil {
		fake.fsyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fsyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LsfStmt(code int, k int) *syscall.SockFilter {
	fake.lsfStmtMutex.Lock()
	ret, specificReturn := fake.lsfStmtReturnsOnCall[len(fake.lsfStmtArgsForCall)]
	fake.lsfStmtArgsForCall = append(fake.lsfStmtArgsForCall, struct {
		code int
		k    int
	}{code, k})
	fake.recordInvocation("LsfStmt", []interface{}{code, k})
	fake.lsfStmtMutex.Unlock()
	if fake.LsfStmtStub != nil {
		return fake.LsfStmtStub(code, k)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.lsfStmtReturns.result1
}

func (fake *FakeSyscall) LsfStmtCallCount() int {
	fake.lsfStmtMutex.RLock()
	defer fake.lsfStmtMutex.RUnlock()
	return len(fake.lsfStmtArgsForCall)
}

func (fake *FakeSyscall) LsfStmtArgsForCall(i int) (int, int) {
	fake.lsfStmtMutex.RLock()
	defer fake.lsfStmtMutex.RUnlock()
	return fake.lsfStmtArgsForCall[i].code, fake.lsfStmtArgsForCall[i].k
}

func (fake *FakeSyscall) LsfStmtReturns(result1 *syscall.SockFilter) {
	fake.LsfStmtStub = nil
	fake.lsfStmtReturns = struct {
		result1 *syscall.SockFilter
	}{result1}
}

func (fake *FakeSyscall) LsfStmtReturnsOnCall(i int, result1 *syscall.SockFilter) {
	fake.LsfStmtStub = nil
	if fake.lsfStmtReturnsOnCall == nil {
		fake.lsfStmtReturnsOnCall = make(map[int]struct {
			result1 *syscall.SockFilter
		})
	}
	fake.lsfStmtReturnsOnCall[i] = struct {
		result1 *syscall.SockFilter
	}{result1}
}

func (fake *FakeSyscall) LsfJump(code int, k int, jt int, jf int) *syscall.SockFilter {
	fake.lsfJumpMutex.Lock()
	ret, specificReturn := fake.lsfJumpReturnsOnCall[len(fake.lsfJumpArgsForCall)]
	fake.lsfJumpArgsForCall = append(fake.lsfJumpArgsForCall, struct {
		code int
		k    int
		jt   int
		jf   int
	}{code, k, jt, jf})
	fake.recordInvocation("LsfJump", []interface{}{code, k, jt, jf})
	fake.lsfJumpMutex.Unlock()
	if fake.LsfJumpStub != nil {
		return fake.LsfJumpStub(code, k, jt, jf)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.lsfJumpReturns.result1
}

func (fake *FakeSyscall) LsfJumpCallCount() int {
	fake.lsfJumpMutex.RLock()
	defer fake.lsfJumpMutex.RUnlock()
	return len(fake.lsfJumpArgsForCall)
}

func (fake *FakeSyscall) LsfJumpArgsForCall(i int) (int, int, int, int) {
	fake.lsfJumpMutex.RLock()
	defer fake.lsfJumpMutex.RUnlock()
	return fake.lsfJumpArgsForCall[i].code, fake.lsfJumpArgsForCall[i].k, fake.lsfJumpArgsForCall[i].jt, fake.lsfJumpArgsForCall[i].jf
}

func (fake *FakeSyscall) LsfJumpReturns(result1 *syscall.SockFilter) {
	fake.LsfJumpStub = nil
	fake.lsfJumpReturns = struct {
		result1 *syscall.SockFilter
	}{result1}
}

func (fake *FakeSyscall) LsfJumpReturnsOnCall(i int, result1 *syscall.SockFilter) {
	fake.LsfJumpStub = nil
	if fake.lsfJumpReturnsOnCall == nil {
		fake.lsfJumpReturnsOnCall = make(map[int]struct {
			result1 *syscall.SockFilter
		})
	}
	fake.lsfJumpReturnsOnCall[i] = struct {
		result1 *syscall.SockFilter
	}{result1}
}

func (fake *FakeSyscall) LsfSocket(ifindex int, proto int) (int, error) {
	fake.lsfSocketMutex.Lock()
	ret, specificReturn := fake.lsfSocketReturnsOnCall[len(fake.lsfSocketArgsForCall)]
	fake.lsfSocketArgsForCall = append(fake.lsfSocketArgsForCall, struct {
		ifindex int
		proto   int
	}{ifindex, proto})
	fake.recordInvocation("LsfSocket", []interface{}{ifindex, proto})
	fake.lsfSocketMutex.Unlock()
	if fake.LsfSocketStub != nil {
		return fake.LsfSocketStub(ifindex, proto)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.lsfSocketReturns.result1, fake.lsfSocketReturns.result2
}

func (fake *FakeSyscall) LsfSocketCallCount() int {
	fake.lsfSocketMutex.RLock()
	defer fake.lsfSocketMutex.RUnlock()
	return len(fake.lsfSocketArgsForCall)
}

func (fake *FakeSyscall) LsfSocketArgsForCall(i int) (int, int) {
	fake.lsfSocketMutex.RLock()
	defer fake.lsfSocketMutex.RUnlock()
	return fake.lsfSocketArgsForCall[i].ifindex, fake.lsfSocketArgsForCall[i].proto
}

func (fake *FakeSyscall) LsfSocketReturns(result1 int, result2 error) {
	fake.LsfSocketStub = nil
	fake.lsfSocketReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) LsfSocketReturnsOnCall(i int, result1 int, result2 error) {
	fake.LsfSocketStub = nil
	if fake.lsfSocketReturnsOnCall == nil {
		fake.lsfSocketReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.lsfSocketReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetLsfPromisc(name string, m bool) error {
	fake.setLsfPromiscMutex.Lock()
	ret, specificReturn := fake.setLsfPromiscReturnsOnCall[len(fake.setLsfPromiscArgsForCall)]
	fake.setLsfPromiscArgsForCall = append(fake.setLsfPromiscArgsForCall, struct {
		name string
		m    bool
	}{name, m})
	fake.recordInvocation("SetLsfPromisc", []interface{}{name, m})
	fake.setLsfPromiscMutex.Unlock()
	if fake.SetLsfPromiscStub != nil {
		return fake.SetLsfPromiscStub(name, m)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setLsfPromiscReturns.result1
}

func (fake *FakeSyscall) SetLsfPromiscCallCount() int {
	fake.setLsfPromiscMutex.RLock()
	defer fake.setLsfPromiscMutex.RUnlock()
	return len(fake.setLsfPromiscArgsForCall)
}

func (fake *FakeSyscall) SetLsfPromiscArgsForCall(i int) (string, bool) {
	fake.setLsfPromiscMutex.RLock()
	defer fake.setLsfPromiscMutex.RUnlock()
	return fake.setLsfPromiscArgsForCall[i].name, fake.setLsfPromiscArgsForCall[i].m
}

func (fake *FakeSyscall) SetLsfPromiscReturns(result1 error) {
	fake.SetLsfPromiscStub = nil
	fake.setLsfPromiscReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetLsfPromiscReturnsOnCall(i int, result1 error) {
	fake.SetLsfPromiscStub = nil
	if fake.setLsfPromiscReturnsOnCall == nil {
		fake.setLsfPromiscReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setLsfPromiscReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) AttachLsf(fd int, i []syscall.SockFilter) error {
	var iCopy []syscall.SockFilter
	if i != nil {
		iCopy = make([]syscall.SockFilter, len(i))
		copy(iCopy, i)
	}
	fake.attachLsfMutex.Lock()
	ret, specificReturn := fake.attachLsfReturnsOnCall[len(fake.attachLsfArgsForCall)]
	fake.attachLsfArgsForCall = append(fake.attachLsfArgsForCall, struct {
		fd int
		i  []syscall.SockFilter
	}{fd, iCopy})
	fake.recordInvocation("AttachLsf", []interface{}{fd, iCopy})
	fake.attachLsfMutex.Unlock()
	if fake.AttachLsfStub != nil {
		return fake.AttachLsfStub(fd, i)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.attachLsfReturns.result1
}

func (fake *FakeSyscall) AttachLsfCallCount() int {
	fake.attachLsfMutex.RLock()
	defer fake.attachLsfMutex.RUnlock()
	return len(fake.attachLsfArgsForCall)
}

func (fake *FakeSyscall) AttachLsfArgsForCall(i int) (int, []syscall.SockFilter) {
	fake.attachLsfMutex.RLock()
	defer fake.attachLsfMutex.RUnlock()
	return fake.attachLsfArgsForCall[i].fd, fake.attachLsfArgsForCall[i].i
}

func (fake *FakeSyscall) AttachLsfReturns(result1 error) {
	fake.AttachLsfStub = nil
	fake.attachLsfReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) AttachLsfReturnsOnCall(i int, result1 error) {
	fake.AttachLsfStub = nil
	if fake.attachLsfReturnsOnCall == nil {
		fake.attachLsfReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachLsfReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) DetachLsf(fd int) error {
	fake.detachLsfMutex.Lock()
	ret, specificReturn := fake.detachLsfReturnsOnCall[len(fake.detachLsfArgsForCall)]
	fake.detachLsfArgsForCall = append(fake.detachLsfArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("DetachLsf", []interface{}{fd})
	fake.detachLsfMutex.Unlock()
	if fake.DetachLsfStub != nil {
		return fake.DetachLsfStub(fd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.detachLsfReturns.result1
}

func (fake *FakeSyscall) DetachLsfCallCount() int {
	fake.detachLsfMutex.RLock()
	defer fake.detachLsfMutex.RUnlock()
	return len(fake.detachLsfArgsForCall)
}

func (fake *FakeSyscall) DetachLsfArgsForCall(i int) int {
	fake.detachLsfMutex.RLock()
	defer fake.detachLsfMutex.RUnlock()
	return fake.detachLsfArgsForCall[i].fd
}

func (fake *FakeSyscall) DetachLsfReturns(result1 error) {
	fake.DetachLsfStub = nil
	fake.detachLsfReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) DetachLsfReturnsOnCall(i int, result1 error) {
	fake.DetachLsfStub = nil
	if fake.detachLsfReturnsOnCall == nil {
		fake.detachLsfReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachLsfReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ParseFiles(fs []string) (*Source, error) {
	var fsCopy []string
	if fs != nil {
		fsCopy = make([]string, len(fs))
		copy(fsCopy, fs)
	}
	fake.parseFilesMutex.Lock()
	ret, specificReturn := fake.parseFilesReturnsOnCall[len(fake.parseFilesArgsForCall)]
	fake.parseFilesArgsForCall = append(fake.parseFilesArgsForCall, struct {
		fs []string
	}{fsCopy})
	fake.recordInvocation("ParseFiles", []interface{}{fsCopy})
	fake.parseFilesMutex.Unlock()
	if fake.ParseFilesStub != nil {
		return fake.ParseFilesStub(fs)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseFilesReturns.result1, fake.parseFilesReturns.result2
}

func (fake *FakeSyscall) ParseFilesCallCount() int {
	fake.parseFilesMutex.RLock()
	defer fake.parseFilesMutex.RUnlock()
	return len(fake.parseFilesArgsForCall)
}

func (fake *FakeSyscall) ParseFilesArgsForCall(i int) []string {
	fake.parseFilesMutex.RLock()
	defer fake.parseFilesMutex.RUnlock()
	return fake.parseFilesArgsForCall[i].fs
}

func (fake *FakeSyscall) ParseFilesReturns(result1 *Source, result2 error) {
	fake.ParseFilesStub = nil
	fake.parseFilesReturns = struct {
		result1 *Source
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseFilesReturnsOnCall(i int, result1 *Source, result2 error) {
	fake.ParseFilesStub = nil
	if fake.parseFilesReturnsOnCall == nil {
		fake.parseFilesReturnsOnCall = make(map[int]struct {
			result1 *Source
			result2 error
		})
	}
	fake.parseFilesReturnsOnCall[i] = struct {
		result1 *Source
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Socket(proto int, sotype int, unused int) (fd int, err error) {
	fake.socketMutex.Lock()
	ret, specificReturn := fake.socketReturnsOnCall[len(fake.socketArgsForCall)]
	fake.socketArgsForCall = append(fake.socketArgsForCall, struct {
		proto  int
		sotype int
		unused int
	}{proto, sotype, unused})
	fake.recordInvocation("Socket", []interface{}{proto, sotype, unused})
	fake.socketMutex.Unlock()
	if fake.SocketStub != nil {
		return fake.SocketStub(proto, sotype, unused)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.socketReturns.result1, fake.socketReturns.result2
}

func (fake *FakeSyscall) SocketCallCount() int {
	fake.socketMutex.RLock()
	defer fake.socketMutex.RUnlock()
	return len(fake.socketArgsForCall)
}

func (fake *FakeSyscall) SocketArgsForCall(i int) (int, int, int) {
	fake.socketMutex.RLock()
	defer fake.socketMutex.RUnlock()
	return fake.socketArgsForCall[i].proto, fake.socketArgsForCall[i].sotype, fake.socketArgsForCall[i].unused
}

func (fake *FakeSyscall) SocketReturns(result1 int, result2 error) {
	fake.SocketStub = nil
	fake.socketReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SocketReturnsOnCall(i int, result1 int, result2 error) {
	fake.SocketStub = nil
	if fake.socketReturnsOnCall == nil {
		fake.socketReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.socketReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Bind(fd int, sa syscall.Sockaddr) error {
	fake.bindMutex.Lock()
	ret, specificReturn := fake.bindReturnsOnCall[len(fake.bindArgsForCall)]
	fake.bindArgsForCall = append(fake.bindArgsForCall, struct {
		fd int
		sa syscall.Sockaddr
	}{fd, sa})
	fake.recordInvocation("Bind", []interface{}{fd, sa})
	fake.bindMutex.Unlock()
	if fake.BindStub != nil {
		return fake.BindStub(fd, sa)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bindReturns.result1
}

func (fake *FakeSyscall) BindCallCount() int {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	return len(fake.bindArgsForCall)
}

func (fake *FakeSyscall) BindArgsForCall(i int) (int, syscall.Sockaddr) {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	return fake.bindArgsForCall[i].fd, fake.bindArgsForCall[i].sa
}

func (fake *FakeSyscall) BindReturns(result1 error) {
	fake.BindStub = nil
	fake.bindReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) BindReturnsOnCall(i int, result1 error) {
	fake.BindStub = nil
	if fake.bindReturnsOnCall == nil {
		fake.bindReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bindReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) StopIO(fd int) error {
	fake.stopIOMutex.Lock()
	ret, specificReturn := fake.stopIOReturnsOnCall[len(fake.stopIOArgsForCall)]
	fake.stopIOArgsForCall = append(fake.stopIOArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("StopIO", []interface{}{fd})
	fake.stopIOMutex.Unlock()
	if fake.StopIOStub != nil {
		return fake.StopIOStub(fd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stopIOReturns.result1
}

func (fake *FakeSyscall) StopIOCallCount() int {
	fake.stopIOMutex.RLock()
	defer fake.stopIOMutex.RUnlock()
	return len(fake.stopIOArgsForCall)
}

func (fake *FakeSyscall) StopIOArgsForCall(i int) int {
	fake.stopIOMutex.RLock()
	defer fake.stopIOMutex.RUnlock()
	return fake.stopIOArgsForCall[i].fd
}

func (fake *FakeSyscall) StopIOReturns(result1 error) {
	fake.StopIOStub = nil
	fake.stopIOReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) StopIOReturnsOnCall(i int, result1 error) {
	fake.StopIOStub = nil
	if fake.stopIOReturnsOnCall == nil {
		fake.stopIOReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopIOReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Listen(fd int, backlog int) error {
	fake.listenMutex.Lock()
	ret, specificReturn := fake.listenReturnsOnCall[len(fake.listenArgsForCall)]
	fake.listenArgsForCall = append(fake.listenArgsForCall, struct {
		fd      int
		backlog int
	}{fd, backlog})
	fake.recordInvocation("Listen", []interface{}{fd, backlog})
	fake.listenMutex.Unlock()
	if fake.ListenStub != nil {
		return fake.ListenStub(fd, backlog)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.listenReturns.result1
}

func (fake *FakeSyscall) ListenCallCount() int {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	return len(fake.listenArgsForCall)
}

func (fake *FakeSyscall) ListenArgsForCall(i int) (int, int) {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	return fake.listenArgsForCall[i].fd, fake.listenArgsForCall[i].backlog
}

func (fake *FakeSyscall) ListenReturns(result1 error) {
	fake.ListenStub = nil
	fake.listenReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ListenReturnsOnCall(i int, result1 error) {
	fake.ListenStub = nil
	if fake.listenReturnsOnCall == nil {
		fake.listenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Accept(fd int) (newfd int, sa syscall.Sockaddr, err error) {
	fake.acceptMutex.Lock()
	ret, specificReturn := fake.acceptReturnsOnCall[len(fake.acceptArgsForCall)]
	fake.acceptArgsForCall = append(fake.acceptArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("Accept", []interface{}{fd})
	fake.acceptMutex.Unlock()
	if fake.AcceptStub != nil {
		return fake.AcceptStub(fd)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acceptReturns.result1, fake.acceptReturns.result2, fake.acceptReturns.result3
}

func (fake *FakeSyscall) AcceptCallCount() int {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	return len(fake.acceptArgsForCall)
}

func (fake *FakeSyscall) AcceptArgsForCall(i int) int {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	return fake.acceptArgsForCall[i].fd
}

func (fake *FakeSyscall) AcceptReturns(result1 int, result2 syscall.Sockaddr, result3 error) {
	fake.AcceptStub = nil
	fake.acceptReturns = struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSyscall) AcceptReturnsOnCall(i int, result1 int, result2 syscall.Sockaddr, result3 error) {
	fake.AcceptStub = nil
	if fake.acceptReturnsOnCall == nil {
		fake.acceptReturnsOnCall = make(map[int]struct {
			result1 int
			result2 syscall.Sockaddr
			result3 error
		})
	}
	fake.acceptReturnsOnCall[i] = struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Getsockname(fd int) (sa syscall.Sockaddr, err error) {
	fake.getsocknameMutex.Lock()
	ret, specificReturn := fake.getsocknameReturnsOnCall[len(fake.getsocknameArgsForCall)]
	fake.getsocknameArgsForCall = append(fake.getsocknameArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("Getsockname", []interface{}{fd})
	fake.getsocknameMutex.Unlock()
	if fake.GetsocknameStub != nil {
		return fake.GetsocknameStub(fd)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getsocknameReturns.result1, fake.getsocknameReturns.result2
}

func (fake *FakeSyscall) GetsocknameCallCount() int {
	fake.getsocknameMutex.RLock()
	defer fake.getsocknameMutex.RUnlock()
	return len(fake.getsocknameArgsForCall)
}

func (fake *FakeSyscall) GetsocknameArgsForCall(i int) int {
	fake.getsocknameMutex.RLock()
	defer fake.getsocknameMutex.RUnlock()
	return fake.getsocknameArgsForCall[i].fd
}

func (fake *FakeSyscall) GetsocknameReturns(result1 syscall.Sockaddr, result2 error) {
	fake.GetsocknameStub = nil
	fake.getsocknameReturns = struct {
		result1 syscall.Sockaddr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsocknameReturnsOnCall(i int, result1 syscall.Sockaddr, result2 error) {
	fake.GetsocknameStub = nil
	if fake.getsocknameReturnsOnCall == nil {
		fake.getsocknameReturnsOnCall = make(map[int]struct {
			result1 syscall.Sockaddr
			result2 error
		})
	}
	fake.getsocknameReturnsOnCall[i] = struct {
		result1 syscall.Sockaddr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Getpeername(fd int) (sa syscall.Sockaddr, err error) {
	fake.getpeernameMutex.Lock()
	ret, specificReturn := fake.getpeernameReturnsOnCall[len(fake.getpeernameArgsForCall)]
	fake.getpeernameArgsForCall = append(fake.getpeernameArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("Getpeername", []interface{}{fd})
	fake.getpeernameMutex.Unlock()
	if fake.GetpeernameStub != nil {
		return fake.GetpeernameStub(fd)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getpeernameReturns.result1, fake.getpeernameReturns.result2
}

func (fake *FakeSyscall) GetpeernameCallCount() int {
	fake.getpeernameMutex.RLock()
	defer fake.getpeernameMutex.RUnlock()
	return len(fake.getpeernameArgsForCall)
}

func (fake *FakeSyscall) GetpeernameArgsForCall(i int) int {
	fake.getpeernameMutex.RLock()
	defer fake.getpeernameMutex.RUnlock()
	return fake.getpeernameArgsForCall[i].fd
}

func (fake *FakeSyscall) GetpeernameReturns(result1 syscall.Sockaddr, result2 error) {
	fake.GetpeernameStub = nil
	fake.getpeernameReturns = struct {
		result1 syscall.Sockaddr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetpeernameReturnsOnCall(i int, result1 syscall.Sockaddr, result2 error) {
	fake.GetpeernameStub = nil
	if fake.getpeernameReturnsOnCall == nil {
		fake.getpeernameReturnsOnCall = make(map[int]struct {
			result1 syscall.Sockaddr
			result2 error
		})
	}
	fake.getpeernameReturnsOnCall[i] = struct {
		result1 syscall.Sockaddr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Connect(fd int, sa syscall.Sockaddr) error {
	fake.connectMutex.Lock()
	ret, specificReturn := fake.connectReturnsOnCall[len(fake.connectArgsForCall)]
	fake.connectArgsForCall = append(fake.connectArgsForCall, struct {
		fd int
		sa syscall.Sockaddr
	}{fd, sa})
	fake.recordInvocation("Connect", []interface{}{fd, sa})
	fake.connectMutex.Unlock()
	if fake.ConnectStub != nil {
		return fake.ConnectStub(fd, sa)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.connectReturns.result1
}

func (fake *FakeSyscall) ConnectCallCount() int {
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	return len(fake.connectArgsForCall)
}

func (fake *FakeSyscall) ConnectArgsForCall(i int) (int, syscall.Sockaddr) {
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	return fake.connectArgsForCall[i].fd, fake.connectArgsForCall[i].sa
}

func (fake *FakeSyscall) ConnectReturns(result1 error) {
	fake.ConnectStub = nil
	fake.connectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ConnectReturnsOnCall(i int, result1 error) {
	fake.ConnectStub = nil
	if fake.connectReturnsOnCall == nil {
		fake.connectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.connectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Recvfrom(fd int, p []byte, flags int) (n int, from syscall.Sockaddr, err error) {
	var pCopy []byte
	if p != nil {
		pCopy = make([]byte, len(p))
		copy(pCopy, p)
	}
	fake.recvfromMutex.Lock()
	ret, specificReturn := fake.recvfromReturnsOnCall[len(fake.recvfromArgsForCall)]
	fake.recvfromArgsForCall = append(fake.recvfromArgsForCall, struct {
		fd    int
		p     []byte
		flags int
	}{fd, pCopy, flags})
	fake.recordInvocation("Recvfrom", []interface{}{fd, pCopy, flags})
	fake.recvfromMutex.Unlock()
	if fake.RecvfromStub != nil {
		return fake.RecvfromStub(fd, p, flags)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.recvfromReturns.result1, fake.recvfromReturns.result2, fake.recvfromReturns.result3
}

func (fake *FakeSyscall) RecvfromCallCount() int {
	fake.recvfromMutex.RLock()
	defer fake.recvfromMutex.RUnlock()
	return len(fake.recvfromArgsForCall)
}

func (fake *FakeSyscall) RecvfromArgsForCall(i int) (int, []byte, int) {
	fake.recvfromMutex.RLock()
	defer fake.recvfromMutex.RUnlock()
	return fake.recvfromArgsForCall[i].fd, fake.recvfromArgsForCall[i].p, fake.recvfromArgsForCall[i].flags
}

func (fake *FakeSyscall) RecvfromReturns(result1 int, result2 syscall.Sockaddr, result3 error) {
	fake.RecvfromStub = nil
	fake.recvfromReturns = struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSyscall) RecvfromReturnsOnCall(i int, result1 int, result2 syscall.Sockaddr, result3 error) {
	fake.RecvfromStub = nil
	if fake.recvfromReturnsOnCall == nil {
		fake.recvfromReturnsOnCall = make(map[int]struct {
			result1 int
			result2 syscall.Sockaddr
			result3 error
		})
	}
	fake.recvfromReturnsOnCall[i] = struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Sendto(fd int, p []byte, flags int, to syscall.Sockaddr) error {
	var pCopy []byte
	if p != nil {
		pCopy = make([]byte, len(p))
		copy(pCopy, p)
	}
	fake.sendtoMutex.Lock()
	ret, specificReturn := fake.sendtoReturnsOnCall[len(fake.sendtoArgsForCall)]
	fake.sendtoArgsForCall = append(fake.sendtoArgsForCall, struct {
		fd    int
		p     []byte
		flags int
		to    syscall.Sockaddr
	}{fd, pCopy, flags, to})
	fake.recordInvocation("Sendto", []interface{}{fd, pCopy, flags, to})
	fake.sendtoMutex.Unlock()
	if fake.SendtoStub != nil {
		return fake.SendtoStub(fd, p, flags, to)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sendtoReturns.result1
}

func (fake *FakeSyscall) SendtoCallCount() int {
	fake.sendtoMutex.RLock()
	defer fake.sendtoMutex.RUnlock()
	return len(fake.sendtoArgsForCall)
}

func (fake *FakeSyscall) SendtoArgsForCall(i int) (int, []byte, int, syscall.Sockaddr) {
	fake.sendtoMutex.RLock()
	defer fake.sendtoMutex.RUnlock()
	return fake.sendtoArgsForCall[i].fd, fake.sendtoArgsForCall[i].p, fake.sendtoArgsForCall[i].flags, fake.sendtoArgsForCall[i].to
}

func (fake *FakeSyscall) SendtoReturns(result1 error) {
	fake.SendtoStub = nil
	fake.sendtoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SendtoReturnsOnCall(i int, result1 error) {
	fake.SendtoStub = nil
	if fake.sendtoReturnsOnCall == nil {
		fake.sendtoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendtoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Recvmsg(fd int, p []byte, oob []byte, flags int) (n, oobn, recvflags int, from syscall.Sockaddr, err error) {
	var pCopy []byte
	if p != nil {
		pCopy = make([]byte, len(p))
		copy(pCopy, p)
	}
	var oobCopy []byte
	if oob != nil {
		oobCopy = make([]byte, len(oob))
		copy(oobCopy, oob)
	}
	fake.recvmsgMutex.Lock()
	ret, specificReturn := fake.recvmsgReturnsOnCall[len(fake.recvmsgArgsForCall)]
	fake.recvmsgArgsForCall = append(fake.recvmsgArgsForCall, struct {
		fd    int
		p     []byte
		oob   []byte
		flags int
	}{fd, pCopy, oobCopy, flags})
	fake.recordInvocation("Recvmsg", []interface{}{fd, pCopy, oobCopy, flags})
	fake.recvmsgMutex.Unlock()
	if fake.RecvmsgStub != nil {
		return fake.RecvmsgStub(fd, p, oob, flags)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4, ret.result5
	}
	return fake.recvmsgReturns.result1, fake.recvmsgReturns.result2, fake.recvmsgReturns.result3, fake.recvmsgReturns.result4, fake.recvmsgReturns.result5
}

func (fake *FakeSyscall) RecvmsgCallCount() int {
	fake.recvmsgMutex.RLock()
	defer fake.recvmsgMutex.RUnlock()
	return len(fake.recvmsgArgsForCall)
}

func (fake *FakeSyscall) RecvmsgArgsForCall(i int) (int, []byte, []byte, int) {
	fake.recvmsgMutex.RLock()
	defer fake.recvmsgMutex.RUnlock()
	return fake.recvmsgArgsForCall[i].fd, fake.recvmsgArgsForCall[i].p, fake.recvmsgArgsForCall[i].oob, fake.recvmsgArgsForCall[i].flags
}

func (fake *FakeSyscall) RecvmsgReturns(result1 int, result2 int, result3 int, result4 syscall.Sockaddr, result5 error) {
	fake.RecvmsgStub = nil
	fake.recvmsgReturns = struct {
		result1 int
		result2 int
		result3 int
		result4 syscall.Sockaddr
		result5 error
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeSyscall) RecvmsgReturnsOnCall(i int, result1 int, result2 int, result3 int, result4 syscall.Sockaddr, result5 error) {
	fake.RecvmsgStub = nil
	if fake.recvmsgReturnsOnCall == nil {
		fake.recvmsgReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 int
			result4 syscall.Sockaddr
			result5 error
		})
	}
	fake.recvmsgReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 int
		result4 syscall.Sockaddr
		result5 error
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeSyscall) Sendmsg(fd int, p []byte, oob []byte, to syscall.Sockaddr, flags int) error {
	var pCopy []byte
	if p != nil {
		pCopy = make([]byte, len(p))
		copy(pCopy, p)
	}
	var oobCopy []byte
	if oob != nil {
		oobCopy = make([]byte, len(oob))
		copy(oobCopy, oob)
	}
	fake.sendmsgMutex.Lock()
	ret, specificReturn := fake.sendmsgReturnsOnCall[len(fake.sendmsgArgsForCall)]
	fake.sendmsgArgsForCall = append(fake.sendmsgArgsForCall, struct {
		fd    int
		p     []byte
		oob   []byte
		to    syscall.Sockaddr
		flags int
	}{fd, pCopy, oobCopy, to, flags})
	fake.recordInvocation("Sendmsg", []interface{}{fd, pCopy, oobCopy, to, flags})
	fake.sendmsgMutex.Unlock()
	if fake.SendmsgStub != nil {
		return fake.SendmsgStub(fd, p, oob, to, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sendmsgReturns.result1
}

func (fake *FakeSyscall) SendmsgCallCount() int {
	fake.sendmsgMutex.RLock()
	defer fake.sendmsgMutex.RUnlock()
	return len(fake.sendmsgArgsForCall)
}

func (fake *FakeSyscall) SendmsgArgsForCall(i int) (int, []byte, []byte, syscall.Sockaddr, int) {
	fake.sendmsgMutex.RLock()
	defer fake.sendmsgMutex.RUnlock()
	return fake.sendmsgArgsForCall[i].fd, fake.sendmsgArgsForCall[i].p, fake.sendmsgArgsForCall[i].oob, fake.sendmsgArgsForCall[i].to, fake.sendmsgArgsForCall[i].flags
}

func (fake *FakeSyscall) SendmsgReturns(result1 error) {
	fake.SendmsgStub = nil
	fake.sendmsgReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SendmsgReturnsOnCall(i int, result1 error) {
	fake.SendmsgStub = nil
	if fake.sendmsgReturnsOnCall == nil {
		fake.sendmsgReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendmsgReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SendmsgN(fd int, p []byte, oob []byte, to syscall.Sockaddr, flags int) (n int, err error) {
	var pCopy []byte
	if p != nil {
		pCopy = make([]byte, len(p))
		copy(pCopy, p)
	}
	var oobCopy []byte
	if oob != nil {
		oobCopy = make([]byte, len(oob))
		copy(oobCopy, oob)
	}
	fake.sendmsgNMutex.Lock()
	ret, specificReturn := fake.sendmsgNReturnsOnCall[len(fake.sendmsgNArgsForCall)]
	fake.sendmsgNArgsForCall = append(fake.sendmsgNArgsForCall, struct {
		fd    int
		p     []byte
		oob   []byte
		to    syscall.Sockaddr
		flags int
	}{fd, pCopy, oobCopy, to, flags})
	fake.recordInvocation("SendmsgN", []interface{}{fd, pCopy, oobCopy, to, flags})
	fake.sendmsgNMutex.Unlock()
	if fake.SendmsgNStub != nil {
		return fake.SendmsgNStub(fd, p, oob, to, flags)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.sendmsgNReturns.result1, fake.sendmsgNReturns.result2
}

func (fake *FakeSyscall) SendmsgNCallCount() int {
	fake.sendmsgNMutex.RLock()
	defer fake.sendmsgNMutex.RUnlock()
	return len(fake.sendmsgNArgsForCall)
}

func (fake *FakeSyscall) SendmsgNArgsForCall(i int) (int, []byte, []byte, syscall.Sockaddr, int) {
	fake.sendmsgNMutex.RLock()
	defer fake.sendmsgNMutex.RUnlock()
	return fake.sendmsgNArgsForCall[i].fd, fake.sendmsgNArgsForCall[i].p, fake.sendmsgNArgsForCall[i].oob, fake.sendmsgNArgsForCall[i].to, fake.sendmsgNArgsForCall[i].flags
}

func (fake *FakeSyscall) SendmsgNReturns(result1 int, result2 error) {
	fake.SendmsgNStub = nil
	fake.sendmsgNReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SendmsgNReturnsOnCall(i int, result1 int, result2 error) {
	fake.SendmsgNStub = nil
	if fake.sendmsgNReturnsOnCall == nil {
		fake.sendmsgNReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.sendmsgNReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptInt(fd int, level int, opt int) (value int, err error) {
	fake.getsockoptIntMutex.Lock()
	ret, specificReturn := fake.getsockoptIntReturnsOnCall[len(fake.getsockoptIntArgsForCall)]
	fake.getsockoptIntArgsForCall = append(fake.getsockoptIntArgsForCall, struct {
		fd    int
		level int
		opt   int
	}{fd, level, opt})
	fake.recordInvocation("GetsockoptInt", []interface{}{fd, level, opt})
	fake.getsockoptIntMutex.Unlock()
	if fake.GetsockoptIntStub != nil {
		return fake.GetsockoptIntStub(fd, level, opt)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getsockoptIntReturns.result1, fake.getsockoptIntReturns.result2
}

func (fake *FakeSyscall) GetsockoptIntCallCount() int {
	fake.getsockoptIntMutex.RLock()
	defer fake.getsockoptIntMutex.RUnlock()
	return len(fake.getsockoptIntArgsForCall)
}

func (fake *FakeSyscall) GetsockoptIntArgsForCall(i int) (int, int, int) {
	fake.getsockoptIntMutex.RLock()
	defer fake.getsockoptIntMutex.RUnlock()
	return fake.getsockoptIntArgsForCall[i].fd, fake.getsockoptIntArgsForCall[i].level, fake.getsockoptIntArgsForCall[i].opt
}

func (fake *FakeSyscall) GetsockoptIntReturns(result1 int, result2 error) {
	fake.GetsockoptIntStub = nil
	fake.getsockoptIntReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptIntReturnsOnCall(i int, result1 int, result2 error) {
	fake.GetsockoptIntStub = nil
	if fake.getsockoptIntReturnsOnCall == nil {
		fake.getsockoptIntReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getsockoptIntReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetsockoptInt(fd int, level int, opt int, value int) error {
	fake.setsockoptIntMutex.Lock()
	ret, specificReturn := fake.setsockoptIntReturnsOnCall[len(fake.setsockoptIntArgsForCall)]
	fake.setsockoptIntArgsForCall = append(fake.setsockoptIntArgsForCall, struct {
		fd    int
		level int
		opt   int
		value int
	}{fd, level, opt, value})
	fake.recordInvocation("SetsockoptInt", []interface{}{fd, level, opt, value})
	fake.setsockoptIntMutex.Unlock()
	if fake.SetsockoptIntStub != nil {
		return fake.SetsockoptIntStub(fd, level, opt, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setsockoptIntReturns.result1
}

func (fake *FakeSyscall) SetsockoptIntCallCount() int {
	fake.setsockoptIntMutex.RLock()
	defer fake.setsockoptIntMutex.RUnlock()
	return len(fake.setsockoptIntArgsForCall)
}

func (fake *FakeSyscall) SetsockoptIntArgsForCall(i int) (int, int, int, int) {
	fake.setsockoptIntMutex.RLock()
	defer fake.setsockoptIntMutex.RUnlock()
	return fake.setsockoptIntArgsForCall[i].fd, fake.setsockoptIntArgsForCall[i].level, fake.setsockoptIntArgsForCall[i].opt, fake.setsockoptIntArgsForCall[i].value
}

func (fake *FakeSyscall) SetsockoptIntReturns(result1 error) {
	fake.SetsockoptIntStub = nil
	fake.setsockoptIntReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptIntReturnsOnCall(i int, result1 error) {
	fake.SetsockoptIntStub = nil
	if fake.setsockoptIntReturnsOnCall == nil {
		fake.setsockoptIntReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setsockoptIntReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptByte(fd int, level int, opt int, value byte) error {
	fake.setsockoptByteMutex.Lock()
	ret, specificReturn := fake.setsockoptByteReturnsOnCall[len(fake.setsockoptByteArgsForCall)]
	fake.setsockoptByteArgsForCall = append(fake.setsockoptByteArgsForCall, struct {
		fd    int
		level int
		opt   int
		value byte
	}{fd, level, opt, value})
	fake.recordInvocation("SetsockoptByte", []interface{}{fd, level, opt, value})
	fake.setsockoptByteMutex.Unlock()
	if fake.SetsockoptByteStub != nil {
		return fake.SetsockoptByteStub(fd, level, opt, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setsockoptByteReturns.result1
}

func (fake *FakeSyscall) SetsockoptByteCallCount() int {
	fake.setsockoptByteMutex.RLock()
	defer fake.setsockoptByteMutex.RUnlock()
	return len(fake.setsockoptByteArgsForCall)
}

func (fake *FakeSyscall) SetsockoptByteArgsForCall(i int) (int, int, int, byte) {
	fake.setsockoptByteMutex.RLock()
	defer fake.setsockoptByteMutex.RUnlock()
	return fake.setsockoptByteArgsForCall[i].fd, fake.setsockoptByteArgsForCall[i].level, fake.setsockoptByteArgsForCall[i].opt, fake.setsockoptByteArgsForCall[i].value
}

func (fake *FakeSyscall) SetsockoptByteReturns(result1 error) {
	fake.SetsockoptByteStub = nil
	fake.setsockoptByteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptByteReturnsOnCall(i int, result1 error) {
	fake.SetsockoptByteStub = nil
	if fake.setsockoptByteReturnsOnCall == nil {
		fake.setsockoptByteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setsockoptByteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptLinger(fd int, level int, opt int, l *syscall.Linger) error {
	fake.setsockoptLingerMutex.Lock()
	ret, specificReturn := fake.setsockoptLingerReturnsOnCall[len(fake.setsockoptLingerArgsForCall)]
	fake.setsockoptLingerArgsForCall = append(fake.setsockoptLingerArgsForCall, struct {
		fd    int
		level int
		opt   int
		l     *syscall.Linger
	}{fd, level, opt, l})
	fake.recordInvocation("SetsockoptLinger", []interface{}{fd, level, opt, l})
	fake.setsockoptLingerMutex.Unlock()
	if fake.SetsockoptLingerStub != nil {
		return fake.SetsockoptLingerStub(fd, level, opt, l)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setsockoptLingerReturns.result1
}

func (fake *FakeSyscall) SetsockoptLingerCallCount() int {
	fake.setsockoptLingerMutex.RLock()
	defer fake.setsockoptLingerMutex.RUnlock()
	return len(fake.setsockoptLingerArgsForCall)
}

func (fake *FakeSyscall) SetsockoptLingerArgsForCall(i int) (int, int, int, *syscall.Linger) {
	fake.setsockoptLingerMutex.RLock()
	defer fake.setsockoptLingerMutex.RUnlock()
	return fake.setsockoptLingerArgsForCall[i].fd, fake.setsockoptLingerArgsForCall[i].level, fake.setsockoptLingerArgsForCall[i].opt, fake.setsockoptLingerArgsForCall[i].l
}

func (fake *FakeSyscall) SetsockoptLingerReturns(result1 error) {
	fake.SetsockoptLingerStub = nil
	fake.setsockoptLingerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptLingerReturnsOnCall(i int, result1 error) {
	fake.SetsockoptLingerStub = nil
	if fake.setsockoptLingerReturnsOnCall == nil {
		fake.setsockoptLingerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setsockoptLingerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetReadDeadline(fd int, t int64) error {
	fake.setReadDeadlineMutex.Lock()
	ret, specificReturn := fake.setReadDeadlineReturnsOnCall[len(fake.setReadDeadlineArgsForCall)]
	fake.setReadDeadlineArgsForCall = append(fake.setReadDeadlineArgsForCall, struct {
		fd int
		t  int64
	}{fd, t})
	fake.recordInvocation("SetReadDeadline", []interface{}{fd, t})
	fake.setReadDeadlineMutex.Unlock()
	if fake.SetReadDeadlineStub != nil {
		return fake.SetReadDeadlineStub(fd, t)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setReadDeadlineReturns.result1
}

func (fake *FakeSyscall) SetReadDeadlineCallCount() int {
	fake.setReadDeadlineMutex.RLock()
	defer fake.setReadDeadlineMutex.RUnlock()
	return len(fake.setReadDeadlineArgsForCall)
}

func (fake *FakeSyscall) SetReadDeadlineArgsForCall(i int) (int, int64) {
	fake.setReadDeadlineMutex.RLock()
	defer fake.setReadDeadlineMutex.RUnlock()
	return fake.setReadDeadlineArgsForCall[i].fd, fake.setReadDeadlineArgsForCall[i].t
}

func (fake *FakeSyscall) SetReadDeadlineReturns(result1 error) {
	fake.SetReadDeadlineStub = nil
	fake.setReadDeadlineReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetReadDeadlineReturnsOnCall(i int, result1 error) {
	fake.SetReadDeadlineStub = nil
	if fake.setReadDeadlineReturnsOnCall == nil {
		fake.setReadDeadlineReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setReadDeadlineReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetWriteDeadline(fd int, t int64) error {
	fake.setWriteDeadlineMutex.Lock()
	ret, specificReturn := fake.setWriteDeadlineReturnsOnCall[len(fake.setWriteDeadlineArgsForCall)]
	fake.setWriteDeadlineArgsForCall = append(fake.setWriteDeadlineArgsForCall, struct {
		fd int
		t  int64
	}{fd, t})
	fake.recordInvocation("SetWriteDeadline", []interface{}{fd, t})
	fake.setWriteDeadlineMutex.Unlock()
	if fake.SetWriteDeadlineStub != nil {
		return fake.SetWriteDeadlineStub(fd, t)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setWriteDeadlineReturns.result1
}

func (fake *FakeSyscall) SetWriteDeadlineCallCount() int {
	fake.setWriteDeadlineMutex.RLock()
	defer fake.setWriteDeadlineMutex.RUnlock()
	return len(fake.setWriteDeadlineArgsForCall)
}

func (fake *FakeSyscall) SetWriteDeadlineArgsForCall(i int) (int, int64) {
	fake.setWriteDeadlineMutex.RLock()
	defer fake.setWriteDeadlineMutex.RUnlock()
	return fake.setWriteDeadlineArgsForCall[i].fd, fake.setWriteDeadlineArgsForCall[i].t
}

func (fake *FakeSyscall) SetWriteDeadlineReturns(result1 error) {
	fake.SetWriteDeadlineStub = nil
	fake.setWriteDeadlineReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetWriteDeadlineReturnsOnCall(i int, result1 error) {
	fake.SetWriteDeadlineStub = nil
	if fake.setWriteDeadlineReturnsOnCall == nil {
		fake.setWriteDeadlineReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setWriteDeadlineReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Shutdown(fd int, how int) error {
	fake.shutdownMutex.Lock()
	ret, specificReturn := fake.shutdownReturnsOnCall[len(fake.shutdownArgsForCall)]
	fake.shutdownArgsForCall = append(fake.shutdownArgsForCall, struct {
		fd  int
		how int
	}{fd, how})
	fake.recordInvocation("Shutdown", []interface{}{fd, how})
	fake.shutdownMutex.Unlock()
	if fake.ShutdownStub != nil {
		return fake.ShutdownStub(fd, how)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.shutdownReturns.result1
}

func (fake *FakeSyscall) ShutdownCallCount() int {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return len(fake.shutdownArgsForCall)
}

func (fake *FakeSyscall) ShutdownArgsForCall(i int) (int, int) {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return fake.shutdownArgsForCall[i].fd, fake.shutdownArgsForCall[i].how
}

func (fake *FakeSyscall) ShutdownReturns(result1 error) {
	fake.ShutdownStub = nil
	fake.shutdownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ShutdownReturnsOnCall(i int, result1 error) {
	fake.ShutdownStub = nil
	if fake.shutdownReturnsOnCall == nil {
		fake.shutdownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.shutdownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptICMPv6Filter(fd int, level int, opt int, filter *syscall.ICMPv6Filter) error {
	fake.setsockoptICMPv6FilterMutex.Lock()
	ret, specificReturn := fake.setsockoptICMPv6FilterReturnsOnCall[len(fake.setsockoptICMPv6FilterArgsForCall)]
	fake.setsockoptICMPv6FilterArgsForCall = append(fake.setsockoptICMPv6FilterArgsForCall, struct {
		fd     int
		level  int
		opt    int
		filter *syscall.ICMPv6Filter
	}{fd, level, opt, filter})
	fake.recordInvocation("SetsockoptICMPv6Filter", []interface{}{fd, level, opt, filter})
	fake.setsockoptICMPv6FilterMutex.Unlock()
	if fake.SetsockoptICMPv6FilterStub != nil {
		return fake.SetsockoptICMPv6FilterStub(fd, level, opt, filter)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setsockoptICMPv6FilterReturns.result1
}

func (fake *FakeSyscall) SetsockoptICMPv6FilterCallCount() int {
	fake.setsockoptICMPv6FilterMutex.RLock()
	defer fake.setsockoptICMPv6FilterMutex.RUnlock()
	return len(fake.setsockoptICMPv6FilterArgsForCall)
}

func (fake *FakeSyscall) SetsockoptICMPv6FilterArgsForCall(i int) (int, int, int, *syscall.ICMPv6Filter) {
	fake.setsockoptICMPv6FilterMutex.RLock()
	defer fake.setsockoptICMPv6FilterMutex.RUnlock()
	return fake.setsockoptICMPv6FilterArgsForCall[i].fd, fake.setsockoptICMPv6FilterArgsForCall[i].level, fake.setsockoptICMPv6FilterArgsForCall[i].opt, fake.setsockoptICMPv6FilterArgsForCall[i].filter
}

func (fake *FakeSyscall) SetsockoptICMPv6FilterReturns(result1 error) {
	fake.SetsockoptICMPv6FilterStub = nil
	fake.setsockoptICMPv6FilterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptICMPv6FilterReturnsOnCall(i int, result1 error) {
	fake.SetsockoptICMPv6FilterStub = nil
	if fake.setsockoptICMPv6FilterReturnsOnCall == nil {
		fake.setsockoptICMPv6FilterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setsockoptICMPv6FilterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptIPMreq(fd int, level int, opt int, mreq *syscall.IPMreq) error {
	fake.setsockoptIPMreqMutex.Lock()
	ret, specificReturn := fake.setsockoptIPMreqReturnsOnCall[len(fake.setsockoptIPMreqArgsForCall)]
	fake.setsockoptIPMreqArgsForCall = append(fake.setsockoptIPMreqArgsForCall, struct {
		fd    int
		level int
		opt   int
		mreq  *syscall.IPMreq
	}{fd, level, opt, mreq})
	fake.recordInvocation("SetsockoptIPMreq", []interface{}{fd, level, opt, mreq})
	fake.setsockoptIPMreqMutex.Unlock()
	if fake.SetsockoptIPMreqStub != nil {
		return fake.SetsockoptIPMreqStub(fd, level, opt, mreq)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setsockoptIPMreqReturns.result1
}

func (fake *FakeSyscall) SetsockoptIPMreqCallCount() int {
	fake.setsockoptIPMreqMutex.RLock()
	defer fake.setsockoptIPMreqMutex.RUnlock()
	return len(fake.setsockoptIPMreqArgsForCall)
}

func (fake *FakeSyscall) SetsockoptIPMreqArgsForCall(i int) (int, int, int, *syscall.IPMreq) {
	fake.setsockoptIPMreqMutex.RLock()
	defer fake.setsockoptIPMreqMutex.RUnlock()
	return fake.setsockoptIPMreqArgsForCall[i].fd, fake.setsockoptIPMreqArgsForCall[i].level, fake.setsockoptIPMreqArgsForCall[i].opt, fake.setsockoptIPMreqArgsForCall[i].mreq
}

func (fake *FakeSyscall) SetsockoptIPMreqReturns(result1 error) {
	fake.SetsockoptIPMreqStub = nil
	fake.setsockoptIPMreqReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptIPMreqReturnsOnCall(i int, result1 error) {
	fake.SetsockoptIPMreqStub = nil
	if fake.setsockoptIPMreqReturnsOnCall == nil {
		fake.setsockoptIPMreqReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setsockoptIPMreqReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptIPv6Mreq(fd int, level int, opt int, mreq *syscall.IPv6Mreq) error {
	fake.setsockoptIPv6MreqMutex.Lock()
	ret, specificReturn := fake.setsockoptIPv6MreqReturnsOnCall[len(fake.setsockoptIPv6MreqArgsForCall)]
	fake.setsockoptIPv6MreqArgsForCall = append(fake.setsockoptIPv6MreqArgsForCall, struct {
		fd    int
		level int
		opt   int
		mreq  *syscall.IPv6Mreq
	}{fd, level, opt, mreq})
	fake.recordInvocation("SetsockoptIPv6Mreq", []interface{}{fd, level, opt, mreq})
	fake.setsockoptIPv6MreqMutex.Unlock()
	if fake.SetsockoptIPv6MreqStub != nil {
		return fake.SetsockoptIPv6MreqStub(fd, level, opt, mreq)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setsockoptIPv6MreqReturns.result1
}

func (fake *FakeSyscall) SetsockoptIPv6MreqCallCount() int {
	fake.setsockoptIPv6MreqMutex.RLock()
	defer fake.setsockoptIPv6MreqMutex.RUnlock()
	return len(fake.setsockoptIPv6MreqArgsForCall)
}

func (fake *FakeSyscall) SetsockoptIPv6MreqArgsForCall(i int) (int, int, int, *syscall.IPv6Mreq) {
	fake.setsockoptIPv6MreqMutex.RLock()
	defer fake.setsockoptIPv6MreqMutex.RUnlock()
	return fake.setsockoptIPv6MreqArgsForCall[i].fd, fake.setsockoptIPv6MreqArgsForCall[i].level, fake.setsockoptIPv6MreqArgsForCall[i].opt, fake.setsockoptIPv6MreqArgsForCall[i].mreq
}

func (fake *FakeSyscall) SetsockoptIPv6MreqReturns(result1 error) {
	fake.SetsockoptIPv6MreqStub = nil
	fake.setsockoptIPv6MreqReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptIPv6MreqReturnsOnCall(i int, result1 error) {
	fake.SetsockoptIPv6MreqStub = nil
	if fake.setsockoptIPv6MreqReturnsOnCall == nil {
		fake.setsockoptIPv6MreqReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setsockoptIPv6MreqReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptInet4Addr(fd int, level int, opt int, value [4]byte) error {
	fake.setsockoptInet4AddrMutex.Lock()
	ret, specificReturn := fake.setsockoptInet4AddrReturnsOnCall[len(fake.setsockoptInet4AddrArgsForCall)]
	fake.setsockoptInet4AddrArgsForCall = append(fake.setsockoptInet4AddrArgsForCall, struct {
		fd    int
		level int
		opt   int
		value [4]byte
	}{fd, level, opt, value})
	fake.recordInvocation("SetsockoptInet4Addr", []interface{}{fd, level, opt, value})
	fake.setsockoptInet4AddrMutex.Unlock()
	if fake.SetsockoptInet4AddrStub != nil {
		return fake.SetsockoptInet4AddrStub(fd, level, opt, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setsockoptInet4AddrReturns.result1
}

func (fake *FakeSyscall) SetsockoptInet4AddrCallCount() int {
	fake.setsockoptInet4AddrMutex.RLock()
	defer fake.setsockoptInet4AddrMutex.RUnlock()
	return len(fake.setsockoptInet4AddrArgsForCall)
}

func (fake *FakeSyscall) SetsockoptInet4AddrArgsForCall(i int) (int, int, int, [4]byte) {
	fake.setsockoptInet4AddrMutex.RLock()
	defer fake.setsockoptInet4AddrMutex.RUnlock()
	return fake.setsockoptInet4AddrArgsForCall[i].fd, fake.setsockoptInet4AddrArgsForCall[i].level, fake.setsockoptInet4AddrArgsForCall[i].opt, fake.setsockoptInet4AddrArgsForCall[i].value
}

func (fake *FakeSyscall) SetsockoptInet4AddrReturns(result1 error) {
	fake.SetsockoptInet4AddrStub = nil
	fake.setsockoptInet4AddrReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptInet4AddrReturnsOnCall(i int, result1 error) {
	fake.SetsockoptInet4AddrStub = nil
	if fake.setsockoptInet4AddrReturnsOnCall == nil {
		fake.setsockoptInet4AddrReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setsockoptInet4AddrReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptString(fd int, level int, opt int, s string) error {
	fake.setsockoptStringMutex.Lock()
	ret, specificReturn := fake.setsockoptStringReturnsOnCall[len(fake.setsockoptStringArgsForCall)]
	fake.setsockoptStringArgsForCall = append(fake.setsockoptStringArgsForCall, struct {
		fd    int
		level int
		opt   int
		s     string
	}{fd, level, opt, s})
	fake.recordInvocation("SetsockoptString", []interface{}{fd, level, opt, s})
	fake.setsockoptStringMutex.Unlock()
	if fake.SetsockoptStringStub != nil {
		return fake.SetsockoptStringStub(fd, level, opt, s)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setsockoptStringReturns.result1
}

func (fake *FakeSyscall) SetsockoptStringCallCount() int {
	fake.setsockoptStringMutex.RLock()
	defer fake.setsockoptStringMutex.RUnlock()
	return len(fake.setsockoptStringArgsForCall)
}

func (fake *FakeSyscall) SetsockoptStringArgsForCall(i int) (int, int, int, string) {
	fake.setsockoptStringMutex.RLock()
	defer fake.setsockoptStringMutex.RUnlock()
	return fake.setsockoptStringArgsForCall[i].fd, fake.setsockoptStringArgsForCall[i].level, fake.setsockoptStringArgsForCall[i].opt, fake.setsockoptStringArgsForCall[i].s
}

func (fake *FakeSyscall) SetsockoptStringReturns(result1 error) {
	fake.SetsockoptStringStub = nil
	fake.setsockoptStringReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptStringReturnsOnCall(i int, result1 error) {
	fake.SetsockoptStringStub = nil
	if fake.setsockoptStringReturnsOnCall == nil {
		fake.setsockoptStringReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setsockoptStringReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptTimeval(fd int, level int, opt int, tv *syscall.Timeval) error {
	fake.setsockoptTimevalMutex.Lock()
	ret, specificReturn := fake.setsockoptTimevalReturnsOnCall[len(fake.setsockoptTimevalArgsForCall)]
	fake.setsockoptTimevalArgsForCall = append(fake.setsockoptTimevalArgsForCall, struct {
		fd    int
		level int
		opt   int
		tv    *syscall.Timeval
	}{fd, level, opt, tv})
	fake.recordInvocation("SetsockoptTimeval", []interface{}{fd, level, opt, tv})
	fake.setsockoptTimevalMutex.Unlock()
	if fake.SetsockoptTimevalStub != nil {
		return fake.SetsockoptTimevalStub(fd, level, opt, tv)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setsockoptTimevalReturns.result1
}

func (fake *FakeSyscall) SetsockoptTimevalCallCount() int {
	fake.setsockoptTimevalMutex.RLock()
	defer fake.setsockoptTimevalMutex.RUnlock()
	return len(fake.setsockoptTimevalArgsForCall)
}

func (fake *FakeSyscall) SetsockoptTimevalArgsForCall(i int) (int, int, int, *syscall.Timeval) {
	fake.setsockoptTimevalMutex.RLock()
	defer fake.setsockoptTimevalMutex.RUnlock()
	return fake.setsockoptTimevalArgsForCall[i].fd, fake.setsockoptTimevalArgsForCall[i].level, fake.setsockoptTimevalArgsForCall[i].opt, fake.setsockoptTimevalArgsForCall[i].tv
}

func (fake *FakeSyscall) SetsockoptTimevalReturns(result1 error) {
	fake.SetsockoptTimevalStub = nil
	fake.setsockoptTimevalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptTimevalReturnsOnCall(i int, result1 error) {
	fake.SetsockoptTimevalStub = nil
	if fake.setsockoptTimevalReturnsOnCall == nil {
		fake.setsockoptTimevalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setsockoptTimevalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Socketpair(domain int, typ int, proto int) (fd [2]int, err error) {
	fake.socketpairMutex.Lock()
	ret, specificReturn := fake.socketpairReturnsOnCall[len(fake.socketpairArgsForCall)]
	fake.socketpairArgsForCall = append(fake.socketpairArgsForCall, struct {
		domain int
		typ    int
		proto  int
	}{domain, typ, proto})
	fake.recordInvocation("Socketpair", []interface{}{domain, typ, proto})
	fake.socketpairMutex.Unlock()
	if fake.SocketpairStub != nil {
		return fake.SocketpairStub(domain, typ, proto)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.socketpairReturns.result1, fake.socketpairReturns.result2
}

func (fake *FakeSyscall) SocketpairCallCount() int {
	fake.socketpairMutex.RLock()
	defer fake.socketpairMutex.RUnlock()
	return len(fake.socketpairArgsForCall)
}

func (fake *FakeSyscall) SocketpairArgsForCall(i int) (int, int, int) {
	fake.socketpairMutex.RLock()
	defer fake.socketpairMutex.RUnlock()
	return fake.socketpairArgsForCall[i].domain, fake.socketpairArgsForCall[i].typ, fake.socketpairArgsForCall[i].proto
}

func (fake *FakeSyscall) SocketpairReturns(result1 [2]int, result2 error) {
	fake.SocketpairStub = nil
	fake.socketpairReturns = struct {
		result1 [2]int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SocketpairReturnsOnCall(i int, result1 [2]int, result2 error) {
	fake.SocketpairStub = nil
	if fake.socketpairReturnsOnCall == nil {
		fake.socketpairReturnsOnCall = make(map[int]struct {
			result1 [2]int
			result2 error
		})
	}
	fake.socketpairReturnsOnCall[i] = struct {
		result1 [2]int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) NetlinkRIB(proto int, family int) ([]byte, error) {
	fake.netlinkRIBMutex.Lock()
	ret, specificReturn := fake.netlinkRIBReturnsOnCall[len(fake.netlinkRIBArgsForCall)]
	fake.netlinkRIBArgsForCall = append(fake.netlinkRIBArgsForCall, struct {
		proto  int
		family int
	}{proto, family})
	fake.recordInvocation("NetlinkRIB", []interface{}{proto, family})
	fake.netlinkRIBMutex.Unlock()
	if fake.NetlinkRIBStub != nil {
		return fake.NetlinkRIBStub(proto, family)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.netlinkRIBReturns.result1, fake.netlinkRIBReturns.result2
}

func (fake *FakeSyscall) NetlinkRIBCallCount() int {
	fake.netlinkRIBMutex.RLock()
	defer fake.netlinkRIBMutex.RUnlock()
	return len(fake.netlinkRIBArgsForCall)
}

func (fake *FakeSyscall) NetlinkRIBArgsForCall(i int) (int, int) {
	fake.netlinkRIBMutex.RLock()
	defer fake.netlinkRIBMutex.RUnlock()
	return fake.netlinkRIBArgsForCall[i].proto, fake.netlinkRIBArgsForCall[i].family
}

func (fake *FakeSyscall) NetlinkRIBReturns(result1 []byte, result2 error) {
	fake.NetlinkRIBStub = nil
	fake.netlinkRIBReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) NetlinkRIBReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.NetlinkRIBStub = nil
	if fake.netlinkRIBReturnsOnCall == nil {
		fake.netlinkRIBReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.netlinkRIBReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseNetlinkMessage(b []byte) ([]syscall.NetlinkMessage, error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.parseNetlinkMessageMutex.Lock()
	ret, specificReturn := fake.parseNetlinkMessageReturnsOnCall[len(fake.parseNetlinkMessageArgsForCall)]
	fake.parseNetlinkMessageArgsForCall = append(fake.parseNetlinkMessageArgsForCall, struct {
		b []byte
	}{bCopy})
	fake.recordInvocation("ParseNetlinkMessage", []interface{}{bCopy})
	fake.parseNetlinkMessageMutex.Unlock()
	if fake.ParseNetlinkMessageStub != nil {
		return fake.ParseNetlinkMessageStub(b)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseNetlinkMessageReturns.result1, fake.parseNetlinkMessageReturns.result2
}

func (fake *FakeSyscall) ParseNetlinkMessageCallCount() int {
	fake.parseNetlinkMessageMutex.RLock()
	defer fake.parseNetlinkMessageMutex.RUnlock()
	return len(fake.parseNetlinkMessageArgsForCall)
}

func (fake *FakeSyscall) ParseNetlinkMessageArgsForCall(i int) []byte {
	fake.parseNetlinkMessageMutex.RLock()
	defer fake.parseNetlinkMessageMutex.RUnlock()
	return fake.parseNetlinkMessageArgsForCall[i].b
}

func (fake *FakeSyscall) ParseNetlinkMessageReturns(result1 []syscall.NetlinkMessage, result2 error) {
	fake.ParseNetlinkMessageStub = nil
	fake.parseNetlinkMessageReturns = struct {
		result1 []syscall.NetlinkMessage
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseNetlinkMessageReturnsOnCall(i int, result1 []syscall.NetlinkMessage, result2 error) {
	fake.ParseNetlinkMessageStub = nil
	if fake.parseNetlinkMessageReturnsOnCall == nil {
		fake.parseNetlinkMessageReturnsOnCall = make(map[int]struct {
			result1 []syscall.NetlinkMessage
			result2 error
		})
	}
	fake.parseNetlinkMessageReturnsOnCall[i] = struct {
		result1 []syscall.NetlinkMessage
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseNetlinkRouteAttr(m *syscall.NetlinkMessage) ([]syscall.NetlinkRouteAttr, error) {
	fake.parseNetlinkRouteAttrMutex.Lock()
	ret, specificReturn := fake.parseNetlinkRouteAttrReturnsOnCall[len(fake.parseNetlinkRouteAttrArgsForCall)]
	fake.parseNetlinkRouteAttrArgsForCall = append(fake.parseNetlinkRouteAttrArgsForCall, struct {
		m *syscall.NetlinkMessage
	}{m})
	fake.recordInvocation("ParseNetlinkRouteAttr", []interface{}{m})
	fake.parseNetlinkRouteAttrMutex.Unlock()
	if fake.ParseNetlinkRouteAttrStub != nil {
		return fake.ParseNetlinkRouteAttrStub(m)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseNetlinkRouteAttrReturns.result1, fake.parseNetlinkRouteAttrReturns.result2
}

func (fake *FakeSyscall) ParseNetlinkRouteAttrCallCount() int {
	fake.parseNetlinkRouteAttrMutex.RLock()
	defer fake.parseNetlinkRouteAttrMutex.RUnlock()
	return len(fake.parseNetlinkRouteAttrArgsForCall)
}

func (fake *FakeSyscall) ParseNetlinkRouteAttrArgsForCall(i int) *syscall.NetlinkMessage {
	fake.parseNetlinkRouteAttrMutex.RLock()
	defer fake.parseNetlinkRouteAttrMutex.RUnlock()
	return fake.parseNetlinkRouteAttrArgsForCall[i].m
}

func (fake *FakeSyscall) ParseNetlinkRouteAttrReturns(result1 []syscall.NetlinkRouteAttr, result2 error) {
	fake.ParseNetlinkRouteAttrStub = nil
	fake.parseNetlinkRouteAttrReturns = struct {
		result1 []syscall.NetlinkRouteAttr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseNetlinkRouteAttrReturnsOnCall(i int, result1 []syscall.NetlinkRouteAttr, result2 error) {
	fake.ParseNetlinkRouteAttrStub = nil
	if fake.parseNetlinkRouteAttrReturnsOnCall == nil {
		fake.parseNetlinkRouteAttrReturnsOnCall = make(map[int]struct {
			result1 []syscall.NetlinkRouteAttr
			result2 error
		})
	}
	fake.parseNetlinkRouteAttrReturnsOnCall[i] = struct {
		result1 []syscall.NetlinkRouteAttr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Fixwd() {
	fake.fixwdMutex.Lock()
	fake.fixwdArgsForCall = append(fake.fixwdArgsForCall, struct{}{})
	fake.recordInvocation("Fixwd", []interface{}{})
	fake.fixwdMutex.Unlock()
	if fake.FixwdStub != nil {
		fake.FixwdStub()
	}
}

func (fake *FakeSyscall) FixwdCallCount() int {
	fake.fixwdMutex.RLock()
	defer fake.fixwdMutex.RUnlock()
	return len(fake.fixwdArgsForCall)
}

func (fake *FakeSyscall) Getwd() (wd string, err error) {
	fake.getwdMutex.Lock()
	ret, specificReturn := fake.getwdReturnsOnCall[len(fake.getwdArgsForCall)]
	fake.getwdArgsForCall = append(fake.getwdArgsForCall, struct{}{})
	fake.recordInvocation("Getwd", []interface{}{})
	fake.getwdMutex.Unlock()
	if fake.GetwdStub != nil {
		return fake.GetwdStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getwdReturns.result1, fake.getwdReturns.result2
}

func (fake *FakeSyscall) GetwdCallCount() int {
	fake.getwdMutex.RLock()
	defer fake.getwdMutex.RUnlock()
	return len(fake.getwdArgsForCall)
}

func (fake *FakeSyscall) GetwdReturns(result1 string, result2 error) {
	fake.GetwdStub = nil
	fake.getwdReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetwdReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetwdStub = nil
	if fake.getwdReturnsOnCall == nil {
		fake.getwdReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getwdReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) RouteRIB(facility int, param int) ([]byte, error) {
	fake.routeRIBMutex.Lock()
	ret, specificReturn := fake.routeRIBReturnsOnCall[len(fake.routeRIBArgsForCall)]
	fake.routeRIBArgsForCall = append(fake.routeRIBArgsForCall, struct {
		facility int
		param    int
	}{facility, param})
	fake.recordInvocation("RouteRIB", []interface{}{facility, param})
	fake.routeRIBMutex.Unlock()
	if fake.RouteRIBStub != nil {
		return fake.RouteRIBStub(facility, param)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.routeRIBReturns.result1, fake.routeRIBReturns.result2
}

func (fake *FakeSyscall) RouteRIBCallCount() int {
	fake.routeRIBMutex.RLock()
	defer fake.routeRIBMutex.RUnlock()
	return len(fake.routeRIBArgsForCall)
}

func (fake *FakeSyscall) RouteRIBArgsForCall(i int) (int, int) {
	fake.routeRIBMutex.RLock()
	defer fake.routeRIBMutex.RUnlock()
	return fake.routeRIBArgsForCall[i].facility, fake.routeRIBArgsForCall[i].param
}

func (fake *FakeSyscall) RouteRIBReturns(result1 []byte, result2 error) {
	fake.RouteRIBStub = nil
	fake.routeRIBReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) RouteRIBReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.RouteRIBStub = nil
	if fake.routeRIBReturnsOnCall == nil {
		fake.routeRIBReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.routeRIBReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseRoutingMessage(b []byte) (msgs []syscall.RoutingMessage, err error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.parseRoutingMessageMutex.Lock()
	ret, specificReturn := fake.parseRoutingMessageReturnsOnCall[len(fake.parseRoutingMessageArgsForCall)]
	fake.parseRoutingMessageArgsForCall = append(fake.parseRoutingMessageArgsForCall, struct {
		b []byte
	}{bCopy})
	fake.recordInvocation("ParseRoutingMessage", []interface{}{bCopy})
	fake.parseRoutingMessageMutex.Unlock()
	if fake.ParseRoutingMessageStub != nil {
		return fake.ParseRoutingMessageStub(b)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseRoutingMessageReturns.result1, fake.parseRoutingMessageReturns.result2
}

func (fake *FakeSyscall) ParseRoutingMessageCallCount() int {
	fake.parseRoutingMessageMutex.RLock()
	defer fake.parseRoutingMessageMutex.RUnlock()
	return len(fake.parseRoutingMessageArgsForCall)
}

func (fake *FakeSyscall) ParseRoutingMessageArgsForCall(i int) []byte {
	fake.parseRoutingMessageMutex.RLock()
	defer fake.parseRoutingMessageMutex.RUnlock()
	return fake.parseRoutingMessageArgsForCall[i].b
}

func (fake *FakeSyscall) ParseRoutingMessageReturns(result1 []syscall.RoutingMessage, result2 error) {
	fake.ParseRoutingMessageStub = nil
	fake.parseRoutingMessageReturns = struct {
		result1 []syscall.RoutingMessage
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseRoutingMessageReturnsOnCall(i int, result1 []syscall.RoutingMessage, result2 error) {
	fake.ParseRoutingMessageStub = nil
	if fake.parseRoutingMessageReturnsOnCall == nil {
		fake.parseRoutingMessageReturnsOnCall = make(map[int]struct {
			result1 []syscall.RoutingMessage
			result2 error
		})
	}
	fake.parseRoutingMessageReturnsOnCall[i] = struct {
		result1 []syscall.RoutingMessage
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseRoutingSockaddr(msg syscall.RoutingMessage) ([]syscall.Sockaddr, error) {
	fake.parseRoutingSockaddrMutex.Lock()
	ret, specificReturn := fake.parseRoutingSockaddrReturnsOnCall[len(fake.parseRoutingSockaddrArgsForCall)]
	fake.parseRoutingSockaddrArgsForCall = append(fake.parseRoutingSockaddrArgsForCall, struct {
		msg syscall.RoutingMessage
	}{msg})
	fake.recordInvocation("ParseRoutingSockaddr", []interface{}{msg})
	fake.parseRoutingSockaddrMutex.Unlock()
	if fake.ParseRoutingSockaddrStub != nil {
		return fake.ParseRoutingSockaddrStub(msg)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseRoutingSockaddrReturns.result1, fake.parseRoutingSockaddrReturns.result2
}

func (fake *FakeSyscall) ParseRoutingSockaddrCallCount() int {
	fake.parseRoutingSockaddrMutex.RLock()
	defer fake.parseRoutingSockaddrMutex.RUnlock()
	return len(fake.parseRoutingSockaddrArgsForCall)
}

func (fake *FakeSyscall) ParseRoutingSockaddrArgsForCall(i int) syscall.RoutingMessage {
	fake.parseRoutingSockaddrMutex.RLock()
	defer fake.parseRoutingSockaddrMutex.RUnlock()
	return fake.parseRoutingSockaddrArgsForCall[i].msg
}

func (fake *FakeSyscall) ParseRoutingSockaddrReturns(result1 []syscall.Sockaddr, result2 error) {
	fake.ParseRoutingSockaddrStub = nil
	fake.parseRoutingSockaddrReturns = struct {
		result1 []syscall.Sockaddr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseRoutingSockaddrReturnsOnCall(i int, result1 []syscall.Sockaddr, result2 error) {
	fake.ParseRoutingSockaddrStub = nil
	if fake.parseRoutingSockaddrReturnsOnCall == nil {
		fake.parseRoutingSockaddrReturnsOnCall = make(map[int]struct {
			result1 []syscall.Sockaddr
			result2 error
		})
	}
	fake.parseRoutingSockaddrReturnsOnCall[i] = struct {
		result1 []syscall.Sockaddr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) TranslateAccountName(username string, from uint32, to uint32, initSize int) (string, error) {
	fake.translateAccountNameMutex.Lock()
	ret, specificReturn := fake.translateAccountNameReturnsOnCall[len(fake.translateAccountNameArgsForCall)]
	fake.translateAccountNameArgsForCall = append(fake.translateAccountNameArgsForCall, struct {
		username string
		from     uint32
		to       uint32
		initSize int
	}{username, from, to, initSize})
	fake.recordInvocation("TranslateAccountName", []interface{}{username, from, to, initSize})
	fake.translateAccountNameMutex.Unlock()
	if fake.TranslateAccountNameStub != nil {
		return fake.TranslateAccountNameStub(username, from, to, initSize)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.translateAccountNameReturns.result1, fake.translateAccountNameReturns.result2
}

func (fake *FakeSyscall) TranslateAccountNameCallCount() int {
	fake.translateAccountNameMutex.RLock()
	defer fake.translateAccountNameMutex.RUnlock()
	return len(fake.translateAccountNameArgsForCall)
}

func (fake *FakeSyscall) TranslateAccountNameArgsForCall(i int) (string, uint32, uint32, int) {
	fake.translateAccountNameMutex.RLock()
	defer fake.translateAccountNameMutex.RUnlock()
	return fake.translateAccountNameArgsForCall[i].username, fake.translateAccountNameArgsForCall[i].from, fake.translateAccountNameArgsForCall[i].to, fake.translateAccountNameArgsForCall[i].initSize
}

func (fake *FakeSyscall) TranslateAccountNameReturns(result1 string, result2 error) {
	fake.TranslateAccountNameStub = nil
	fake.translateAccountNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) TranslateAccountNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.TranslateAccountNameStub = nil
	if fake.translateAccountNameReturnsOnCall == nil {
		fake.translateAccountNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.translateAccountNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) StringToSid(s string) (*syscall.SID, error) {
	fake.stringToSidMutex.Lock()
	ret, specificReturn := fake.stringToSidReturnsOnCall[len(fake.stringToSidArgsForCall)]
	fake.stringToSidArgsForCall = append(fake.stringToSidArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("StringToSid", []interface{}{s})
	fake.stringToSidMutex.Unlock()
	if fake.StringToSidStub != nil {
		return fake.StringToSidStub(s)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.stringToSidReturns.result1, fake.stringToSidReturns.result2
}

func (fake *FakeSyscall) StringToSidCallCount() int {
	fake.stringToSidMutex.RLock()
	defer fake.stringToSidMutex.RUnlock()
	return len(fake.stringToSidArgsForCall)
}

func (fake *FakeSyscall) StringToSidArgsForCall(i int) string {
	fake.stringToSidMutex.RLock()
	defer fake.stringToSidMutex.RUnlock()
	return fake.stringToSidArgsForCall[i].s
}

func (fake *FakeSyscall) StringToSidReturns(result1 *syscall.SID, result2 error) {
	fake.StringToSidStub = nil
	fake.stringToSidReturns = struct {
		result1 *syscall.SID
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) StringToSidReturnsOnCall(i int, result1 *syscall.SID, result2 error) {
	fake.StringToSidStub = nil
	if fake.stringToSidReturnsOnCall == nil {
		fake.stringToSidReturnsOnCall = make(map[int]struct {
			result1 *syscall.SID
			result2 error
		})
	}
	fake.stringToSidReturnsOnCall[i] = struct {
		result1 *syscall.SID
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) LookupSID(system string, account string) (sid *syscall.SID, domain string, accType uint32, err error) {
	fake.lookupSIDMutex.Lock()
	ret, specificReturn := fake.lookupSIDReturnsOnCall[len(fake.lookupSIDArgsForCall)]
	fake.lookupSIDArgsForCall = append(fake.lookupSIDArgsForCall, struct {
		system  string
		account string
	}{system, account})
	fake.recordInvocation("LookupSID", []interface{}{system, account})
	fake.lookupSIDMutex.Unlock()
	if fake.LookupSIDStub != nil {
		return fake.LookupSIDStub(system, account)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.lookupSIDReturns.result1, fake.lookupSIDReturns.result2, fake.lookupSIDReturns.result3, fake.lookupSIDReturns.result4
}

func (fake *FakeSyscall) LookupSIDCallCount() int {
	fake.lookupSIDMutex.RLock()
	defer fake.lookupSIDMutex.RUnlock()
	return len(fake.lookupSIDArgsForCall)
}

func (fake *FakeSyscall) LookupSIDArgsForCall(i int) (string, string) {
	fake.lookupSIDMutex.RLock()
	defer fake.lookupSIDMutex.RUnlock()
	return fake.lookupSIDArgsForCall[i].system, fake.lookupSIDArgsForCall[i].account
}

func (fake *FakeSyscall) LookupSIDReturns(result1 *syscall.SID, result2 string, result3 uint32, result4 error) {
	fake.LookupSIDStub = nil
	fake.lookupSIDReturns = struct {
		result1 *syscall.SID
		result2 string
		result3 uint32
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeSyscall) LookupSIDReturnsOnCall(i int, result1 *syscall.SID, result2 string, result3 uint32, result4 error) {
	fake.LookupSIDStub = nil
	if fake.lookupSIDReturnsOnCall == nil {
		fake.lookupSIDReturnsOnCall = make(map[int]struct {
			result1 *syscall.SID
			result2 string
			result3 uint32
			result4 error
		})
	}
	fake.lookupSIDReturnsOnCall[i] = struct {
		result1 *syscall.SID
		result2 string
		result3 uint32
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeSyscall) OpenCurrentProcessToken() (syscall.Token, error) {
	fake.openCurrentProcessTokenMutex.Lock()
	ret, specificReturn := fake.openCurrentProcessTokenReturnsOnCall[len(fake.openCurrentProcessTokenArgsForCall)]
	fake.openCurrentProcessTokenArgsForCall = append(fake.openCurrentProcessTokenArgsForCall, struct{}{})
	fake.recordInvocation("OpenCurrentProcessToken", []interface{}{})
	fake.openCurrentProcessTokenMutex.Unlock()
	if fake.OpenCurrentProcessTokenStub != nil {
		return fake.OpenCurrentProcessTokenStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.openCurrentProcessTokenReturns.result1, fake.openCurrentProcessTokenReturns.result2
}

func (fake *FakeSyscall) OpenCurrentProcessTokenCallCount() int {
	fake.openCurrentProcessTokenMutex.RLock()
	defer fake.openCurrentProcessTokenMutex.RUnlock()
	return len(fake.openCurrentProcessTokenArgsForCall)
}

func (fake *FakeSyscall) OpenCurrentProcessTokenReturns(result1 syscall.Token, result2 error) {
	fake.OpenCurrentProcessTokenStub = nil
	fake.openCurrentProcessTokenReturns = struct {
		result1 syscall.Token
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) OpenCurrentProcessTokenReturnsOnCall(i int, result1 syscall.Token, result2 error) {
	fake.OpenCurrentProcessTokenStub = nil
	if fake.openCurrentProcessTokenReturnsOnCall == nil {
		fake.openCurrentProcessTokenReturnsOnCall = make(map[int]struct {
			result1 syscall.Token
			result2 error
		})
	}
	fake.openCurrentProcessTokenReturnsOnCall[i] = struct {
		result1 syscall.Token
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) UnixCredentials(ucred *syscall.Ucred) []byte {
	fake.unixCredentialsMutex.Lock()
	ret, specificReturn := fake.unixCredentialsReturnsOnCall[len(fake.unixCredentialsArgsForCall)]
	fake.unixCredentialsArgsForCall = append(fake.unixCredentialsArgsForCall, struct {
		ucred *syscall.Ucred
	}{ucred})
	fake.recordInvocation("UnixCredentials", []interface{}{ucred})
	fake.unixCredentialsMutex.Unlock()
	if fake.UnixCredentialsStub != nil {
		return fake.UnixCredentialsStub(ucred)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unixCredentialsReturns.result1
}

func (fake *FakeSyscall) UnixCredentialsCallCount() int {
	fake.unixCredentialsMutex.RLock()
	defer fake.unixCredentialsMutex.RUnlock()
	return len(fake.unixCredentialsArgsForCall)
}

func (fake *FakeSyscall) UnixCredentialsArgsForCall(i int) *syscall.Ucred {
	fake.unixCredentialsMutex.RLock()
	defer fake.unixCredentialsMutex.RUnlock()
	return fake.unixCredentialsArgsForCall[i].ucred
}

func (fake *FakeSyscall) UnixCredentialsReturns(result1 []byte) {
	fake.UnixCredentialsStub = nil
	fake.unixCredentialsReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeSyscall) UnixCredentialsReturnsOnCall(i int, result1 []byte) {
	fake.UnixCredentialsStub = nil
	if fake.unixCredentialsReturnsOnCall == nil {
		fake.unixCredentialsReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.unixCredentialsReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeSyscall) ParseUnixCredentials(m *syscall.SocketControlMessage) (*syscall.Ucred, error) {
	fake.parseUnixCredentialsMutex.Lock()
	ret, specificReturn := fake.parseUnixCredentialsReturnsOnCall[len(fake.parseUnixCredentialsArgsForCall)]
	fake.parseUnixCredentialsArgsForCall = append(fake.parseUnixCredentialsArgsForCall, struct {
		m *syscall.SocketControlMessage
	}{m})
	fake.recordInvocation("ParseUnixCredentials", []interface{}{m})
	fake.parseUnixCredentialsMutex.Unlock()
	if fake.ParseUnixCredentialsStub != nil {
		return fake.ParseUnixCredentialsStub(m)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseUnixCredentialsReturns.result1, fake.parseUnixCredentialsReturns.result2
}

func (fake *FakeSyscall) ParseUnixCredentialsCallCount() int {
	fake.parseUnixCredentialsMutex.RLock()
	defer fake.parseUnixCredentialsMutex.RUnlock()
	return len(fake.parseUnixCredentialsArgsForCall)
}

func (fake *FakeSyscall) ParseUnixCredentialsArgsForCall(i int) *syscall.SocketControlMessage {
	fake.parseUnixCredentialsMutex.RLock()
	defer fake.parseUnixCredentialsMutex.RUnlock()
	return fake.parseUnixCredentialsArgsForCall[i].m
}

func (fake *FakeSyscall) ParseUnixCredentialsReturns(result1 *syscall.Ucred, result2 error) {
	fake.ParseUnixCredentialsStub = nil
	fake.parseUnixCredentialsReturns = struct {
		result1 *syscall.Ucred
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseUnixCredentialsReturnsOnCall(i int, result1 *syscall.Ucred, result2 error) {
	fake.ParseUnixCredentialsStub = nil
	if fake.parseUnixCredentialsReturnsOnCall == nil {
		fake.parseUnixCredentialsReturnsOnCall = make(map[int]struct {
			result1 *syscall.Ucred
			result2 error
		})
	}
	fake.parseUnixCredentialsReturnsOnCall[i] = struct {
		result1 *syscall.Ucred
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CmsgLen(datalen int) int {
	fake.cmsgLenMutex.Lock()
	ret, specificReturn := fake.cmsgLenReturnsOnCall[len(fake.cmsgLenArgsForCall)]
	fake.cmsgLenArgsForCall = append(fake.cmsgLenArgsForCall, struct {
		datalen int
	}{datalen})
	fake.recordInvocation("CmsgLen", []interface{}{datalen})
	fake.cmsgLenMutex.Unlock()
	if fake.CmsgLenStub != nil {
		return fake.CmsgLenStub(datalen)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cmsgLenReturns.result1
}

func (fake *FakeSyscall) CmsgLenCallCount() int {
	fake.cmsgLenMutex.RLock()
	defer fake.cmsgLenMutex.RUnlock()
	return len(fake.cmsgLenArgsForCall)
}

func (fake *FakeSyscall) CmsgLenArgsForCall(i int) int {
	fake.cmsgLenMutex.RLock()
	defer fake.cmsgLenMutex.RUnlock()
	return fake.cmsgLenArgsForCall[i].datalen
}

func (fake *FakeSyscall) CmsgLenReturns(result1 int) {
	fake.CmsgLenStub = nil
	fake.cmsgLenReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) CmsgLenReturnsOnCall(i int, result1 int) {
	fake.CmsgLenStub = nil
	if fake.cmsgLenReturnsOnCall == nil {
		fake.cmsgLenReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.cmsgLenReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) CmsgSpace(datalen int) int {
	fake.cmsgSpaceMutex.Lock()
	ret, specificReturn := fake.cmsgSpaceReturnsOnCall[len(fake.cmsgSpaceArgsForCall)]
	fake.cmsgSpaceArgsForCall = append(fake.cmsgSpaceArgsForCall, struct {
		datalen int
	}{datalen})
	fake.recordInvocation("CmsgSpace", []interface{}{datalen})
	fake.cmsgSpaceMutex.Unlock()
	if fake.CmsgSpaceStub != nil {
		return fake.CmsgSpaceStub(datalen)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cmsgSpaceReturns.result1
}

func (fake *FakeSyscall) CmsgSpaceCallCount() int {
	fake.cmsgSpaceMutex.RLock()
	defer fake.cmsgSpaceMutex.RUnlock()
	return len(fake.cmsgSpaceArgsForCall)
}

func (fake *FakeSyscall) CmsgSpaceArgsForCall(i int) int {
	fake.cmsgSpaceMutex.RLock()
	defer fake.cmsgSpaceMutex.RUnlock()
	return fake.cmsgSpaceArgsForCall[i].datalen
}

func (fake *FakeSyscall) CmsgSpaceReturns(result1 int) {
	fake.CmsgSpaceStub = nil
	fake.cmsgSpaceReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) CmsgSpaceReturnsOnCall(i int, result1 int) {
	fake.CmsgSpaceStub = nil
	if fake.cmsgSpaceReturnsOnCall == nil {
		fake.cmsgSpaceReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.cmsgSpaceReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) ParseSocketControlMessage(b []byte) ([]syscall.SocketControlMessage, error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.parseSocketControlMessageMutex.Lock()
	ret, specificReturn := fake.parseSocketControlMessageReturnsOnCall[len(fake.parseSocketControlMessageArgsForCall)]
	fake.parseSocketControlMessageArgsForCall = append(fake.parseSocketControlMessageArgsForCall, struct {
		b []byte
	}{bCopy})
	fake.recordInvocation("ParseSocketControlMessage", []interface{}{bCopy})
	fake.parseSocketControlMessageMutex.Unlock()
	if fake.ParseSocketControlMessageStub != nil {
		return fake.ParseSocketControlMessageStub(b)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseSocketControlMessageReturns.result1, fake.parseSocketControlMessageReturns.result2
}

func (fake *FakeSyscall) ParseSocketControlMessageCallCount() int {
	fake.parseSocketControlMessageMutex.RLock()
	defer fake.parseSocketControlMessageMutex.RUnlock()
	return len(fake.parseSocketControlMessageArgsForCall)
}

func (fake *FakeSyscall) ParseSocketControlMessageArgsForCall(i int) []byte {
	fake.parseSocketControlMessageMutex.RLock()
	defer fake.parseSocketControlMessageMutex.RUnlock()
	return fake.parseSocketControlMessageArgsForCall[i].b
}

func (fake *FakeSyscall) ParseSocketControlMessageReturns(result1 []syscall.SocketControlMessage, result2 error) {
	fake.ParseSocketControlMessageStub = nil
	fake.parseSocketControlMessageReturns = struct {
		result1 []syscall.SocketControlMessage
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseSocketControlMessageReturnsOnCall(i int, result1 []syscall.SocketControlMessage, result2 error) {
	fake.ParseSocketControlMessageStub = nil
	if fake.parseSocketControlMessageReturnsOnCall == nil {
		fake.parseSocketControlMessageReturnsOnCall = make(map[int]struct {
			result1 []syscall.SocketControlMessage
			result2 error
		})
	}
	fake.parseSocketControlMessageReturnsOnCall[i] = struct {
		result1 []syscall.SocketControlMessage
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) UnixRights(fds ...int) []byte {
	fake.unixRightsMutex.Lock()
	ret, specificReturn := fake.unixRightsReturnsOnCall[len(fake.unixRightsArgsForCall)]
	fake.unixRightsArgsForCall = append(fake.unixRightsArgsForCall, struct {
		fds []int
	}{fds})
	fake.recordInvocation("UnixRights", []interface{}{fds})
	fake.unixRightsMutex.Unlock()
	if fake.UnixRightsStub != nil {
		return fake.UnixRightsStub(fds...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unixRightsReturns.result1
}

func (fake *FakeSyscall) UnixRightsCallCount() int {
	fake.unixRightsMutex.RLock()
	defer fake.unixRightsMutex.RUnlock()
	return len(fake.unixRightsArgsForCall)
}

func (fake *FakeSyscall) UnixRightsArgsForCall(i int) []int {
	fake.unixRightsMutex.RLock()
	defer fake.unixRightsMutex.RUnlock()
	return fake.unixRightsArgsForCall[i].fds
}

func (fake *FakeSyscall) UnixRightsReturns(result1 []byte) {
	fake.UnixRightsStub = nil
	fake.unixRightsReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeSyscall) UnixRightsReturnsOnCall(i int, result1 []byte) {
	fake.UnixRightsStub = nil
	if fake.unixRightsReturnsOnCall == nil {
		fake.unixRightsReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.unixRightsReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeSyscall) ParseUnixRights(m *syscall.SocketControlMessage) ([]int, error) {
	fake.parseUnixRightsMutex.Lock()
	ret, specificReturn := fake.parseUnixRightsReturnsOnCall[len(fake.parseUnixRightsArgsForCall)]
	fake.parseUnixRightsArgsForCall = append(fake.parseUnixRightsArgsForCall, struct {
		m *syscall.SocketControlMessage
	}{m})
	fake.recordInvocation("ParseUnixRights", []interface{}{m})
	fake.parseUnixRightsMutex.Unlock()
	if fake.ParseUnixRightsStub != nil {
		return fake.ParseUnixRightsStub(m)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseUnixRightsReturns.result1, fake.parseUnixRightsReturns.result2
}

func (fake *FakeSyscall) ParseUnixRightsCallCount() int {
	fake.parseUnixRightsMutex.RLock()
	defer fake.parseUnixRightsMutex.RUnlock()
	return len(fake.parseUnixRightsArgsForCall)
}

func (fake *FakeSyscall) ParseUnixRightsArgsForCall(i int) *syscall.SocketControlMessage {
	fake.parseUnixRightsMutex.RLock()
	defer fake.parseUnixRightsMutex.RUnlock()
	return fake.parseUnixRightsArgsForCall[i].m
}

func (fake *FakeSyscall) ParseUnixRightsReturns(result1 []int, result2 error) {
	fake.ParseUnixRightsStub = nil
	fake.parseUnixRightsReturns = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ParseUnixRightsReturnsOnCall(i int, result1 []int, result2 error) {
	fake.ParseUnixRightsStub = nil
	if fake.parseUnixRightsReturnsOnCall == nil {
		fake.parseUnixRightsReturnsOnCall = make(map[int]struct {
			result1 []int
			result2 error
		})
	}
	fake.parseUnixRightsReturnsOnCall[i] = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) StringByteSlice(s string) []byte {
	fake.stringByteSliceMutex.Lock()
	ret, specificReturn := fake.stringByteSliceReturnsOnCall[len(fake.stringByteSliceArgsForCall)]
	fake.stringByteSliceArgsForCall = append(fake.stringByteSliceArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("StringByteSlice", []interface{}{s})
	fake.stringByteSliceMutex.Unlock()
	if fake.StringByteSliceStub != nil {
		return fake.StringByteSliceStub(s)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stringByteSliceReturns.result1
}

func (fake *FakeSyscall) StringByteSliceCallCount() int {
	fake.stringByteSliceMutex.RLock()
	defer fake.stringByteSliceMutex.RUnlock()
	return len(fake.stringByteSliceArgsForCall)
}

func (fake *FakeSyscall) StringByteSliceArgsForCall(i int) string {
	fake.stringByteSliceMutex.RLock()
	defer fake.stringByteSliceMutex.RUnlock()
	return fake.stringByteSliceArgsForCall[i].s
}

func (fake *FakeSyscall) StringByteSliceReturns(result1 []byte) {
	fake.StringByteSliceStub = nil
	fake.stringByteSliceReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeSyscall) StringByteSliceReturnsOnCall(i int, result1 []byte) {
	fake.StringByteSliceStub = nil
	if fake.stringByteSliceReturnsOnCall == nil {
		fake.stringByteSliceReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.stringByteSliceReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeSyscall) ByteSliceFromString(s string) ([]byte, error) {
	fake.byteSliceFromStringMutex.Lock()
	ret, specificReturn := fake.byteSliceFromStringReturnsOnCall[len(fake.byteSliceFromStringArgsForCall)]
	fake.byteSliceFromStringArgsForCall = append(fake.byteSliceFromStringArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("ByteSliceFromString", []interface{}{s})
	fake.byteSliceFromStringMutex.Unlock()
	if fake.ByteSliceFromStringStub != nil {
		return fake.ByteSliceFromStringStub(s)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.byteSliceFromStringReturns.result1, fake.byteSliceFromStringReturns.result2
}

func (fake *FakeSyscall) ByteSliceFromStringCallCount() int {
	fake.byteSliceFromStringMutex.RLock()
	defer fake.byteSliceFromStringMutex.RUnlock()
	return len(fake.byteSliceFromStringArgsForCall)
}

func (fake *FakeSyscall) ByteSliceFromStringArgsForCall(i int) string {
	fake.byteSliceFromStringMutex.RLock()
	defer fake.byteSliceFromStringMutex.RUnlock()
	return fake.byteSliceFromStringArgsForCall[i].s
}

func (fake *FakeSyscall) ByteSliceFromStringReturns(result1 []byte, result2 error) {
	fake.ByteSliceFromStringStub = nil
	fake.byteSliceFromStringReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ByteSliceFromStringReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.ByteSliceFromStringStub = nil
	if fake.byteSliceFromStringReturnsOnCall == nil {
		fake.byteSliceFromStringReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.byteSliceFromStringReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) StringBytePtr(s string) *byte {
	fake.stringBytePtrMutex.Lock()
	ret, specificReturn := fake.stringBytePtrReturnsOnCall[len(fake.stringBytePtrArgsForCall)]
	fake.stringBytePtrArgsForCall = append(fake.stringBytePtrArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("StringBytePtr", []interface{}{s})
	fake.stringBytePtrMutex.Unlock()
	if fake.StringBytePtrStub != nil {
		return fake.StringBytePtrStub(s)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stringBytePtrReturns.result1
}

func (fake *FakeSyscall) StringBytePtrCallCount() int {
	fake.stringBytePtrMutex.RLock()
	defer fake.stringBytePtrMutex.RUnlock()
	return len(fake.stringBytePtrArgsForCall)
}

func (fake *FakeSyscall) StringBytePtrArgsForCall(i int) string {
	fake.stringBytePtrMutex.RLock()
	defer fake.stringBytePtrMutex.RUnlock()
	return fake.stringBytePtrArgsForCall[i].s
}

func (fake *FakeSyscall) StringBytePtrReturns(result1 *byte) {
	fake.StringBytePtrStub = nil
	fake.stringBytePtrReturns = struct {
		result1 *byte
	}{result1}
}

func (fake *FakeSyscall) StringBytePtrReturnsOnCall(i int, result1 *byte) {
	fake.StringBytePtrStub = nil
	if fake.stringBytePtrReturnsOnCall == nil {
		fake.stringBytePtrReturnsOnCall = make(map[int]struct {
			result1 *byte
		})
	}
	fake.stringBytePtrReturnsOnCall[i] = struct {
		result1 *byte
	}{result1}
}

func (fake *FakeSyscall) BytePtrFromString(s string) (*byte, error) {
	fake.bytePtrFromStringMutex.Lock()
	ret, specificReturn := fake.bytePtrFromStringReturnsOnCall[len(fake.bytePtrFromStringArgsForCall)]
	fake.bytePtrFromStringArgsForCall = append(fake.bytePtrFromStringArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("BytePtrFromString", []interface{}{s})
	fake.bytePtrFromStringMutex.Unlock()
	if fake.BytePtrFromStringStub != nil {
		return fake.BytePtrFromStringStub(s)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.bytePtrFromStringReturns.result1, fake.bytePtrFromStringReturns.result2
}

func (fake *FakeSyscall) BytePtrFromStringCallCount() int {
	fake.bytePtrFromStringMutex.RLock()
	defer fake.bytePtrFromStringMutex.RUnlock()
	return len(fake.bytePtrFromStringArgsForCall)
}

func (fake *FakeSyscall) BytePtrFromStringArgsForCall(i int) string {
	fake.bytePtrFromStringMutex.RLock()
	defer fake.bytePtrFromStringMutex.RUnlock()
	return fake.bytePtrFromStringArgsForCall[i].s
}

func (fake *FakeSyscall) BytePtrFromStringReturns(result1 *byte, result2 error) {
	fake.BytePtrFromStringStub = nil
	fake.bytePtrFromStringReturns = struct {
		result1 *byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) BytePtrFromStringReturnsOnCall(i int, result1 *byte, result2 error) {
	fake.BytePtrFromStringStub = nil
	if fake.bytePtrFromStringReturnsOnCall == nil {
		fake.bytePtrFromStringReturnsOnCall = make(map[int]struct {
			result1 *byte
			result2 error
		})
	}
	fake.bytePtrFromStringReturnsOnCall[i] = struct {
		result1 *byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Getpagesize() int {
	fake.getpagesizeMutex.Lock()
	ret, specificReturn := fake.getpagesizeReturnsOnCall[len(fake.getpagesizeArgsForCall)]
	fake.getpagesizeArgsForCall = append(fake.getpagesizeArgsForCall, struct{}{})
	fake.recordInvocation("Getpagesize", []interface{}{})
	fake.getpagesizeMutex.Unlock()
	if fake.GetpagesizeStub != nil {
		return fake.GetpagesizeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getpagesizeReturns.result1
}

func (fake *FakeSyscall) GetpagesizeCallCount() int {
	fake.getpagesizeMutex.RLock()
	defer fake.getpagesizeMutex.RUnlock()
	return len(fake.getpagesizeArgsForCall)
}

func (fake *FakeSyscall) GetpagesizeReturns(result1 int) {
	fake.GetpagesizeStub = nil
	fake.getpagesizeReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) GetpagesizeReturnsOnCall(i int, result1 int) {
	fake.GetpagesizeStub = nil
	if fake.getpagesizeReturnsOnCall == nil {
		fake.getpagesizeReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getpagesizeReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) Getgroups() (gids []int, err error) {
	fake.getgroupsMutex.Lock()
	ret, specificReturn := fake.getgroupsReturnsOnCall[len(fake.getgroupsArgsForCall)]
	fake.getgroupsArgsForCall = append(fake.getgroupsArgsForCall, struct{}{})
	fake.recordInvocation("Getgroups", []interface{}{})
	fake.getgroupsMutex.Unlock()
	if fake.GetgroupsStub != nil {
		return fake.GetgroupsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getgroupsReturns.result1, fake.getgroupsReturns.result2
}

func (fake *FakeSyscall) GetgroupsCallCount() int {
	fake.getgroupsMutex.RLock()
	defer fake.getgroupsMutex.RUnlock()
	return len(fake.getgroupsArgsForCall)
}

func (fake *FakeSyscall) GetgroupsReturns(result1 []int, result2 error) {
	fake.GetgroupsStub = nil
	fake.getgroupsReturns = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetgroupsReturnsOnCall(i int, result1 []int, result2 error) {
	fake.GetgroupsStub = nil
	if fake.getgroupsReturnsOnCall == nil {
		fake.getgroupsReturnsOnCall = make(map[int]struct {
			result1 []int
			result2 error
		})
	}
	fake.getgroupsReturnsOnCall[i] = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Setgroups(gids []int) (err error) {
	var gidsCopy []int
	if gids != nil {
		gidsCopy = make([]int, len(gids))
		copy(gidsCopy, gids)
	}
	fake.setgroupsMutex.Lock()
	ret, specificReturn := fake.setgroupsReturnsOnCall[len(fake.setgroupsArgsForCall)]
	fake.setgroupsArgsForCall = append(fake.setgroupsArgsForCall, struct {
		gids []int
	}{gidsCopy})
	fake.recordInvocation("Setgroups", []interface{}{gidsCopy})
	fake.setgroupsMutex.Unlock()
	if fake.SetgroupsStub != nil {
		return fake.SetgroupsStub(gids)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setgroupsReturns.result1
}

func (fake *FakeSyscall) SetgroupsCallCount() int {
	fake.setgroupsMutex.RLock()
	defer fake.setgroupsMutex.RUnlock()
	return len(fake.setgroupsArgsForCall)
}

func (fake *FakeSyscall) SetgroupsArgsForCall(i int) []int {
	fake.setgroupsMutex.RLock()
	defer fake.setgroupsMutex.RUnlock()
	return fake.setgroupsArgsForCall[i].gids
}

func (fake *FakeSyscall) SetgroupsReturns(result1 error) {
	fake.SetgroupsStub = nil
	fake.setgroupsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetgroupsReturnsOnCall(i int, result1 error) {
	fake.SetgroupsStub = nil
	if fake.setgroupsReturnsOnCall == nil {
		fake.setgroupsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setgroupsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Wait4(pid int, wstatus *syscall.WaitStatus, options int, rusage *syscall.Rusage) (wpid int, err error) {
	fake.wait4Mutex.Lock()
	ret, specificReturn := fake.wait4ReturnsOnCall[len(fake.wait4ArgsForCall)]
	fake.wait4ArgsForCall = append(fake.wait4ArgsForCall, struct {
		pid     int
		wstatus *syscall.WaitStatus
		options int
		rusage  *syscall.Rusage
	}{pid, wstatus, options, rusage})
	fake.recordInvocation("Wait4", []interface{}{pid, wstatus, options, rusage})
	fake.wait4Mutex.Unlock()
	if fake.Wait4Stub != nil {
		return fake.Wait4Stub(pid, wstatus, options, rusage)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.wait4Returns.result1, fake.wait4Returns.result2
}

func (fake *FakeSyscall) Wait4CallCount() int {
	fake.wait4Mutex.RLock()
	defer fake.wait4Mutex.RUnlock()
	return len(fake.wait4ArgsForCall)
}

func (fake *FakeSyscall) Wait4ArgsForCall(i int) (int, *syscall.WaitStatus, int, *syscall.Rusage) {
	fake.wait4Mutex.RLock()
	defer fake.wait4Mutex.RUnlock()
	return fake.wait4ArgsForCall[i].pid, fake.wait4ArgsForCall[i].wstatus, fake.wait4ArgsForCall[i].options, fake.wait4ArgsForCall[i].rusage
}

func (fake *FakeSyscall) Wait4Returns(result1 int, result2 error) {
	fake.Wait4Stub = nil
	fake.wait4Returns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Wait4ReturnsOnCall(i int, result1 int, result2 error) {
	fake.Wait4Stub = nil
	if fake.wait4ReturnsOnCall == nil {
		fake.wait4ReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.wait4ReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptByte(fd int, level int, opt int) (value byte, err error) {
	fake.getsockoptByteMutex.Lock()
	ret, specificReturn := fake.getsockoptByteReturnsOnCall[len(fake.getsockoptByteArgsForCall)]
	fake.getsockoptByteArgsForCall = append(fake.getsockoptByteArgsForCall, struct {
		fd    int
		level int
		opt   int
	}{fd, level, opt})
	fake.recordInvocation("GetsockoptByte", []interface{}{fd, level, opt})
	fake.getsockoptByteMutex.Unlock()
	if fake.GetsockoptByteStub != nil {
		return fake.GetsockoptByteStub(fd, level, opt)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getsockoptByteReturns.result1, fake.getsockoptByteReturns.result2
}

func (fake *FakeSyscall) GetsockoptByteCallCount() int {
	fake.getsockoptByteMutex.RLock()
	defer fake.getsockoptByteMutex.RUnlock()
	return len(fake.getsockoptByteArgsForCall)
}

func (fake *FakeSyscall) GetsockoptByteArgsForCall(i int) (int, int, int) {
	fake.getsockoptByteMutex.RLock()
	defer fake.getsockoptByteMutex.RUnlock()
	return fake.getsockoptByteArgsForCall[i].fd, fake.getsockoptByteArgsForCall[i].level, fake.getsockoptByteArgsForCall[i].opt
}

func (fake *FakeSyscall) GetsockoptByteReturns(result1 byte, result2 error) {
	fake.GetsockoptByteStub = nil
	fake.getsockoptByteReturns = struct {
		result1 byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptByteReturnsOnCall(i int, result1 byte, result2 error) {
	fake.GetsockoptByteStub = nil
	if fake.getsockoptByteReturnsOnCall == nil {
		fake.getsockoptByteReturnsOnCall = make(map[int]struct {
			result1 byte
			result2 error
		})
	}
	fake.getsockoptByteReturnsOnCall[i] = struct {
		result1 byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptInet4Addr(fd int, level int, opt int) (value [4]byte, err error) {
	fake.getsockoptInet4AddrMutex.Lock()
	ret, specificReturn := fake.getsockoptInet4AddrReturnsOnCall[len(fake.getsockoptInet4AddrArgsForCall)]
	fake.getsockoptInet4AddrArgsForCall = append(fake.getsockoptInet4AddrArgsForCall, struct {
		fd    int
		level int
		opt   int
	}{fd, level, opt})
	fake.recordInvocation("GetsockoptInet4Addr", []interface{}{fd, level, opt})
	fake.getsockoptInet4AddrMutex.Unlock()
	if fake.GetsockoptInet4AddrStub != nil {
		return fake.GetsockoptInet4AddrStub(fd, level, opt)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getsockoptInet4AddrReturns.result1, fake.getsockoptInet4AddrReturns.result2
}

func (fake *FakeSyscall) GetsockoptInet4AddrCallCount() int {
	fake.getsockoptInet4AddrMutex.RLock()
	defer fake.getsockoptInet4AddrMutex.RUnlock()
	return len(fake.getsockoptInet4AddrArgsForCall)
}

func (fake *FakeSyscall) GetsockoptInet4AddrArgsForCall(i int) (int, int, int) {
	fake.getsockoptInet4AddrMutex.RLock()
	defer fake.getsockoptInet4AddrMutex.RUnlock()
	return fake.getsockoptInet4AddrArgsForCall[i].fd, fake.getsockoptInet4AddrArgsForCall[i].level, fake.getsockoptInet4AddrArgsForCall[i].opt
}

func (fake *FakeSyscall) GetsockoptInet4AddrReturns(result1 [4]byte, result2 error) {
	fake.GetsockoptInet4AddrStub = nil
	fake.getsockoptInet4AddrReturns = struct {
		result1 [4]byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptInet4AddrReturnsOnCall(i int, result1 [4]byte, result2 error) {
	fake.GetsockoptInet4AddrStub = nil
	if fake.getsockoptInet4AddrReturnsOnCall == nil {
		fake.getsockoptInet4AddrReturnsOnCall = make(map[int]struct {
			result1 [4]byte
			result2 error
		})
	}
	fake.getsockoptInet4AddrReturnsOnCall[i] = struct {
		result1 [4]byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptIPMreq(fd int, level int, opt int) (*syscall.IPMreq, error) {
	fake.getsockoptIPMreqMutex.Lock()
	ret, specificReturn := fake.getsockoptIPMreqReturnsOnCall[len(fake.getsockoptIPMreqArgsForCall)]
	fake.getsockoptIPMreqArgsForCall = append(fake.getsockoptIPMreqArgsForCall, struct {
		fd    int
		level int
		opt   int
	}{fd, level, opt})
	fake.recordInvocation("GetsockoptIPMreq", []interface{}{fd, level, opt})
	fake.getsockoptIPMreqMutex.Unlock()
	if fake.GetsockoptIPMreqStub != nil {
		return fake.GetsockoptIPMreqStub(fd, level, opt)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getsockoptIPMreqReturns.result1, fake.getsockoptIPMreqReturns.result2
}

func (fake *FakeSyscall) GetsockoptIPMreqCallCount() int {
	fake.getsockoptIPMreqMutex.RLock()
	defer fake.getsockoptIPMreqMutex.RUnlock()
	return len(fake.getsockoptIPMreqArgsForCall)
}

func (fake *FakeSyscall) GetsockoptIPMreqArgsForCall(i int) (int, int, int) {
	fake.getsockoptIPMreqMutex.RLock()
	defer fake.getsockoptIPMreqMutex.RUnlock()
	return fake.getsockoptIPMreqArgsForCall[i].fd, fake.getsockoptIPMreqArgsForCall[i].level, fake.getsockoptIPMreqArgsForCall[i].opt
}

func (fake *FakeSyscall) GetsockoptIPMreqReturns(result1 *syscall.IPMreq, result2 error) {
	fake.GetsockoptIPMreqStub = nil
	fake.getsockoptIPMreqReturns = struct {
		result1 *syscall.IPMreq
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptIPMreqReturnsOnCall(i int, result1 *syscall.IPMreq, result2 error) {
	fake.GetsockoptIPMreqStub = nil
	if fake.getsockoptIPMreqReturnsOnCall == nil {
		fake.getsockoptIPMreqReturnsOnCall = make(map[int]struct {
			result1 *syscall.IPMreq
			result2 error
		})
	}
	fake.getsockoptIPMreqReturnsOnCall[i] = struct {
		result1 *syscall.IPMreq
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptIPv6Mreq(fd int, level int, opt int) (*syscall.IPv6Mreq, error) {
	fake.getsockoptIPv6MreqMutex.Lock()
	ret, specificReturn := fake.getsockoptIPv6MreqReturnsOnCall[len(fake.getsockoptIPv6MreqArgsForCall)]
	fake.getsockoptIPv6MreqArgsForCall = append(fake.getsockoptIPv6MreqArgsForCall, struct {
		fd    int
		level int
		opt   int
	}{fd, level, opt})
	fake.recordInvocation("GetsockoptIPv6Mreq", []interface{}{fd, level, opt})
	fake.getsockoptIPv6MreqMutex.Unlock()
	if fake.GetsockoptIPv6MreqStub != nil {
		return fake.GetsockoptIPv6MreqStub(fd, level, opt)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getsockoptIPv6MreqReturns.result1, fake.getsockoptIPv6MreqReturns.result2
}

func (fake *FakeSyscall) GetsockoptIPv6MreqCallCount() int {
	fake.getsockoptIPv6MreqMutex.RLock()
	defer fake.getsockoptIPv6MreqMutex.RUnlock()
	return len(fake.getsockoptIPv6MreqArgsForCall)
}

func (fake *FakeSyscall) GetsockoptIPv6MreqArgsForCall(i int) (int, int, int) {
	fake.getsockoptIPv6MreqMutex.RLock()
	defer fake.getsockoptIPv6MreqMutex.RUnlock()
	return fake.getsockoptIPv6MreqArgsForCall[i].fd, fake.getsockoptIPv6MreqArgsForCall[i].level, fake.getsockoptIPv6MreqArgsForCall[i].opt
}

func (fake *FakeSyscall) GetsockoptIPv6MreqReturns(result1 *syscall.IPv6Mreq, result2 error) {
	fake.GetsockoptIPv6MreqStub = nil
	fake.getsockoptIPv6MreqReturns = struct {
		result1 *syscall.IPv6Mreq
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptIPv6MreqReturnsOnCall(i int, result1 *syscall.IPv6Mreq, result2 error) {
	fake.GetsockoptIPv6MreqStub = nil
	if fake.getsockoptIPv6MreqReturnsOnCall == nil {
		fake.getsockoptIPv6MreqReturnsOnCall = make(map[int]struct {
			result1 *syscall.IPv6Mreq
			result2 error
		})
	}
	fake.getsockoptIPv6MreqReturnsOnCall[i] = struct {
		result1 *syscall.IPv6Mreq
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptIPv6MTUInfo(fd int, level int, opt int) (*syscall.IPv6MTUInfo, error) {
	fake.getsockoptIPv6MTUInfoMutex.Lock()
	ret, specificReturn := fake.getsockoptIPv6MTUInfoReturnsOnCall[len(fake.getsockoptIPv6MTUInfoArgsForCall)]
	fake.getsockoptIPv6MTUInfoArgsForCall = append(fake.getsockoptIPv6MTUInfoArgsForCall, struct {
		fd    int
		level int
		opt   int
	}{fd, level, opt})
	fake.recordInvocation("GetsockoptIPv6MTUInfo", []interface{}{fd, level, opt})
	fake.getsockoptIPv6MTUInfoMutex.Unlock()
	if fake.GetsockoptIPv6MTUInfoStub != nil {
		return fake.GetsockoptIPv6MTUInfoStub(fd, level, opt)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getsockoptIPv6MTUInfoReturns.result1, fake.getsockoptIPv6MTUInfoReturns.result2
}

func (fake *FakeSyscall) GetsockoptIPv6MTUInfoCallCount() int {
	fake.getsockoptIPv6MTUInfoMutex.RLock()
	defer fake.getsockoptIPv6MTUInfoMutex.RUnlock()
	return len(fake.getsockoptIPv6MTUInfoArgsForCall)
}

func (fake *FakeSyscall) GetsockoptIPv6MTUInfoArgsForCall(i int) (int, int, int) {
	fake.getsockoptIPv6MTUInfoMutex.RLock()
	defer fake.getsockoptIPv6MTUInfoMutex.RUnlock()
	return fake.getsockoptIPv6MTUInfoArgsForCall[i].fd, fake.getsockoptIPv6MTUInfoArgsForCall[i].level, fake.getsockoptIPv6MTUInfoArgsForCall[i].opt
}

func (fake *FakeSyscall) GetsockoptIPv6MTUInfoReturns(result1 *syscall.IPv6MTUInfo, result2 error) {
	fake.GetsockoptIPv6MTUInfoStub = nil
	fake.getsockoptIPv6MTUInfoReturns = struct {
		result1 *syscall.IPv6MTUInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptIPv6MTUInfoReturnsOnCall(i int, result1 *syscall.IPv6MTUInfo, result2 error) {
	fake.GetsockoptIPv6MTUInfoStub = nil
	if fake.getsockoptIPv6MTUInfoReturnsOnCall == nil {
		fake.getsockoptIPv6MTUInfoReturnsOnCall = make(map[int]struct {
			result1 *syscall.IPv6MTUInfo
			result2 error
		})
	}
	fake.getsockoptIPv6MTUInfoReturnsOnCall[i] = struct {
		result1 *syscall.IPv6MTUInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptICMPv6Filter(fd int, level int, opt int) (*syscall.ICMPv6Filter, error) {
	fake.getsockoptICMPv6FilterMutex.Lock()
	ret, specificReturn := fake.getsockoptICMPv6FilterReturnsOnCall[len(fake.getsockoptICMPv6FilterArgsForCall)]
	fake.getsockoptICMPv6FilterArgsForCall = append(fake.getsockoptICMPv6FilterArgsForCall, struct {
		fd    int
		level int
		opt   int
	}{fd, level, opt})
	fake.recordInvocation("GetsockoptICMPv6Filter", []interface{}{fd, level, opt})
	fake.getsockoptICMPv6FilterMutex.Unlock()
	if fake.GetsockoptICMPv6FilterStub != nil {
		return fake.GetsockoptICMPv6FilterStub(fd, level, opt)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getsockoptICMPv6FilterReturns.result1, fake.getsockoptICMPv6FilterReturns.result2
}

func (fake *FakeSyscall) GetsockoptICMPv6FilterCallCount() int {
	fake.getsockoptICMPv6FilterMutex.RLock()
	defer fake.getsockoptICMPv6FilterMutex.RUnlock()
	return len(fake.getsockoptICMPv6FilterArgsForCall)
}

func (fake *FakeSyscall) GetsockoptICMPv6FilterArgsForCall(i int) (int, int, int) {
	fake.getsockoptICMPv6FilterMutex.RLock()
	defer fake.getsockoptICMPv6FilterMutex.RUnlock()
	return fake.getsockoptICMPv6FilterArgsForCall[i].fd, fake.getsockoptICMPv6FilterArgsForCall[i].level, fake.getsockoptICMPv6FilterArgsForCall[i].opt
}

func (fake *FakeSyscall) GetsockoptICMPv6FilterReturns(result1 *syscall.ICMPv6Filter, result2 error) {
	fake.GetsockoptICMPv6FilterStub = nil
	fake.getsockoptICMPv6FilterReturns = struct {
		result1 *syscall.ICMPv6Filter
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptICMPv6FilterReturnsOnCall(i int, result1 *syscall.ICMPv6Filter, result2 error) {
	fake.GetsockoptICMPv6FilterStub = nil
	if fake.getsockoptICMPv6FilterReturnsOnCall == nil {
		fake.getsockoptICMPv6FilterReturnsOnCall = make(map[int]struct {
			result1 *syscall.ICMPv6Filter
			result2 error
		})
	}
	fake.getsockoptICMPv6FilterReturnsOnCall[i] = struct {
		result1 *syscall.ICMPv6Filter
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Kevent(kq int, changes []syscall.Kevent_t, events []syscall.Kevent_t, timeout *syscall.Timespec) (n int, err error) {
	var changesCopy []syscall.Kevent_t
	if changes != nil {
		changesCopy = make([]syscall.Kevent_t, len(changes))
		copy(changesCopy, changes)
	}
	var eventsCopy []syscall.Kevent_t
	if events != nil {
		eventsCopy = make([]syscall.Kevent_t, len(events))
		copy(eventsCopy, events)
	}
	fake.keventMutex.Lock()
	ret, specificReturn := fake.keventReturnsOnCall[len(fake.keventArgsForCall)]
	fake.keventArgsForCall = append(fake.keventArgsForCall, struct {
		kq      int
		changes []syscall.Kevent_t
		events  []syscall.Kevent_t
		timeout *syscall.Timespec
	}{kq, changesCopy, eventsCopy, timeout})
	fake.recordInvocation("Kevent", []interface{}{kq, changesCopy, eventsCopy, timeout})
	fake.keventMutex.Unlock()
	if fake.KeventStub != nil {
		return fake.KeventStub(kq, changes, events, timeout)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.keventReturns.result1, fake.keventReturns.result2
}

func (fake *FakeSyscall) KeventCallCount() int {
	fake.keventMutex.RLock()
	defer fake.keventMutex.RUnlock()
	return len(fake.keventArgsForCall)
}

func (fake *FakeSyscall) KeventArgsForCall(i int) (int, []syscall.Kevent_t, []syscall.Kevent_t, *syscall.Timespec) {
	fake.keventMutex.RLock()
	defer fake.keventMutex.RUnlock()
	return fake.keventArgsForCall[i].kq, fake.keventArgsForCall[i].changes, fake.keventArgsForCall[i].events, fake.keventArgsForCall[i].timeout
}

func (fake *FakeSyscall) KeventReturns(result1 int, result2 error) {
	fake.KeventStub = nil
	fake.keventReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) KeventReturnsOnCall(i int, result1 int, result2 error) {
	fake.KeventStub = nil
	if fake.keventReturnsOnCall == nil {
		fake.keventReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.keventReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Sysctl(name string) (value string, err error) {
	fake.sysctlMutex.Lock()
	ret, specificReturn := fake.sysctlReturnsOnCall[len(fake.sysctlArgsForCall)]
	fake.sysctlArgsForCall = append(fake.sysctlArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Sysctl", []interface{}{name})
	fake.sysctlMutex.Unlock()
	if fake.SysctlStub != nil {
		return fake.SysctlStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.sysctlReturns.result1, fake.sysctlReturns.result2
}

func (fake *FakeSyscall) SysctlCallCount() int {
	fake.sysctlMutex.RLock()
	defer fake.sysctlMutex.RUnlock()
	return len(fake.sysctlArgsForCall)
}

func (fake *FakeSyscall) SysctlArgsForCall(i int) string {
	fake.sysctlMutex.RLock()
	defer fake.sysctlMutex.RUnlock()
	return fake.sysctlArgsForCall[i].name
}

func (fake *FakeSyscall) SysctlReturns(result1 string, result2 error) {
	fake.SysctlStub = nil
	fake.sysctlReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SysctlReturnsOnCall(i int, result1 string, result2 error) {
	fake.SysctlStub = nil
	if fake.sysctlReturnsOnCall == nil {
		fake.sysctlReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.sysctlReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SysctlUint32(name string) (value uint32, err error) {
	fake.sysctlUint32Mutex.Lock()
	ret, specificReturn := fake.sysctlUint32ReturnsOnCall[len(fake.sysctlUint32ArgsForCall)]
	fake.sysctlUint32ArgsForCall = append(fake.sysctlUint32ArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("SysctlUint32", []interface{}{name})
	fake.sysctlUint32Mutex.Unlock()
	if fake.SysctlUint32Stub != nil {
		return fake.SysctlUint32Stub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.sysctlUint32Returns.result1, fake.sysctlUint32Returns.result2
}

func (fake *FakeSyscall) SysctlUint32CallCount() int {
	fake.sysctlUint32Mutex.RLock()
	defer fake.sysctlUint32Mutex.RUnlock()
	return len(fake.sysctlUint32ArgsForCall)
}

func (fake *FakeSyscall) SysctlUint32ArgsForCall(i int) string {
	fake.sysctlUint32Mutex.RLock()
	defer fake.sysctlUint32Mutex.RUnlock()
	return fake.sysctlUint32ArgsForCall[i].name
}

func (fake *FakeSyscall) SysctlUint32Returns(result1 uint32, result2 error) {
	fake.SysctlUint32Stub = nil
	fake.sysctlUint32Returns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SysctlUint32ReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.SysctlUint32Stub = nil
	if fake.sysctlUint32ReturnsOnCall == nil {
		fake.sysctlUint32ReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.sysctlUint32ReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Utimes(path string, tv []syscall.Timeval) (err error) {
	var tvCopy []syscall.Timeval
	if tv != nil {
		tvCopy = make([]syscall.Timeval, len(tv))
		copy(tvCopy, tv)
	}
	fake.utimesMutex.Lock()
	ret, specificReturn := fake.utimesReturnsOnCall[len(fake.utimesArgsForCall)]
	fake.utimesArgsForCall = append(fake.utimesArgsForCall, struct {
		path string
		tv   []syscall.Timeval
	}{path, tvCopy})
	fake.recordInvocation("Utimes", []interface{}{path, tvCopy})
	fake.utimesMutex.Unlock()
	if fake.UtimesStub != nil {
		return fake.UtimesStub(path, tv)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.utimesReturns.result1
}

func (fake *FakeSyscall) UtimesCallCount() int {
	fake.utimesMutex.RLock()
	defer fake.utimesMutex.RUnlock()
	return len(fake.utimesArgsForCall)
}

func (fake *FakeSyscall) UtimesArgsForCall(i int) (string, []syscall.Timeval) {
	fake.utimesMutex.RLock()
	defer fake.utimesMutex.RUnlock()
	return fake.utimesArgsForCall[i].path, fake.utimesArgsForCall[i].tv
}

func (fake *FakeSyscall) UtimesReturns(result1 error) {
	fake.UtimesStub = nil
	fake.utimesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UtimesReturnsOnCall(i int, result1 error) {
	fake.UtimesStub = nil
	if fake.utimesReturnsOnCall == nil {
		fake.utimesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.utimesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Futimes(fd int, tv []syscall.Timeval) (err error) {
	var tvCopy []syscall.Timeval
	if tv != nil {
		tvCopy = make([]syscall.Timeval, len(tv))
		copy(tvCopy, tv)
	}
	fake.futimesMutex.Lock()
	ret, specificReturn := fake.futimesReturnsOnCall[len(fake.futimesArgsForCall)]
	fake.futimesArgsForCall = append(fake.futimesArgsForCall, struct {
		fd int
		tv []syscall.Timeval
	}{fd, tvCopy})
	fake.recordInvocation("Futimes", []interface{}{fd, tvCopy})
	fake.futimesMutex.Unlock()
	if fake.FutimesStub != nil {
		return fake.FutimesStub(fd, tv)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.futimesReturns.result1
}

func (fake *FakeSyscall) FutimesCallCount() int {
	fake.futimesMutex.RLock()
	defer fake.futimesMutex.RUnlock()
	return len(fake.futimesArgsForCall)
}

func (fake *FakeSyscall) FutimesArgsForCall(i int) (int, []syscall.Timeval) {
	fake.futimesMutex.RLock()
	defer fake.futimesMutex.RUnlock()
	return fake.futimesArgsForCall[i].fd, fake.futimesArgsForCall[i].tv
}

func (fake *FakeSyscall) FutimesReturns(result1 error) {
	fake.FutimesStub = nil
	fake.futimesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FutimesReturnsOnCall(i int, result1 error) {
	fake.FutimesStub = nil
	if fake.futimesReturnsOnCall == nil {
		fake.futimesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.futimesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error) {
	fake.mmapMutex.Lock()
	ret, specificReturn := fake.mmapReturnsOnCall[len(fake.mmapArgsForCall)]
	fake.mmapArgsForCall = append(fake.mmapArgsForCall, struct {
		fd     int
		offset int64
		length int
		prot   int
		flags  int
	}{fd, offset, length, prot, flags})
	fake.recordInvocation("Mmap", []interface{}{fd, offset, length, prot, flags})
	fake.mmapMutex.Unlock()
	if fake.MmapStub != nil {
		return fake.MmapStub(fd, offset, length, prot, flags)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.mmapReturns.result1, fake.mmapReturns.result2
}

func (fake *FakeSyscall) MmapCallCount() int {
	fake.mmapMutex.RLock()
	defer fake.mmapMutex.RUnlock()
	return len(fake.mmapArgsForCall)
}

func (fake *FakeSyscall) MmapArgsForCall(i int) (int, int64, int, int, int) {
	fake.mmapMutex.RLock()
	defer fake.mmapMutex.RUnlock()
	return fake.mmapArgsForCall[i].fd, fake.mmapArgsForCall[i].offset, fake.mmapArgsForCall[i].length, fake.mmapArgsForCall[i].prot, fake.mmapArgsForCall[i].flags
}

func (fake *FakeSyscall) MmapReturns(result1 []byte, result2 error) {
	fake.MmapStub = nil
	fake.mmapReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) MmapReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.MmapStub = nil
	if fake.mmapReturnsOnCall == nil {
		fake.mmapReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.mmapReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Munmap(b []byte) (err error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.munmapMutex.Lock()
	ret, specificReturn := fake.munmapReturnsOnCall[len(fake.munmapArgsForCall)]
	fake.munmapArgsForCall = append(fake.munmapArgsForCall, struct {
		b []byte
	}{bCopy})
	fake.recordInvocation("Munmap", []interface{}{bCopy})
	fake.munmapMutex.Unlock()
	if fake.MunmapStub != nil {
		return fake.MunmapStub(b)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.munmapReturns.result1
}

func (fake *FakeSyscall) MunmapCallCount() int {
	fake.munmapMutex.RLock()
	defer fake.munmapMutex.RUnlock()
	return len(fake.munmapArgsForCall)
}

func (fake *FakeSyscall) MunmapArgsForCall(i int) []byte {
	fake.munmapMutex.RLock()
	defer fake.munmapMutex.RUnlock()
	return fake.munmapArgsForCall[i].b
}

func (fake *FakeSyscall) MunmapReturns(result1 error) {
	fake.MunmapStub = nil
	fake.munmapReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MunmapReturnsOnCall(i int, result1 error) {
	fake.MunmapStub = nil
	if fake.munmapReturnsOnCall == nil {
		fake.munmapReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.munmapReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceAttach(pid int) (err error) {
	fake.ptraceAttachMutex.Lock()
	ret, specificReturn := fake.ptraceAttachReturnsOnCall[len(fake.ptraceAttachArgsForCall)]
	fake.ptraceAttachArgsForCall = append(fake.ptraceAttachArgsForCall, struct {
		pid int
	}{pid})
	fake.recordInvocation("PtraceAttach", []interface{}{pid})
	fake.ptraceAttachMutex.Unlock()
	if fake.PtraceAttachStub != nil {
		return fake.PtraceAttachStub(pid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ptraceAttachReturns.result1
}

func (fake *FakeSyscall) PtraceAttachCallCount() int {
	fake.ptraceAttachMutex.RLock()
	defer fake.ptraceAttachMutex.RUnlock()
	return len(fake.ptraceAttachArgsForCall)
}

func (fake *FakeSyscall) PtraceAttachArgsForCall(i int) int {
	fake.ptraceAttachMutex.RLock()
	defer fake.ptraceAttachMutex.RUnlock()
	return fake.ptraceAttachArgsForCall[i].pid
}

func (fake *FakeSyscall) PtraceAttachReturns(result1 error) {
	fake.PtraceAttachStub = nil
	fake.ptraceAttachReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceAttachReturnsOnCall(i int, result1 error) {
	fake.PtraceAttachStub = nil
	if fake.ptraceAttachReturnsOnCall == nil {
		fake.ptraceAttachReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ptraceAttachReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceDetach(pid int) (err error) {
	fake.ptraceDetachMutex.Lock()
	ret, specificReturn := fake.ptraceDetachReturnsOnCall[len(fake.ptraceDetachArgsForCall)]
	fake.ptraceDetachArgsForCall = append(fake.ptraceDetachArgsForCall, struct {
		pid int
	}{pid})
	fake.recordInvocation("PtraceDetach", []interface{}{pid})
	fake.ptraceDetachMutex.Unlock()
	if fake.PtraceDetachStub != nil {
		return fake.PtraceDetachStub(pid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ptraceDetachReturns.result1
}

func (fake *FakeSyscall) PtraceDetachCallCount() int {
	fake.ptraceDetachMutex.RLock()
	defer fake.ptraceDetachMutex.RUnlock()
	return len(fake.ptraceDetachArgsForCall)
}

func (fake *FakeSyscall) PtraceDetachArgsForCall(i int) int {
	fake.ptraceDetachMutex.RLock()
	defer fake.ptraceDetachMutex.RUnlock()
	return fake.ptraceDetachArgsForCall[i].pid
}

func (fake *FakeSyscall) PtraceDetachReturns(result1 error) {
	fake.PtraceDetachStub = nil
	fake.ptraceDetachReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceDetachReturnsOnCall(i int, result1 error) {
	fake.PtraceDetachStub = nil
	if fake.ptraceDetachReturnsOnCall == nil {
		fake.ptraceDetachReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ptraceDetachReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Getfsstat(buf []syscall.Statfs_t, flags int) (n int, err error) {
	var bufCopy []syscall.Statfs_t
	if buf != nil {
		bufCopy = make([]syscall.Statfs_t, len(buf))
		copy(bufCopy, buf)
	}
	fake.getfsstatMutex.Lock()
	ret, specificReturn := fake.getfsstatReturnsOnCall[len(fake.getfsstatArgsForCall)]
	fake.getfsstatArgsForCall = append(fake.getfsstatArgsForCall, struct {
		buf   []syscall.Statfs_t
		flags int
	}{bufCopy, flags})
	fake.recordInvocation("Getfsstat", []interface{}{bufCopy, flags})
	fake.getfsstatMutex.Unlock()
	if fake.GetfsstatStub != nil {
		return fake.GetfsstatStub(buf, flags)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getfsstatReturns.result1, fake.getfsstatReturns.result2
}

func (fake *FakeSyscall) GetfsstatCallCount() int {
	fake.getfsstatMutex.RLock()
	defer fake.getfsstatMutex.RUnlock()
	return len(fake.getfsstatArgsForCall)
}

func (fake *FakeSyscall) GetfsstatArgsForCall(i int) ([]syscall.Statfs_t, int) {
	fake.getfsstatMutex.RLock()
	defer fake.getfsstatMutex.RUnlock()
	return fake.getfsstatArgsForCall[i].buf, fake.getfsstatArgsForCall[i].flags
}

func (fake *FakeSyscall) GetfsstatReturns(result1 int, result2 error) {
	fake.GetfsstatStub = nil
	fake.getfsstatReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetfsstatReturnsOnCall(i int, result1 int, result2 error) {
	fake.GetfsstatStub = nil
	if fake.getfsstatReturnsOnCall == nil {
		fake.getfsstatReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getfsstatReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Kill(pid int, signum syscall.Signal) (err error) {
	fake.killMutex.Lock()
	ret, specificReturn := fake.killReturnsOnCall[len(fake.killArgsForCall)]
	fake.killArgsForCall = append(fake.killArgsForCall, struct {
		pid    int
		signum syscall.Signal
	}{pid, signum})
	fake.recordInvocation("Kill", []interface{}{pid, signum})
	fake.killMutex.Unlock()
	if fake.KillStub != nil {
		return fake.KillStub(pid, signum)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.killReturns.result1
}

func (fake *FakeSyscall) KillCallCount() int {
	fake.killMutex.RLock()
	defer fake.killMutex.RUnlock()
	return len(fake.killArgsForCall)
}

func (fake *FakeSyscall) KillArgsForCall(i int) (int, syscall.Signal) {
	fake.killMutex.RLock()
	defer fake.killMutex.RUnlock()
	return fake.killArgsForCall[i].pid, fake.killArgsForCall[i].signum
}

func (fake *FakeSyscall) KillReturns(result1 error) {
	fake.KillStub = nil
	fake.killReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) KillReturnsOnCall(i int, result1 error) {
	fake.KillStub = nil
	if fake.killReturnsOnCall == nil {
		fake.killReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.killReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Gettimeofday(tv *syscall.Timeval) error {
	fake.gettimeofdayMutex.Lock()
	ret, specificReturn := fake.gettimeofdayReturnsOnCall[len(fake.gettimeofdayArgsForCall)]
	fake.gettimeofdayArgsForCall = append(fake.gettimeofdayArgsForCall, struct {
		tv *syscall.Timeval
	}{tv})
	fake.recordInvocation("Gettimeofday", []interface{}{tv})
	fake.gettimeofdayMutex.Unlock()
	if fake.GettimeofdayStub != nil {
		return fake.GettimeofdayStub(tv)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.gettimeofdayReturns.result1
}

func (fake *FakeSyscall) GettimeofdayCallCount() int {
	fake.gettimeofdayMutex.RLock()
	defer fake.gettimeofdayMutex.RUnlock()
	return len(fake.gettimeofdayArgsForCall)
}

func (fake *FakeSyscall) GettimeofdayArgsForCall(i int) *syscall.Timeval {
	fake.gettimeofdayMutex.RLock()
	defer fake.gettimeofdayMutex.RUnlock()
	return fake.gettimeofdayArgsForCall[i].tv
}

func (fake *FakeSyscall) GettimeofdayReturns(result1 error) {
	fake.GettimeofdayStub = nil
	fake.gettimeofdayReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GettimeofdayReturnsOnCall(i int, result1 error) {
	fake.GettimeofdayStub = nil
	if fake.gettimeofdayReturnsOnCall == nil {
		fake.gettimeofdayReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.gettimeofdayReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetKevent(k *syscall.Kevent_t, fd int, mode int, flags int) {
	fake.setKeventMutex.Lock()
	fake.setKeventArgsForCall = append(fake.setKeventArgsForCall, struct {
		k     *syscall.Kevent_t
		fd    int
		mode  int
		flags int
	}{k, fd, mode, flags})
	fake.recordInvocation("SetKevent", []interface{}{k, fd, mode, flags})
	fake.setKeventMutex.Unlock()
	if fake.SetKeventStub != nil {
		fake.SetKeventStub(k, fd, mode, flags)
	}
}

func (fake *FakeSyscall) SetKeventCallCount() int {
	fake.setKeventMutex.RLock()
	defer fake.setKeventMutex.RUnlock()
	return len(fake.setKeventArgsForCall)
}

func (fake *FakeSyscall) SetKeventArgsForCall(i int) (*syscall.Kevent_t, int, int, int) {
	fake.setKeventMutex.RLock()
	defer fake.setKeventMutex.RUnlock()
	return fake.setKeventArgsForCall[i].k, fake.setKeventArgsForCall[i].fd, fake.setKeventArgsForCall[i].mode, fake.setKeventArgsForCall[i].flags
}

func (fake *FakeSyscall) GetsockoptIPMreqn(fd int, level int, opt int) (*syscall.IPMreqn, error) {
	fake.getsockoptIPMreqnMutex.Lock()
	ret, specificReturn := fake.getsockoptIPMreqnReturnsOnCall[len(fake.getsockoptIPMreqnArgsForCall)]
	fake.getsockoptIPMreqnArgsForCall = append(fake.getsockoptIPMreqnArgsForCall, struct {
		fd    int
		level int
		opt   int
	}{fd, level, opt})
	fake.recordInvocation("GetsockoptIPMreqn", []interface{}{fd, level, opt})
	fake.getsockoptIPMreqnMutex.Unlock()
	if fake.GetsockoptIPMreqnStub != nil {
		return fake.GetsockoptIPMreqnStub(fd, level, opt)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getsockoptIPMreqnReturns.result1, fake.getsockoptIPMreqnReturns.result2
}

func (fake *FakeSyscall) GetsockoptIPMreqnCallCount() int {
	fake.getsockoptIPMreqnMutex.RLock()
	defer fake.getsockoptIPMreqnMutex.RUnlock()
	return len(fake.getsockoptIPMreqnArgsForCall)
}

func (fake *FakeSyscall) GetsockoptIPMreqnArgsForCall(i int) (int, int, int) {
	fake.getsockoptIPMreqnMutex.RLock()
	defer fake.getsockoptIPMreqnMutex.RUnlock()
	return fake.getsockoptIPMreqnArgsForCall[i].fd, fake.getsockoptIPMreqnArgsForCall[i].level, fake.getsockoptIPMreqnArgsForCall[i].opt
}

func (fake *FakeSyscall) GetsockoptIPMreqnReturns(result1 *syscall.IPMreqn, result2 error) {
	fake.GetsockoptIPMreqnStub = nil
	fake.getsockoptIPMreqnReturns = struct {
		result1 *syscall.IPMreqn
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptIPMreqnReturnsOnCall(i int, result1 *syscall.IPMreqn, result2 error) {
	fake.GetsockoptIPMreqnStub = nil
	if fake.getsockoptIPMreqnReturnsOnCall == nil {
		fake.getsockoptIPMreqnReturnsOnCall = make(map[int]struct {
			result1 *syscall.IPMreqn
			result2 error
		})
	}
	fake.getsockoptIPMreqnReturnsOnCall[i] = struct {
		result1 *syscall.IPMreqn
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetsockoptIPMreqn(fd int, level int, opt int, mreq *syscall.IPMreqn) (err error) {
	fake.setsockoptIPMreqnMutex.Lock()
	ret, specificReturn := fake.setsockoptIPMreqnReturnsOnCall[len(fake.setsockoptIPMreqnArgsForCall)]
	fake.setsockoptIPMreqnArgsForCall = append(fake.setsockoptIPMreqnArgsForCall, struct {
		fd    int
		level int
		opt   int
		mreq  *syscall.IPMreqn
	}{fd, level, opt, mreq})
	fake.recordInvocation("SetsockoptIPMreqn", []interface{}{fd, level, opt, mreq})
	fake.setsockoptIPMreqnMutex.Unlock()
	if fake.SetsockoptIPMreqnStub != nil {
		return fake.SetsockoptIPMreqnStub(fd, level, opt, mreq)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setsockoptIPMreqnReturns.result1
}

func (fake *FakeSyscall) SetsockoptIPMreqnCallCount() int {
	fake.setsockoptIPMreqnMutex.RLock()
	defer fake.setsockoptIPMreqnMutex.RUnlock()
	return len(fake.setsockoptIPMreqnArgsForCall)
}

func (fake *FakeSyscall) SetsockoptIPMreqnArgsForCall(i int) (int, int, int, *syscall.IPMreqn) {
	fake.setsockoptIPMreqnMutex.RLock()
	defer fake.setsockoptIPMreqnMutex.RUnlock()
	return fake.setsockoptIPMreqnArgsForCall[i].fd, fake.setsockoptIPMreqnArgsForCall[i].level, fake.setsockoptIPMreqnArgsForCall[i].opt, fake.setsockoptIPMreqnArgsForCall[i].mreq
}

func (fake *FakeSyscall) SetsockoptIPMreqnReturns(result1 error) {
	fake.SetsockoptIPMreqnStub = nil
	fake.setsockoptIPMreqnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptIPMreqnReturnsOnCall(i int, result1 error) {
	fake.SetsockoptIPMreqnStub = nil
	if fake.setsockoptIPMreqnReturnsOnCall == nil {
		fake.setsockoptIPMreqnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setsockoptIPMreqnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Accept4(fd int, flags int) (nfd int, sa syscall.Sockaddr, err error) {
	fake.accept4Mutex.Lock()
	ret, specificReturn := fake.accept4ReturnsOnCall[len(fake.accept4ArgsForCall)]
	fake.accept4ArgsForCall = append(fake.accept4ArgsForCall, struct {
		fd    int
		flags int
	}{fd, flags})
	fake.recordInvocation("Accept4", []interface{}{fd, flags})
	fake.accept4Mutex.Unlock()
	if fake.Accept4Stub != nil {
		return fake.Accept4Stub(fd, flags)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.accept4Returns.result1, fake.accept4Returns.result2, fake.accept4Returns.result3
}

func (fake *FakeSyscall) Accept4CallCount() int {
	fake.accept4Mutex.RLock()
	defer fake.accept4Mutex.RUnlock()
	return len(fake.accept4ArgsForCall)
}

func (fake *FakeSyscall) Accept4ArgsForCall(i int) (int, int) {
	fake.accept4Mutex.RLock()
	defer fake.accept4Mutex.RUnlock()
	return fake.accept4ArgsForCall[i].fd, fake.accept4ArgsForCall[i].flags
}

func (fake *FakeSyscall) Accept4Returns(result1 int, result2 syscall.Sockaddr, result3 error) {
	fake.Accept4Stub = nil
	fake.accept4Returns = struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Accept4ReturnsOnCall(i int, result1 int, result2 syscall.Sockaddr, result3 error) {
	fake.Accept4Stub = nil
	if fake.accept4ReturnsOnCall == nil {
		fake.accept4ReturnsOnCall = make(map[int]struct {
			result1 int
			result2 syscall.Sockaddr
			result3 error
		})
	}
	fake.accept4ReturnsOnCall[i] = struct {
		result1 int
		result2 syscall.Sockaddr
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Access(path string, mode uint32) (err error) {
	fake.accessMutex.Lock()
	ret, specificReturn := fake.accessReturnsOnCall[len(fake.accessArgsForCall)]
	fake.accessArgsForCall = append(fake.accessArgsForCall, struct {
		path string
		mode uint32
	}{path, mode})
	fake.recordInvocation("Access", []interface{}{path, mode})
	fake.accessMutex.Unlock()
	if fake.AccessStub != nil {
		return fake.AccessStub(path, mode)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.accessReturns.result1
}

func (fake *FakeSyscall) AccessCallCount() int {
	fake.accessMutex.RLock()
	defer fake.accessMutex.RUnlock()
	return len(fake.accessArgsForCall)
}

func (fake *FakeSyscall) AccessArgsForCall(i int) (string, uint32) {
	fake.accessMutex.RLock()
	defer fake.accessMutex.RUnlock()
	return fake.accessArgsForCall[i].path, fake.accessArgsForCall[i].mode
}

func (fake *FakeSyscall) AccessReturns(result1 error) {
	fake.AccessStub = nil
	fake.accessReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) AccessReturnsOnCall(i int, result1 error) {
	fake.AccessStub = nil
	if fake.accessReturnsOnCall == nil {
		fake.accessReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.accessReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Creat(path string, mode uint32) (fd int, err error) {
	fake.creatMutex.Lock()
	ret, specificReturn := fake.creatReturnsOnCall[len(fake.creatArgsForCall)]
	fake.creatArgsForCall = append(fake.creatArgsForCall, struct {
		path string
		mode uint32
	}{path, mode})
	fake.recordInvocation("Creat", []interface{}{path, mode})
	fake.creatMutex.Unlock()
	if fake.CreatStub != nil {
		return fake.CreatStub(path, mode)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.creatReturns.result1, fake.creatReturns.result2
}

func (fake *FakeSyscall) CreatCallCount() int {
	fake.creatMutex.RLock()
	defer fake.creatMutex.RUnlock()
	return len(fake.creatArgsForCall)
}

func (fake *FakeSyscall) CreatArgsForCall(i int) (string, uint32) {
	fake.creatMutex.RLock()
	defer fake.creatMutex.RUnlock()
	return fake.creatArgsForCall[i].path, fake.creatArgsForCall[i].mode
}

func (fake *FakeSyscall) CreatReturns(result1 int, result2 error) {
	fake.CreatStub = nil
	fake.creatReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CreatReturnsOnCall(i int, result1 int, result2 error) {
	fake.CreatStub = nil
	if fake.creatReturnsOnCall == nil {
		fake.creatReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.creatReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Mknod(path string, mode uint32, dev int) (err error) {
	fake.mknodMutex.Lock()
	ret, specificReturn := fake.mknodReturnsOnCall[len(fake.mknodArgsForCall)]
	fake.mknodArgsForCall = append(fake.mknodArgsForCall, struct {
		path string
		mode uint32
		dev  int
	}{path, mode, dev})
	fake.recordInvocation("Mknod", []interface{}{path, mode, dev})
	fake.mknodMutex.Unlock()
	if fake.MknodStub != nil {
		return fake.MknodStub(path, mode, dev)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mknodReturns.result1
}

func (fake *FakeSyscall) MknodCallCount() int {
	fake.mknodMutex.RLock()
	defer fake.mknodMutex.RUnlock()
	return len(fake.mknodArgsForCall)
}

func (fake *FakeSyscall) MknodArgsForCall(i int) (string, uint32, int) {
	fake.mknodMutex.RLock()
	defer fake.mknodMutex.RUnlock()
	return fake.mknodArgsForCall[i].path, fake.mknodArgsForCall[i].mode, fake.mknodArgsForCall[i].dev
}

func (fake *FakeSyscall) MknodReturns(result1 error) {
	fake.MknodStub = nil
	fake.mknodReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MknodReturnsOnCall(i int, result1 error) {
	fake.MknodStub = nil
	if fake.mknodReturnsOnCall == nil {
		fake.mknodReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mknodReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) {
	fake.openatMutex.Lock()
	ret, specificReturn := fake.openatReturnsOnCall[len(fake.openatArgsForCall)]
	fake.openatArgsForCall = append(fake.openatArgsForCall, struct {
		dirfd int
		path  string
		flags int
		mode  uint32
	}{dirfd, path, flags, mode})
	fake.recordInvocation("Openat", []interface{}{dirfd, path, flags, mode})
	fake.openatMutex.Unlock()
	if fake.OpenatStub != nil {
		return fake.OpenatStub(dirfd, path, flags, mode)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.openatReturns.result1, fake.openatReturns.result2
}

func (fake *FakeSyscall) OpenatCallCount() int {
	fake.openatMutex.RLock()
	defer fake.openatMutex.RUnlock()
	return len(fake.openatArgsForCall)
}

func (fake *FakeSyscall) OpenatArgsForCall(i int) (int, string, int, uint32) {
	fake.openatMutex.RLock()
	defer fake.openatMutex.RUnlock()
	return fake.openatArgsForCall[i].dirfd, fake.openatArgsForCall[i].path, fake.openatArgsForCall[i].flags, fake.openatArgsForCall[i].mode
}

func (fake *FakeSyscall) OpenatReturns(result1 int, result2 error) {
	fake.OpenatStub = nil
	fake.openatReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) OpenatReturnsOnCall(i int, result1 int, result2 error) {
	fake.OpenatStub = nil
	if fake.openatReturnsOnCall == nil {
		fake.openatReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.openatReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Unlinkat(dirfd int, path string) error {
	fake.unlinkatMutex.Lock()
	ret, specificReturn := fake.unlinkatReturnsOnCall[len(fake.unlinkatArgsForCall)]
	fake.unlinkatArgsForCall = append(fake.unlinkatArgsForCall, struct {
		dirfd int
		path  string
	}{dirfd, path})
	fake.recordInvocation("Unlinkat", []interface{}{dirfd, path})
	fake.unlinkatMutex.Unlock()
	if fake.UnlinkatStub != nil {
		return fake.UnlinkatStub(dirfd, path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unlinkatReturns.result1
}

func (fake *FakeSyscall) UnlinkatCallCount() int {
	fake.unlinkatMutex.RLock()
	defer fake.unlinkatMutex.RUnlock()
	return len(fake.unlinkatArgsForCall)
}

func (fake *FakeSyscall) UnlinkatArgsForCall(i int) (int, string) {
	fake.unlinkatMutex.RLock()
	defer fake.unlinkatMutex.RUnlock()
	return fake.unlinkatArgsForCall[i].dirfd, fake.unlinkatArgsForCall[i].path
}

func (fake *FakeSyscall) UnlinkatReturns(result1 error) {
	fake.UnlinkatStub = nil
	fake.unlinkatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UnlinkatReturnsOnCall(i int, result1 error) {
	fake.UnlinkatStub = nil
	if fake.unlinkatReturnsOnCall == nil {
		fake.unlinkatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unlinkatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Futimesat(dirfd int, path string, tv []syscall.Timeval) (err error) {
	var tvCopy []syscall.Timeval
	if tv != nil {
		tvCopy = make([]syscall.Timeval, len(tv))
		copy(tvCopy, tv)
	}
	fake.futimesatMutex.Lock()
	ret, specificReturn := fake.futimesatReturnsOnCall[len(fake.futimesatArgsForCall)]
	fake.futimesatArgsForCall = append(fake.futimesatArgsForCall, struct {
		dirfd int
		path  string
		tv    []syscall.Timeval
	}{dirfd, path, tvCopy})
	fake.recordInvocation("Futimesat", []interface{}{dirfd, path, tvCopy})
	fake.futimesatMutex.Unlock()
	if fake.FutimesatStub != nil {
		return fake.FutimesatStub(dirfd, path, tv)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.futimesatReturns.result1
}

func (fake *FakeSyscall) FutimesatCallCount() int {
	fake.futimesatMutex.RLock()
	defer fake.futimesatMutex.RUnlock()
	return len(fake.futimesatArgsForCall)
}

func (fake *FakeSyscall) FutimesatArgsForCall(i int) (int, string, []syscall.Timeval) {
	fake.futimesatMutex.RLock()
	defer fake.futimesatMutex.RUnlock()
	return fake.futimesatArgsForCall[i].dirfd, fake.futimesatArgsForCall[i].path, fake.futimesatArgsForCall[i].tv
}

func (fake *FakeSyscall) FutimesatReturns(result1 error) {
	fake.FutimesatStub = nil
	fake.futimesatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FutimesatReturnsOnCall(i int, result1 error) {
	fake.FutimesatStub = nil
	if fake.futimesatReturnsOnCall == nil {
		fake.futimesatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.futimesatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Mkfifo(path string, mode uint32) (err error) {
	fake.mkfifoMutex.Lock()
	ret, specificReturn := fake.mkfifoReturnsOnCall[len(fake.mkfifoArgsForCall)]
	fake.mkfifoArgsForCall = append(fake.mkfifoArgsForCall, struct {
		path string
		mode uint32
	}{path, mode})
	fake.recordInvocation("Mkfifo", []interface{}{path, mode})
	fake.mkfifoMutex.Unlock()
	if fake.MkfifoStub != nil {
		return fake.MkfifoStub(path, mode)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mkfifoReturns.result1
}

func (fake *FakeSyscall) MkfifoCallCount() int {
	fake.mkfifoMutex.RLock()
	defer fake.mkfifoMutex.RUnlock()
	return len(fake.mkfifoArgsForCall)
}

func (fake *FakeSyscall) MkfifoArgsForCall(i int) (string, uint32) {
	fake.mkfifoMutex.RLock()
	defer fake.mkfifoMutex.RUnlock()
	return fake.mkfifoArgsForCall[i].path, fake.mkfifoArgsForCall[i].mode
}

func (fake *FakeSyscall) MkfifoReturns(result1 error) {
	fake.MkfifoStub = nil
	fake.mkfifoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MkfifoReturnsOnCall(i int, result1 error) {
	fake.MkfifoStub = nil
	if fake.mkfifoReturnsOnCall == nil {
		fake.mkfifoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkfifoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetsockoptUcred(fd int, level int, opt int) (*syscall.Ucred, error) {
	fake.getsockoptUcredMutex.Lock()
	ret, specificReturn := fake.getsockoptUcredReturnsOnCall[len(fake.getsockoptUcredArgsForCall)]
	fake.getsockoptUcredArgsForCall = append(fake.getsockoptUcredArgsForCall, struct {
		fd    int
		level int
		opt   int
	}{fd, level, opt})
	fake.recordInvocation("GetsockoptUcred", []interface{}{fd, level, opt})
	fake.getsockoptUcredMutex.Unlock()
	if fake.GetsockoptUcredStub != nil {
		return fake.GetsockoptUcredStub(fd, level, opt)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getsockoptUcredReturns.result1, fake.getsockoptUcredReturns.result2
}

func (fake *FakeSyscall) GetsockoptUcredCallCount() int {
	fake.getsockoptUcredMutex.RLock()
	defer fake.getsockoptUcredMutex.RUnlock()
	return len(fake.getsockoptUcredArgsForCall)
}

func (fake *FakeSyscall) GetsockoptUcredArgsForCall(i int) (int, int, int) {
	fake.getsockoptUcredMutex.RLock()
	defer fake.getsockoptUcredMutex.RUnlock()
	return fake.getsockoptUcredArgsForCall[i].fd, fake.getsockoptUcredArgsForCall[i].level, fake.getsockoptUcredArgsForCall[i].opt
}

func (fake *FakeSyscall) GetsockoptUcredReturns(result1 *syscall.Ucred, result2 error) {
	fake.GetsockoptUcredStub = nil
	fake.getsockoptUcredReturns = struct {
		result1 *syscall.Ucred
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsockoptUcredReturnsOnCall(i int, result1 *syscall.Ucred, result2 error) {
	fake.GetsockoptUcredStub = nil
	if fake.getsockoptUcredReturnsOnCall == nil {
		fake.getsockoptUcredReturnsOnCall = make(map[int]struct {
			result1 *syscall.Ucred
			result2 error
		})
	}
	fake.getsockoptUcredReturnsOnCall[i] = struct {
		result1 *syscall.Ucred
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) BindToDevice(fd int, device string) (err error) {
	fake.bindToDeviceMutex.Lock()
	ret, specificReturn := fake.bindToDeviceReturnsOnCall[len(fake.bindToDeviceArgsForCall)]
	fake.bindToDeviceArgsForCall = append(fake.bindToDeviceArgsForCall, struct {
		fd     int
		device string
	}{fd, device})
	fake.recordInvocation("BindToDevice", []interface{}{fd, device})
	fake.bindToDeviceMutex.Unlock()
	if fake.BindToDeviceStub != nil {
		return fake.BindToDeviceStub(fd, device)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bindToDeviceReturns.result1
}

func (fake *FakeSyscall) BindToDeviceCallCount() int {
	fake.bindToDeviceMutex.RLock()
	defer fake.bindToDeviceMutex.RUnlock()
	return len(fake.bindToDeviceArgsForCall)
}

func (fake *FakeSyscall) BindToDeviceArgsForCall(i int) (int, string) {
	fake.bindToDeviceMutex.RLock()
	defer fake.bindToDeviceMutex.RUnlock()
	return fake.bindToDeviceArgsForCall[i].fd, fake.bindToDeviceArgsForCall[i].device
}

func (fake *FakeSyscall) BindToDeviceReturns(result1 error) {
	fake.BindToDeviceStub = nil
	fake.bindToDeviceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) BindToDeviceReturnsOnCall(i int, result1 error) {
	fake.BindToDeviceStub = nil
	if fake.bindToDeviceReturnsOnCall == nil {
		fake.bindToDeviceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bindToDeviceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtracePeekText(pid int, addr uintptr, out []byte) (count int, err error) {
	var outCopy []byte
	if out != nil {
		outCopy = make([]byte, len(out))
		copy(outCopy, out)
	}
	fake.ptracePeekTextMutex.Lock()
	ret, specificReturn := fake.ptracePeekTextReturnsOnCall[len(fake.ptracePeekTextArgsForCall)]
	fake.ptracePeekTextArgsForCall = append(fake.ptracePeekTextArgsForCall, struct {
		pid  int
		addr uintptr
		out  []byte
	}{pid, addr, outCopy})
	fake.recordInvocation("PtracePeekText", []interface{}{pid, addr, outCopy})
	fake.ptracePeekTextMutex.Unlock()
	if fake.PtracePeekTextStub != nil {
		return fake.PtracePeekTextStub(pid, addr, out)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.ptracePeekTextReturns.result1, fake.ptracePeekTextReturns.result2
}

func (fake *FakeSyscall) PtracePeekTextCallCount() int {
	fake.ptracePeekTextMutex.RLock()
	defer fake.ptracePeekTextMutex.RUnlock()
	return len(fake.ptracePeekTextArgsForCall)
}

func (fake *FakeSyscall) PtracePeekTextArgsForCall(i int) (int, uintptr, []byte) {
	fake.ptracePeekTextMutex.RLock()
	defer fake.ptracePeekTextMutex.RUnlock()
	return fake.ptracePeekTextArgsForCall[i].pid, fake.ptracePeekTextArgsForCall[i].addr, fake.ptracePeekTextArgsForCall[i].out
}

func (fake *FakeSyscall) PtracePeekTextReturns(result1 int, result2 error) {
	fake.PtracePeekTextStub = nil
	fake.ptracePeekTextReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PtracePeekTextReturnsOnCall(i int, result1 int, result2 error) {
	fake.PtracePeekTextStub = nil
	if fake.ptracePeekTextReturnsOnCall == nil {
		fake.ptracePeekTextReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.ptracePeekTextReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PtracePeekData(pid int, addr uintptr, out []byte) (count int, err error) {
	var outCopy []byte
	if out != nil {
		outCopy = make([]byte, len(out))
		copy(outCopy, out)
	}
	fake.ptracePeekDataMutex.Lock()
	ret, specificReturn := fake.ptracePeekDataReturnsOnCall[len(fake.ptracePeekDataArgsForCall)]
	fake.ptracePeekDataArgsForCall = append(fake.ptracePeekDataArgsForCall, struct {
		pid  int
		addr uintptr
		out  []byte
	}{pid, addr, outCopy})
	fake.recordInvocation("PtracePeekData", []interface{}{pid, addr, outCopy})
	fake.ptracePeekDataMutex.Unlock()
	if fake.PtracePeekDataStub != nil {
		return fake.PtracePeekDataStub(pid, addr, out)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.ptracePeekDataReturns.result1, fake.ptracePeekDataReturns.result2
}

func (fake *FakeSyscall) PtracePeekDataCallCount() int {
	fake.ptracePeekDataMutex.RLock()
	defer fake.ptracePeekDataMutex.RUnlock()
	return len(fake.ptracePeekDataArgsForCall)
}

func (fake *FakeSyscall) PtracePeekDataArgsForCall(i int) (int, uintptr, []byte) {
	fake.ptracePeekDataMutex.RLock()
	defer fake.ptracePeekDataMutex.RUnlock()
	return fake.ptracePeekDataArgsForCall[i].pid, fake.ptracePeekDataArgsForCall[i].addr, fake.ptracePeekDataArgsForCall[i].out
}

func (fake *FakeSyscall) PtracePeekDataReturns(result1 int, result2 error) {
	fake.PtracePeekDataStub = nil
	fake.ptracePeekDataReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PtracePeekDataReturnsOnCall(i int, result1 int, result2 error) {
	fake.PtracePeekDataStub = nil
	if fake.ptracePeekDataReturnsOnCall == nil {
		fake.ptracePeekDataReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.ptracePeekDataReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PtracePokeText(pid int, addr uintptr, data []byte) (count int, err error) {
	var dataCopy []byte
	if data != nil {
		dataCopy = make([]byte, len(data))
		copy(dataCopy, data)
	}
	fake.ptracePokeTextMutex.Lock()
	ret, specificReturn := fake.ptracePokeTextReturnsOnCall[len(fake.ptracePokeTextArgsForCall)]
	fake.ptracePokeTextArgsForCall = append(fake.ptracePokeTextArgsForCall, struct {
		pid  int
		addr uintptr
		data []byte
	}{pid, addr, dataCopy})
	fake.recordInvocation("PtracePokeText", []interface{}{pid, addr, dataCopy})
	fake.ptracePokeTextMutex.Unlock()
	if fake.PtracePokeTextStub != nil {
		return fake.PtracePokeTextStub(pid, addr, data)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.ptracePokeTextReturns.result1, fake.ptracePokeTextReturns.result2
}

func (fake *FakeSyscall) PtracePokeTextCallCount() int {
	fake.ptracePokeTextMutex.RLock()
	defer fake.ptracePokeTextMutex.RUnlock()
	return len(fake.ptracePokeTextArgsForCall)
}

func (fake *FakeSyscall) PtracePokeTextArgsForCall(i int) (int, uintptr, []byte) {
	fake.ptracePokeTextMutex.RLock()
	defer fake.ptracePokeTextMutex.RUnlock()
	return fake.ptracePokeTextArgsForCall[i].pid, fake.ptracePokeTextArgsForCall[i].addr, fake.ptracePokeTextArgsForCall[i].data
}

func (fake *FakeSyscall) PtracePokeTextReturns(result1 int, result2 error) {
	fake.PtracePokeTextStub = nil
	fake.ptracePokeTextReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PtracePokeTextReturnsOnCall(i int, result1 int, result2 error) {
	fake.PtracePokeTextStub = nil
	if fake.ptracePokeTextReturnsOnCall == nil {
		fake.ptracePokeTextReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.ptracePokeTextReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PtracePokeData(pid int, addr uintptr, data []byte) (count int, err error) {
	var dataCopy []byte
	if data != nil {
		dataCopy = make([]byte, len(data))
		copy(dataCopy, data)
	}
	fake.ptracePokeDataMutex.Lock()
	ret, specificReturn := fake.ptracePokeDataReturnsOnCall[len(fake.ptracePokeDataArgsForCall)]
	fake.ptracePokeDataArgsForCall = append(fake.ptracePokeDataArgsForCall, struct {
		pid  int
		addr uintptr
		data []byte
	}{pid, addr, dataCopy})
	fake.recordInvocation("PtracePokeData", []interface{}{pid, addr, dataCopy})
	fake.ptracePokeDataMutex.Unlock()
	if fake.PtracePokeDataStub != nil {
		return fake.PtracePokeDataStub(pid, addr, data)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.ptracePokeDataReturns.result1, fake.ptracePokeDataReturns.result2
}

func (fake *FakeSyscall) PtracePokeDataCallCount() int {
	fake.ptracePokeDataMutex.RLock()
	defer fake.ptracePokeDataMutex.RUnlock()
	return len(fake.ptracePokeDataArgsForCall)
}

func (fake *FakeSyscall) PtracePokeDataArgsForCall(i int) (int, uintptr, []byte) {
	fake.ptracePokeDataMutex.RLock()
	defer fake.ptracePokeDataMutex.RUnlock()
	return fake.ptracePokeDataArgsForCall[i].pid, fake.ptracePokeDataArgsForCall[i].addr, fake.ptracePokeDataArgsForCall[i].data
}

func (fake *FakeSyscall) PtracePokeDataReturns(result1 int, result2 error) {
	fake.PtracePokeDataStub = nil
	fake.ptracePokeDataReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PtracePokeDataReturnsOnCall(i int, result1 int, result2 error) {
	fake.PtracePokeDataStub = nil
	if fake.ptracePokeDataReturnsOnCall == nil {
		fake.ptracePokeDataReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.ptracePokeDataReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PtraceGetRegs(pid int, regsout *syscall.PtraceRegs) (err error) {
	fake.ptraceGetRegsMutex.Lock()
	ret, specificReturn := fake.ptraceGetRegsReturnsOnCall[len(fake.ptraceGetRegsArgsForCall)]
	fake.ptraceGetRegsArgsForCall = append(fake.ptraceGetRegsArgsForCall, struct {
		pid     int
		regsout *syscall.PtraceRegs
	}{pid, regsout})
	fake.recordInvocation("PtraceGetRegs", []interface{}{pid, regsout})
	fake.ptraceGetRegsMutex.Unlock()
	if fake.PtraceGetRegsStub != nil {
		return fake.PtraceGetRegsStub(pid, regsout)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ptraceGetRegsReturns.result1
}

func (fake *FakeSyscall) PtraceGetRegsCallCount() int {
	fake.ptraceGetRegsMutex.RLock()
	defer fake.ptraceGetRegsMutex.RUnlock()
	return len(fake.ptraceGetRegsArgsForCall)
}

func (fake *FakeSyscall) PtraceGetRegsArgsForCall(i int) (int, *syscall.PtraceRegs) {
	fake.ptraceGetRegsMutex.RLock()
	defer fake.ptraceGetRegsMutex.RUnlock()
	return fake.ptraceGetRegsArgsForCall[i].pid, fake.ptraceGetRegsArgsForCall[i].regsout
}

func (fake *FakeSyscall) PtraceGetRegsReturns(result1 error) {
	fake.PtraceGetRegsStub = nil
	fake.ptraceGetRegsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceGetRegsReturnsOnCall(i int, result1 error) {
	fake.PtraceGetRegsStub = nil
	if fake.ptraceGetRegsReturnsOnCall == nil {
		fake.ptraceGetRegsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ptraceGetRegsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceSetRegs(pid int, regs *syscall.PtraceRegs) (err error) {
	fake.ptraceSetRegsMutex.Lock()
	ret, specificReturn := fake.ptraceSetRegsReturnsOnCall[len(fake.ptraceSetRegsArgsForCall)]
	fake.ptraceSetRegsArgsForCall = append(fake.ptraceSetRegsArgsForCall, struct {
		pid  int
		regs *syscall.PtraceRegs
	}{pid, regs})
	fake.recordInvocation("PtraceSetRegs", []interface{}{pid, regs})
	fake.ptraceSetRegsMutex.Unlock()
	if fake.PtraceSetRegsStub != nil {
		return fake.PtraceSetRegsStub(pid, regs)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ptraceSetRegsReturns.result1
}

func (fake *FakeSyscall) PtraceSetRegsCallCount() int {
	fake.ptraceSetRegsMutex.RLock()
	defer fake.ptraceSetRegsMutex.RUnlock()
	return len(fake.ptraceSetRegsArgsForCall)
}

func (fake *FakeSyscall) PtraceSetRegsArgsForCall(i int) (int, *syscall.PtraceRegs) {
	fake.ptraceSetRegsMutex.RLock()
	defer fake.ptraceSetRegsMutex.RUnlock()
	return fake.ptraceSetRegsArgsForCall[i].pid, fake.ptraceSetRegsArgsForCall[i].regs
}

func (fake *FakeSyscall) PtraceSetRegsReturns(result1 error) {
	fake.PtraceSetRegsStub = nil
	fake.ptraceSetRegsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceSetRegsReturnsOnCall(i int, result1 error) {
	fake.PtraceSetRegsStub = nil
	if fake.ptraceSetRegsReturnsOnCall == nil {
		fake.ptraceSetRegsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ptraceSetRegsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceSetOptions(pid int, options int) (err error) {
	fake.ptraceSetOptionsMutex.Lock()
	ret, specificReturn := fake.ptraceSetOptionsReturnsOnCall[len(fake.ptraceSetOptionsArgsForCall)]
	fake.ptraceSetOptionsArgsForCall = append(fake.ptraceSetOptionsArgsForCall, struct {
		pid     int
		options int
	}{pid, options})
	fake.recordInvocation("PtraceSetOptions", []interface{}{pid, options})
	fake.ptraceSetOptionsMutex.Unlock()
	if fake.PtraceSetOptionsStub != nil {
		return fake.PtraceSetOptionsStub(pid, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ptraceSetOptionsReturns.result1
}

func (fake *FakeSyscall) PtraceSetOptionsCallCount() int {
	fake.ptraceSetOptionsMutex.RLock()
	defer fake.ptraceSetOptionsMutex.RUnlock()
	return len(fake.ptraceSetOptionsArgsForCall)
}

func (fake *FakeSyscall) PtraceSetOptionsArgsForCall(i int) (int, int) {
	fake.ptraceSetOptionsMutex.RLock()
	defer fake.ptraceSetOptionsMutex.RUnlock()
	return fake.ptraceSetOptionsArgsForCall[i].pid, fake.ptraceSetOptionsArgsForCall[i].options
}

func (fake *FakeSyscall) PtraceSetOptionsReturns(result1 error) {
	fake.PtraceSetOptionsStub = nil
	fake.ptraceSetOptionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceSetOptionsReturnsOnCall(i int, result1 error) {
	fake.PtraceSetOptionsStub = nil
	if fake.ptraceSetOptionsReturnsOnCall == nil {
		fake.ptraceSetOptionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ptraceSetOptionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceGetEventMsg(pid int) (msg uint, err error) {
	fake.ptraceGetEventMsgMutex.Lock()
	ret, specificReturn := fake.ptraceGetEventMsgReturnsOnCall[len(fake.ptraceGetEventMsgArgsForCall)]
	fake.ptraceGetEventMsgArgsForCall = append(fake.ptraceGetEventMsgArgsForCall, struct {
		pid int
	}{pid})
	fake.recordInvocation("PtraceGetEventMsg", []interface{}{pid})
	fake.ptraceGetEventMsgMutex.Unlock()
	if fake.PtraceGetEventMsgStub != nil {
		return fake.PtraceGetEventMsgStub(pid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.ptraceGetEventMsgReturns.result1, fake.ptraceGetEventMsgReturns.result2
}

func (fake *FakeSyscall) PtraceGetEventMsgCallCount() int {
	fake.ptraceGetEventMsgMutex.RLock()
	defer fake.ptraceGetEventMsgMutex.RUnlock()
	return len(fake.ptraceGetEventMsgArgsForCall)
}

func (fake *FakeSyscall) PtraceGetEventMsgArgsForCall(i int) int {
	fake.ptraceGetEventMsgMutex.RLock()
	defer fake.ptraceGetEventMsgMutex.RUnlock()
	return fake.ptraceGetEventMsgArgsForCall[i].pid
}

func (fake *FakeSyscall) PtraceGetEventMsgReturns(result1 uint, result2 error) {
	fake.PtraceGetEventMsgStub = nil
	fake.ptraceGetEventMsgReturns = struct {
		result1 uint
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PtraceGetEventMsgReturnsOnCall(i int, result1 uint, result2 error) {
	fake.PtraceGetEventMsgStub = nil
	if fake.ptraceGetEventMsgReturnsOnCall == nil {
		fake.ptraceGetEventMsgReturnsOnCall = make(map[int]struct {
			result1 uint
			result2 error
		})
	}
	fake.ptraceGetEventMsgReturnsOnCall[i] = struct {
		result1 uint
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PtraceCont(pid int, signal int) (err error) {
	fake.ptraceContMutex.Lock()
	ret, specificReturn := fake.ptraceContReturnsOnCall[len(fake.ptraceContArgsForCall)]
	fake.ptraceContArgsForCall = append(fake.ptraceContArgsForCall, struct {
		pid    int
		signal int
	}{pid, signal})
	fake.recordInvocation("PtraceCont", []interface{}{pid, signal})
	fake.ptraceContMutex.Unlock()
	if fake.PtraceContStub != nil {
		return fake.PtraceContStub(pid, signal)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ptraceContReturns.result1
}

func (fake *FakeSyscall) PtraceContCallCount() int {
	fake.ptraceContMutex.RLock()
	defer fake.ptraceContMutex.RUnlock()
	return len(fake.ptraceContArgsForCall)
}

func (fake *FakeSyscall) PtraceContArgsForCall(i int) (int, int) {
	fake.ptraceContMutex.RLock()
	defer fake.ptraceContMutex.RUnlock()
	return fake.ptraceContArgsForCall[i].pid, fake.ptraceContArgsForCall[i].signal
}

func (fake *FakeSyscall) PtraceContReturns(result1 error) {
	fake.PtraceContStub = nil
	fake.ptraceContReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceContReturnsOnCall(i int, result1 error) {
	fake.PtraceContStub = nil
	if fake.ptraceContReturnsOnCall == nil {
		fake.ptraceContReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ptraceContReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceSyscall(pid int, signal int) (err error) {
	fake.ptraceSyscallMutex.Lock()
	ret, specificReturn := fake.ptraceSyscallReturnsOnCall[len(fake.ptraceSyscallArgsForCall)]
	fake.ptraceSyscallArgsForCall = append(fake.ptraceSyscallArgsForCall, struct {
		pid    int
		signal int
	}{pid, signal})
	fake.recordInvocation("PtraceSyscall", []interface{}{pid, signal})
	fake.ptraceSyscallMutex.Unlock()
	if fake.PtraceSyscallStub != nil {
		return fake.PtraceSyscallStub(pid, signal)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ptraceSyscallReturns.result1
}

func (fake *FakeSyscall) PtraceSyscallCallCount() int {
	fake.ptraceSyscallMutex.RLock()
	defer fake.ptraceSyscallMutex.RUnlock()
	return len(fake.ptraceSyscallArgsForCall)
}

func (fake *FakeSyscall) PtraceSyscallArgsForCall(i int) (int, int) {
	fake.ptraceSyscallMutex.RLock()
	defer fake.ptraceSyscallMutex.RUnlock()
	return fake.ptraceSyscallArgsForCall[i].pid, fake.ptraceSyscallArgsForCall[i].signal
}

func (fake *FakeSyscall) PtraceSyscallReturns(result1 error) {
	fake.PtraceSyscallStub = nil
	fake.ptraceSyscallReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceSyscallReturnsOnCall(i int, result1 error) {
	fake.PtraceSyscallStub = nil
	if fake.ptraceSyscallReturnsOnCall == nil {
		fake.ptraceSyscallReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ptraceSyscallReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceSingleStep(pid int) (err error) {
	fake.ptraceSingleStepMutex.Lock()
	ret, specificReturn := fake.ptraceSingleStepReturnsOnCall[len(fake.ptraceSingleStepArgsForCall)]
	fake.ptraceSingleStepArgsForCall = append(fake.ptraceSingleStepArgsForCall, struct {
		pid int
	}{pid})
	fake.recordInvocation("PtraceSingleStep", []interface{}{pid})
	fake.ptraceSingleStepMutex.Unlock()
	if fake.PtraceSingleStepStub != nil {
		return fake.PtraceSingleStepStub(pid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ptraceSingleStepReturns.result1
}

func (fake *FakeSyscall) PtraceSingleStepCallCount() int {
	fake.ptraceSingleStepMutex.RLock()
	defer fake.ptraceSingleStepMutex.RUnlock()
	return len(fake.ptraceSingleStepArgsForCall)
}

func (fake *FakeSyscall) PtraceSingleStepArgsForCall(i int) int {
	fake.ptraceSingleStepMutex.RLock()
	defer fake.ptraceSingleStepMutex.RUnlock()
	return fake.ptraceSingleStepArgsForCall[i].pid
}

func (fake *FakeSyscall) PtraceSingleStepReturns(result1 error) {
	fake.PtraceSingleStepStub = nil
	fake.ptraceSingleStepReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PtraceSingleStepReturnsOnCall(i int, result1 error) {
	fake.PtraceSingleStepStub = nil
	if fake.ptraceSingleStepReturnsOnCall == nil {
		fake.ptraceSingleStepReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ptraceSingleStepReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Reboot(cmd int) (err error) {
	fake.rebootMutex.Lock()
	ret, specificReturn := fake.rebootReturnsOnCall[len(fake.rebootArgsForCall)]
	fake.rebootArgsForCall = append(fake.rebootArgsForCall, struct {
		cmd int
	}{cmd})
	fake.recordInvocation("Reboot", []interface{}{cmd})
	fake.rebootMutex.Unlock()
	if fake.RebootStub != nil {
		return fake.RebootStub(cmd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rebootReturns.result1
}

func (fake *FakeSyscall) RebootCallCount() int {
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	return len(fake.rebootArgsForCall)
}

func (fake *FakeSyscall) RebootArgsForCall(i int) int {
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	return fake.rebootArgsForCall[i].cmd
}

func (fake *FakeSyscall) RebootReturns(result1 error) {
	fake.RebootStub = nil
	fake.rebootReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RebootReturnsOnCall(i int, result1 error) {
	fake.RebootStub = nil
	if fake.rebootReturnsOnCall == nil {
		fake.rebootReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebootReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Mount(source string, target string, fstype string, flags uintptr, data string) (err error) {
	fake.mountMutex.Lock()
	ret, specificReturn := fake.mountReturnsOnCall[len(fake.mountArgsForCall)]
	fake.mountArgsForCall = append(fake.mountArgsForCall, struct {
		source string
		target string
		fstype string
		flags  uintptr
		data   string
	}{source, target, fstype, flags, data})
	fake.recordInvocation("Mount", []interface{}{source, target, fstype, flags, data})
	fake.mountMutex.Unlock()
	if fake.MountStub != nil {
		return fake.MountStub(source, target, fstype, flags, data)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mountReturns.result1
}

func (fake *FakeSyscall) MountCallCount() int {
	fake.mountMutex.RLock()
	defer fake.mountMutex.RUnlock()
	return len(fake.mountArgsForCall)
}

func (fake *FakeSyscall) MountArgsForCall(i int) (string, string, string, uintptr, string) {
	fake.mountMutex.RLock()
	defer fake.mountMutex.RUnlock()
	return fake.mountArgsForCall[i].source, fake.mountArgsForCall[i].target, fake.mountArgsForCall[i].fstype, fake.mountArgsForCall[i].flags, fake.mountArgsForCall[i].data
}

func (fake *FakeSyscall) MountReturns(result1 error) {
	fake.MountStub = nil
	fake.mountReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MountReturnsOnCall(i int, result1 error) {
	fake.MountStub = nil
	if fake.mountReturnsOnCall == nil {
		fake.mountReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mountReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Getpgrp() (pid int) {
	fake.getpgrpMutex.Lock()
	ret, specificReturn := fake.getpgrpReturnsOnCall[len(fake.getpgrpArgsForCall)]
	fake.getpgrpArgsForCall = append(fake.getpgrpArgsForCall, struct{}{})
	fake.recordInvocation("Getpgrp", []interface{}{})
	fake.getpgrpMutex.Unlock()
	if fake.GetpgrpStub != nil {
		return fake.GetpgrpStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getpgrpReturns.result1
}

func (fake *FakeSyscall) GetpgrpCallCount() int {
	fake.getpgrpMutex.RLock()
	defer fake.getpgrpMutex.RUnlock()
	return len(fake.getpgrpArgsForCall)
}

func (fake *FakeSyscall) GetpgrpReturns(result1 int) {
	fake.GetpgrpStub = nil
	fake.getpgrpReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) GetpgrpReturnsOnCall(i int, result1 int) {
	fake.GetpgrpStub = nil
	if fake.getpgrpReturnsOnCall == nil {
		fake.getpgrpReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getpgrpReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) Setuid(uid int) (err error) {
	fake.setuidMutex.Lock()
	ret, specificReturn := fake.setuidReturnsOnCall[len(fake.setuidArgsForCall)]
	fake.setuidArgsForCall = append(fake.setuidArgsForCall, struct {
		uid int
	}{uid})
	fake.recordInvocation("Setuid", []interface{}{uid})
	fake.setuidMutex.Unlock()
	if fake.SetuidStub != nil {
		return fake.SetuidStub(uid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setuidReturns.result1
}

func (fake *FakeSyscall) SetuidCallCount() int {
	fake.setuidMutex.RLock()
	defer fake.setuidMutex.RUnlock()
	return len(fake.setuidArgsForCall)
}

func (fake *FakeSyscall) SetuidArgsForCall(i int) int {
	fake.setuidMutex.RLock()
	defer fake.setuidMutex.RUnlock()
	return fake.setuidArgsForCall[i].uid
}

func (fake *FakeSyscall) SetuidReturns(result1 error) {
	fake.SetuidStub = nil
	fake.setuidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetuidReturnsOnCall(i int, result1 error) {
	fake.SetuidStub = nil
	if fake.setuidReturnsOnCall == nil {
		fake.setuidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setuidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setgid(gid int) (err error) {
	fake.setgidMutex.Lock()
	ret, specificReturn := fake.setgidReturnsOnCall[len(fake.setgidArgsForCall)]
	fake.setgidArgsForCall = append(fake.setgidArgsForCall, struct {
		gid int
	}{gid})
	fake.recordInvocation("Setgid", []interface{}{gid})
	fake.setgidMutex.Unlock()
	if fake.SetgidStub != nil {
		return fake.SetgidStub(gid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setgidReturns.result1
}

func (fake *FakeSyscall) SetgidCallCount() int {
	fake.setgidMutex.RLock()
	defer fake.setgidMutex.RUnlock()
	return len(fake.setgidArgsForCall)
}

func (fake *FakeSyscall) SetgidArgsForCall(i int) int {
	fake.setgidMutex.RLock()
	defer fake.setgidMutex.RUnlock()
	return fake.setgidArgsForCall[i].gid
}

func (fake *FakeSyscall) SetgidReturns(result1 error) {
	fake.SetgidStub = nil
	fake.setgidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetgidReturnsOnCall(i int, result1 error) {
	fake.SetgidStub = nil
	if fake.setgidReturnsOnCall == nil {
		fake.setgidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setgidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Pipe2(p []int, flags int) (err error) {
	var pCopy []int
	if p != nil {
		pCopy = make([]int, len(p))
		copy(pCopy, p)
	}
	fake.pipe2Mutex.Lock()
	ret, specificReturn := fake.pipe2ReturnsOnCall[len(fake.pipe2ArgsForCall)]
	fake.pipe2ArgsForCall = append(fake.pipe2ArgsForCall, struct {
		p     []int
		flags int
	}{pCopy, flags})
	fake.recordInvocation("Pipe2", []interface{}{pCopy, flags})
	fake.pipe2Mutex.Unlock()
	if fake.Pipe2Stub != nil {
		return fake.Pipe2Stub(p, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pipe2Returns.result1
}

func (fake *FakeSyscall) Pipe2CallCount() int {
	fake.pipe2Mutex.RLock()
	defer fake.pipe2Mutex.RUnlock()
	return len(fake.pipe2ArgsForCall)
}

func (fake *FakeSyscall) Pipe2ArgsForCall(i int) ([]int, int) {
	fake.pipe2Mutex.RLock()
	defer fake.pipe2Mutex.RUnlock()
	return fake.pipe2ArgsForCall[i].p, fake.pipe2ArgsForCall[i].flags
}

func (fake *FakeSyscall) Pipe2Returns(result1 error) {
	fake.Pipe2Stub = nil
	fake.pipe2Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Pipe2ReturnsOnCall(i int, result1 error) {
	fake.Pipe2Stub = nil
	if fake.pipe2ReturnsOnCall == nil {
		fake.pipe2ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pipe2ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Getrlimit(resource int, rlim *syscall.Rlimit) (err error) {
	fake.getrlimitMutex.Lock()
	ret, specificReturn := fake.getrlimitReturnsOnCall[len(fake.getrlimitArgsForCall)]
	fake.getrlimitArgsForCall = append(fake.getrlimitArgsForCall, struct {
		resource int
		rlim     *syscall.Rlimit
	}{resource, rlim})
	fake.recordInvocation("Getrlimit", []interface{}{resource, rlim})
	fake.getrlimitMutex.Unlock()
	if fake.GetrlimitStub != nil {
		return fake.GetrlimitStub(resource, rlim)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getrlimitReturns.result1
}

func (fake *FakeSyscall) GetrlimitCallCount() int {
	fake.getrlimitMutex.RLock()
	defer fake.getrlimitMutex.RUnlock()
	return len(fake.getrlimitArgsForCall)
}

func (fake *FakeSyscall) GetrlimitArgsForCall(i int) (int, *syscall.Rlimit) {
	fake.getrlimitMutex.RLock()
	defer fake.getrlimitMutex.RUnlock()
	return fake.getrlimitArgsForCall[i].resource, fake.getrlimitArgsForCall[i].rlim
}

func (fake *FakeSyscall) GetrlimitReturns(result1 error) {
	fake.GetrlimitStub = nil
	fake.getrlimitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetrlimitReturnsOnCall(i int, result1 error) {
	fake.GetrlimitStub = nil
	if fake.getrlimitReturnsOnCall == nil {
		fake.getrlimitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getrlimitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setrlimit(resource int, rlim *syscall.Rlimit) (err error) {
	fake.setrlimitMutex.Lock()
	ret, specificReturn := fake.setrlimitReturnsOnCall[len(fake.setrlimitArgsForCall)]
	fake.setrlimitArgsForCall = append(fake.setrlimitArgsForCall, struct {
		resource int
		rlim     *syscall.Rlimit
	}{resource, rlim})
	fake.recordInvocation("Setrlimit", []interface{}{resource, rlim})
	fake.setrlimitMutex.Unlock()
	if fake.SetrlimitStub != nil {
		return fake.SetrlimitStub(resource, rlim)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setrlimitReturns.result1
}

func (fake *FakeSyscall) SetrlimitCallCount() int {
	fake.setrlimitMutex.RLock()
	defer fake.setrlimitMutex.RUnlock()
	return len(fake.setrlimitArgsForCall)
}

func (fake *FakeSyscall) SetrlimitArgsForCall(i int) (int, *syscall.Rlimit) {
	fake.setrlimitMutex.RLock()
	defer fake.setrlimitMutex.RUnlock()
	return fake.setrlimitArgsForCall[i].resource, fake.setrlimitArgsForCall[i].rlim
}

func (fake *FakeSyscall) SetrlimitReturns(result1 error) {
	fake.SetrlimitStub = nil
	fake.setrlimitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetrlimitReturnsOnCall(i int, result1 error) {
	fake.SetrlimitStub = nil
	if fake.setrlimitReturnsOnCall == nil {
		fake.setrlimitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setrlimitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fstatfs(fd int, buf *syscall.Statfs_t) (err error) {
	fake.fstatfsMutex.Lock()
	ret, specificReturn := fake.fstatfsReturnsOnCall[len(fake.fstatfsArgsForCall)]
	fake.fstatfsArgsForCall = append(fake.fstatfsArgsForCall, struct {
		fd  int
		buf *syscall.Statfs_t
	}{fd, buf})
	fake.recordInvocation("Fstatfs", []interface{}{fd, buf})
	fake.fstatfsMutex.Unlock()
	if fake.FstatfsStub != nil {
		return fake.FstatfsStub(fd, buf)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fstatfsReturns.result1
}

func (fake *FakeSyscall) FstatfsCallCount() int {
	fake.fstatfsMutex.RLock()
	defer fake.fstatfsMutex.RUnlock()
	return len(fake.fstatfsArgsForCall)
}

func (fake *FakeSyscall) FstatfsArgsForCall(i int) (int, *syscall.Statfs_t) {
	fake.fstatfsMutex.RLock()
	defer fake.fstatfsMutex.RUnlock()
	return fake.fstatfsArgsForCall[i].fd, fake.fstatfsArgsForCall[i].buf
}

func (fake *FakeSyscall) FstatfsReturns(result1 error) {
	fake.FstatfsStub = nil
	fake.fstatfsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FstatfsReturnsOnCall(i int, result1 error) {
	fake.FstatfsStub = nil
	if fake.fstatfsReturnsOnCall == nil {
		fake.fstatfsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fstatfsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Statfs(path string, buf *syscall.Statfs_t) (err error) {
	fake.statfsMutex.Lock()
	ret, specificReturn := fake.statfsReturnsOnCall[len(fake.statfsArgsForCall)]
	fake.statfsArgsForCall = append(fake.statfsArgsForCall, struct {
		path string
		buf  *syscall.Statfs_t
	}{path, buf})
	fake.recordInvocation("Statfs", []interface{}{path, buf})
	fake.statfsMutex.Unlock()
	if fake.StatfsStub != nil {
		return fake.StatfsStub(path, buf)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.statfsReturns.result1
}

func (fake *FakeSyscall) StatfsCallCount() int {
	fake.statfsMutex.RLock()
	defer fake.statfsMutex.RUnlock()
	return len(fake.statfsArgsForCall)
}

func (fake *FakeSyscall) StatfsArgsForCall(i int) (string, *syscall.Statfs_t) {
	fake.statfsMutex.RLock()
	defer fake.statfsMutex.RUnlock()
	return fake.statfsArgsForCall[i].path, fake.statfsArgsForCall[i].buf
}

func (fake *FakeSyscall) StatfsReturns(result1 error) {
	fake.StatfsStub = nil
	fake.statfsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) StatfsReturnsOnCall(i int, result1 error) {
	fake.StatfsStub = nil
	if fake.statfsReturnsOnCall == nil {
		fake.statfsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.statfsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Time(t *syscall.Time_t) (tt syscall.Time_t, err error) {
	fake.timeMutex.Lock()
	ret, specificReturn := fake.timeReturnsOnCall[len(fake.timeArgsForCall)]
	fake.timeArgsForCall = append(fake.timeArgsForCall, struct {
		t *syscall.Time_t
	}{t})
	fake.recordInvocation("Time", []interface{}{t})
	fake.timeMutex.Unlock()
	if fake.TimeStub != nil {
		return fake.TimeStub(t)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.timeReturns.result1, fake.timeReturns.result2
}

func (fake *FakeSyscall) TimeCallCount() int {
	fake.timeMutex.RLock()
	defer fake.timeMutex.RUnlock()
	return len(fake.timeArgsForCall)
}

func (fake *FakeSyscall) TimeArgsForCall(i int) *syscall.Time_t {
	fake.timeMutex.RLock()
	defer fake.timeMutex.RUnlock()
	return fake.timeArgsForCall[i].t
}

func (fake *FakeSyscall) TimeReturns(result1 syscall.Time_t, result2 error) {
	fake.TimeStub = nil
	fake.timeReturns = struct {
		result1 syscall.Time_t
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) TimeReturnsOnCall(i int, result1 syscall.Time_t, result2 error) {
	fake.TimeStub = nil
	if fake.timeReturnsOnCall == nil {
		fake.timeReturnsOnCall = make(map[int]struct {
			result1 syscall.Time_t
			result2 error
		})
	}
	fake.timeReturnsOnCall[i] = struct {
		result1 syscall.Time_t
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) InotifyInit() (fd int, err error) {
	fake.inotifyInitMutex.Lock()
	ret, specificReturn := fake.inotifyInitReturnsOnCall[len(fake.inotifyInitArgsForCall)]
	fake.inotifyInitArgsForCall = append(fake.inotifyInitArgsForCall, struct{}{})
	fake.recordInvocation("InotifyInit", []interface{}{})
	fake.inotifyInitMutex.Unlock()
	if fake.InotifyInitStub != nil {
		return fake.InotifyInitStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.inotifyInitReturns.result1, fake.inotifyInitReturns.result2
}

func (fake *FakeSyscall) InotifyInitCallCount() int {
	fake.inotifyInitMutex.RLock()
	defer fake.inotifyInitMutex.RUnlock()
	return len(fake.inotifyInitArgsForCall)
}

func (fake *FakeSyscall) InotifyInitReturns(result1 int, result2 error) {
	fake.InotifyInitStub = nil
	fake.inotifyInitReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) InotifyInitReturnsOnCall(i int, result1 int, result2 error) {
	fake.InotifyInitStub = nil
	if fake.inotifyInitReturnsOnCall == nil {
		fake.inotifyInitReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.inotifyInitReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Ioperm(from int, num int, on int) (err error) {
	fake.iopermMutex.Lock()
	ret, specificReturn := fake.iopermReturnsOnCall[len(fake.iopermArgsForCall)]
	fake.iopermArgsForCall = append(fake.iopermArgsForCall, struct {
		from int
		num  int
		on   int
	}{from, num, on})
	fake.recordInvocation("Ioperm", []interface{}{from, num, on})
	fake.iopermMutex.Unlock()
	if fake.IopermStub != nil {
		return fake.IopermStub(from, num, on)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iopermReturns.result1
}

func (fake *FakeSyscall) IopermCallCount() int {
	fake.iopermMutex.RLock()
	defer fake.iopermMutex.RUnlock()
	return len(fake.iopermArgsForCall)
}

func (fake *FakeSyscall) IopermArgsForCall(i int) (int, int, int) {
	fake.iopermMutex.RLock()
	defer fake.iopermMutex.RUnlock()
	return fake.iopermArgsForCall[i].from, fake.iopermArgsForCall[i].num, fake.iopermArgsForCall[i].on
}

func (fake *FakeSyscall) IopermReturns(result1 error) {
	fake.IopermStub = nil
	fake.iopermReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) IopermReturnsOnCall(i int, result1 error) {
	fake.IopermStub = nil
	if fake.iopermReturnsOnCall == nil {
		fake.iopermReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.iopermReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Iopl(level int) (err error) {
	fake.ioplMutex.Lock()
	ret, specificReturn := fake.ioplReturnsOnCall[len(fake.ioplArgsForCall)]
	fake.ioplArgsForCall = append(fake.ioplArgsForCall, struct {
		level int
	}{level})
	fake.recordInvocation("Iopl", []interface{}{level})
	fake.ioplMutex.Unlock()
	if fake.IoplStub != nil {
		return fake.IoplStub(level)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ioplReturns.result1
}

func (fake *FakeSyscall) IoplCallCount() int {
	fake.ioplMutex.RLock()
	defer fake.ioplMutex.RUnlock()
	return len(fake.ioplArgsForCall)
}

func (fake *FakeSyscall) IoplArgsForCall(i int) int {
	fake.ioplMutex.RLock()
	defer fake.ioplMutex.RUnlock()
	return fake.ioplArgsForCall[i].level
}

func (fake *FakeSyscall) IoplReturns(result1 error) {
	fake.IoplStub = nil
	fake.ioplReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) IoplReturnsOnCall(i int, result1 error) {
	fake.IoplStub = nil
	if fake.ioplReturnsOnCall == nil {
		fake.ioplReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ioplReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RawSyscall(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr) (r1, r2 uintptr, err syscall.Errno) {
	fake.rawSyscallMutex.Lock()
	ret, specificReturn := fake.rawSyscallReturnsOnCall[len(fake.rawSyscallArgsForCall)]
	fake.rawSyscallArgsForCall = append(fake.rawSyscallArgsForCall, struct {
		trap uintptr
		a1   uintptr
		a2   uintptr
		a3   uintptr
	}{trap, a1, a2, a3})
	fake.recordInvocation("RawSyscall", []interface{}{trap, a1, a2, a3})
	fake.rawSyscallMutex.Unlock()
	if fake.RawSyscallStub != nil {
		return fake.RawSyscallStub(trap, a1, a2, a3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.rawSyscallReturns.result1, fake.rawSyscallReturns.result2, fake.rawSyscallReturns.result3
}

func (fake *FakeSyscall) RawSyscallCallCount() int {
	fake.rawSyscallMutex.RLock()
	defer fake.rawSyscallMutex.RUnlock()
	return len(fake.rawSyscallArgsForCall)
}

func (fake *FakeSyscall) RawSyscallArgsForCall(i int) (uintptr, uintptr, uintptr, uintptr) {
	fake.rawSyscallMutex.RLock()
	defer fake.rawSyscallMutex.RUnlock()
	return fake.rawSyscallArgsForCall[i].trap, fake.rawSyscallArgsForCall[i].a1, fake.rawSyscallArgsForCall[i].a2, fake.rawSyscallArgsForCall[i].a3
}

func (fake *FakeSyscall) RawSyscallReturns(result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.RawSyscallStub = nil
	fake.rawSyscallReturns = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) RawSyscallReturnsOnCall(i int, result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.RawSyscallStub = nil
	if fake.rawSyscallReturnsOnCall == nil {
		fake.rawSyscallReturnsOnCall = make(map[int]struct {
			result1 uintptr
			result2 uintptr
			result3 syscall.Errno
		})
	}
	fake.rawSyscallReturnsOnCall[i] = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) RawSyscall6(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) (r1, r2 uintptr, err syscall.Errno) {
	fake.rawSyscall6Mutex.Lock()
	ret, specificReturn := fake.rawSyscall6ReturnsOnCall[len(fake.rawSyscall6ArgsForCall)]
	fake.rawSyscall6ArgsForCall = append(fake.rawSyscall6ArgsForCall, struct {
		trap uintptr
		a1   uintptr
		a2   uintptr
		a3   uintptr
		a4   uintptr
		a5   uintptr
		a6   uintptr
	}{trap, a1, a2, a3, a4, a5, a6})
	fake.recordInvocation("RawSyscall6", []interface{}{trap, a1, a2, a3, a4, a5, a6})
	fake.rawSyscall6Mutex.Unlock()
	if fake.RawSyscall6Stub != nil {
		return fake.RawSyscall6Stub(trap, a1, a2, a3, a4, a5, a6)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.rawSyscall6Returns.result1, fake.rawSyscall6Returns.result2, fake.rawSyscall6Returns.result3
}

func (fake *FakeSyscall) RawSyscall6CallCount() int {
	fake.rawSyscall6Mutex.RLock()
	defer fake.rawSyscall6Mutex.RUnlock()
	return len(fake.rawSyscall6ArgsForCall)
}

func (fake *FakeSyscall) RawSyscall6ArgsForCall(i int) (uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) {
	fake.rawSyscall6Mutex.RLock()
	defer fake.rawSyscall6Mutex.RUnlock()
	return fake.rawSyscall6ArgsForCall[i].trap, fake.rawSyscall6ArgsForCall[i].a1, fake.rawSyscall6ArgsForCall[i].a2, fake.rawSyscall6ArgsForCall[i].a3, fake.rawSyscall6ArgsForCall[i].a4, fake.rawSyscall6ArgsForCall[i].a5, fake.rawSyscall6ArgsForCall[i].a6
}

func (fake *FakeSyscall) RawSyscall6Returns(result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.RawSyscall6Stub = nil
	fake.rawSyscall6Returns = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) RawSyscall6ReturnsOnCall(i int, result1 uintptr, result2 uintptr, result3 syscall.Errno) {
	fake.RawSyscall6Stub = nil
	if fake.rawSyscall6ReturnsOnCall == nil {
		fake.rawSyscall6ReturnsOnCall = make(map[int]struct {
			result1 uintptr
			result2 uintptr
			result3 syscall.Errno
		})
	}
	fake.rawSyscall6ReturnsOnCall[i] = struct {
		result1 uintptr
		result2 uintptr
		result3 syscall.Errno
	}{result1, result2, result3}
}

func (fake *FakeSyscall) Getegid() int {
	fake.getegidMutex.Lock()
	ret, specificReturn := fake.getegidReturnsOnCall[len(fake.getegidArgsForCall)]
	fake.getegidArgsForCall = append(fake.getegidArgsForCall, struct{}{})
	fake.recordInvocation("Getegid", []interface{}{})
	fake.getegidMutex.Unlock()
	if fake.GetegidStub != nil {
		return fake.GetegidStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getegidReturns.result1
}

func (fake *FakeSyscall) GetegidCallCount() int {
	fake.getegidMutex.RLock()
	defer fake.getegidMutex.RUnlock()
	return len(fake.getegidArgsForCall)
}

func (fake *FakeSyscall) GetegidReturns(result1 int) {
	fake.GetegidStub = nil
	fake.getegidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) GetegidReturnsOnCall(i int, result1 int) {
	fake.GetegidStub = nil
	if fake.getegidReturnsOnCall == nil {
		fake.getegidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getegidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) Geteuid() int {
	fake.geteuidMutex.Lock()
	ret, specificReturn := fake.geteuidReturnsOnCall[len(fake.geteuidArgsForCall)]
	fake.geteuidArgsForCall = append(fake.geteuidArgsForCall, struct{}{})
	fake.recordInvocation("Geteuid", []interface{}{})
	fake.geteuidMutex.Unlock()
	if fake.GeteuidStub != nil {
		return fake.GeteuidStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.geteuidReturns.result1
}

func (fake *FakeSyscall) GeteuidCallCount() int {
	fake.geteuidMutex.RLock()
	defer fake.geteuidMutex.RUnlock()
	return len(fake.geteuidArgsForCall)
}

func (fake *FakeSyscall) GeteuidReturns(result1 int) {
	fake.GeteuidStub = nil
	fake.geteuidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) GeteuidReturnsOnCall(i int, result1 int) {
	fake.GeteuidStub = nil
	if fake.geteuidReturnsOnCall == nil {
		fake.geteuidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.geteuidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) Getgid() int {
	fake.getgidMutex.Lock()
	ret, specificReturn := fake.getgidReturnsOnCall[len(fake.getgidArgsForCall)]
	fake.getgidArgsForCall = append(fake.getgidArgsForCall, struct{}{})
	fake.recordInvocation("Getgid", []interface{}{})
	fake.getgidMutex.Unlock()
	if fake.GetgidStub != nil {
		return fake.GetgidStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getgidReturns.result1
}

func (fake *FakeSyscall) GetgidCallCount() int {
	fake.getgidMutex.RLock()
	defer fake.getgidMutex.RUnlock()
	return len(fake.getgidArgsForCall)
}

func (fake *FakeSyscall) GetgidReturns(result1 int) {
	fake.GetgidStub = nil
	fake.getgidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) GetgidReturnsOnCall(i int, result1 int) {
	fake.GetgidStub = nil
	if fake.getgidReturnsOnCall == nil {
		fake.getgidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getgidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) Getppid() int {
	fake.getppidMutex.Lock()
	ret, specificReturn := fake.getppidReturnsOnCall[len(fake.getppidArgsForCall)]
	fake.getppidArgsForCall = append(fake.getppidArgsForCall, struct{}{})
	fake.recordInvocation("Getppid", []interface{}{})
	fake.getppidMutex.Unlock()
	if fake.GetppidStub != nil {
		return fake.GetppidStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getppidReturns.result1
}

func (fake *FakeSyscall) GetppidCallCount() int {
	fake.getppidMutex.RLock()
	defer fake.getppidMutex.RUnlock()
	return len(fake.getppidArgsForCall)
}

func (fake *FakeSyscall) GetppidReturns(result1 int) {
	fake.GetppidStub = nil
	fake.getppidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) GetppidReturnsOnCall(i int, result1 int) {
	fake.GetppidStub = nil
	if fake.getppidReturnsOnCall == nil {
		fake.getppidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getppidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) Getpid() int {
	fake.getpidMutex.Lock()
	ret, specificReturn := fake.getpidReturnsOnCall[len(fake.getpidArgsForCall)]
	fake.getpidArgsForCall = append(fake.getpidArgsForCall, struct{}{})
	fake.recordInvocation("Getpid", []interface{}{})
	fake.getpidMutex.Unlock()
	if fake.GetpidStub != nil {
		return fake.GetpidStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getpidReturns.result1
}

func (fake *FakeSyscall) GetpidCallCount() int {
	fake.getpidMutex.RLock()
	defer fake.getpidMutex.RUnlock()
	return len(fake.getpidArgsForCall)
}

func (fake *FakeSyscall) GetpidReturns(result1 int) {
	fake.GetpidStub = nil
	fake.getpidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) GetpidReturnsOnCall(i int, result1 int) {
	fake.GetpidStub = nil
	if fake.getpidReturnsOnCall == nil {
		fake.getpidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getpidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) Getuid() int {
	fake.getuidMutex.Lock()
	ret, specificReturn := fake.getuidReturnsOnCall[len(fake.getuidArgsForCall)]
	fake.getuidArgsForCall = append(fake.getuidArgsForCall, struct{}{})
	fake.recordInvocation("Getuid", []interface{}{})
	fake.getuidMutex.Unlock()
	if fake.GetuidStub != nil {
		return fake.GetuidStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getuidReturns.result1
}

func (fake *FakeSyscall) GetuidCallCount() int {
	fake.getuidMutex.RLock()
	defer fake.getuidMutex.RUnlock()
	return len(fake.getuidArgsForCall)
}

func (fake *FakeSyscall) GetuidReturns(result1 int) {
	fake.GetuidStub = nil
	fake.getuidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) GetuidReturnsOnCall(i int, result1 int) {
	fake.GetuidStub = nil
	if fake.getuidReturnsOnCall == nil {
		fake.getuidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getuidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	fake.sendfileMutex.Lock()
	ret, specificReturn := fake.sendfileReturnsOnCall[len(fake.sendfileArgsForCall)]
	fake.sendfileArgsForCall = append(fake.sendfileArgsForCall, struct {
		outfd  int
		infd   int
		offset *int64
		count  int
	}{outfd, infd, offset, count})
	fake.recordInvocation("Sendfile", []interface{}{outfd, infd, offset, count})
	fake.sendfileMutex.Unlock()
	if fake.SendfileStub != nil {
		return fake.SendfileStub(outfd, infd, offset, count)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.sendfileReturns.result1, fake.sendfileReturns.result2
}

func (fake *FakeSyscall) SendfileCallCount() int {
	fake.sendfileMutex.RLock()
	defer fake.sendfileMutex.RUnlock()
	return len(fake.sendfileArgsForCall)
}

func (fake *FakeSyscall) SendfileArgsForCall(i int) (int, int, *int64, int) {
	fake.sendfileMutex.RLock()
	defer fake.sendfileMutex.RUnlock()
	return fake.sendfileArgsForCall[i].outfd, fake.sendfileArgsForCall[i].infd, fake.sendfileArgsForCall[i].offset, fake.sendfileArgsForCall[i].count
}

func (fake *FakeSyscall) SendfileReturns(result1 int, result2 error) {
	fake.SendfileStub = nil
	fake.sendfileReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SendfileReturnsOnCall(i int, result1 int, result2 error) {
	fake.SendfileStub = nil
	if fake.sendfileReturnsOnCall == nil {
		fake.sendfileReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.sendfileReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Getdirentries(fd int, buf []byte, basep *uintptr) (n int, err error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.getdirentriesMutex.Lock()
	ret, specificReturn := fake.getdirentriesReturnsOnCall[len(fake.getdirentriesArgsForCall)]
	fake.getdirentriesArgsForCall = append(fake.getdirentriesArgsForCall, struct {
		fd    int
		buf   []byte
		basep *uintptr
	}{fd, bufCopy, basep})
	fake.recordInvocation("Getdirentries", []interface{}{fd, bufCopy, basep})
	fake.getdirentriesMutex.Unlock()
	if fake.GetdirentriesStub != nil {
		return fake.GetdirentriesStub(fd, buf, basep)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getdirentriesReturns.result1, fake.getdirentriesReturns.result2
}

func (fake *FakeSyscall) GetdirentriesCallCount() int {
	fake.getdirentriesMutex.RLock()
	defer fake.getdirentriesMutex.RUnlock()
	return len(fake.getdirentriesArgsForCall)
}

func (fake *FakeSyscall) GetdirentriesArgsForCall(i int) (int, []byte, *uintptr) {
	fake.getdirentriesMutex.RLock()
	defer fake.getdirentriesMutex.RUnlock()
	return fake.getdirentriesArgsForCall[i].fd, fake.getdirentriesArgsForCall[i].buf, fake.getdirentriesArgsForCall[i].basep
}

func (fake *FakeSyscall) GetdirentriesReturns(result1 int, result2 error) {
	fake.GetdirentriesStub = nil
	fake.getdirentriesReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetdirentriesReturnsOnCall(i int, result1 int, result2 error) {
	fake.GetdirentriesStub = nil
	if fake.getdirentriesReturnsOnCall == nil {
		fake.getdirentriesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getdirentriesReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) NewError(s string) error {
	fake.newErrorMutex.Lock()
	ret, specificReturn := fake.newErrorReturnsOnCall[len(fake.newErrorArgsForCall)]
	fake.newErrorArgsForCall = append(fake.newErrorArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("NewError", []interface{}{s})
	fake.newErrorMutex.Unlock()
	if fake.NewErrorStub != nil {
		return fake.NewErrorStub(s)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newErrorReturns.result1
}

func (fake *FakeSyscall) NewErrorCallCount() int {
	fake.newErrorMutex.RLock()
	defer fake.newErrorMutex.RUnlock()
	return len(fake.newErrorArgsForCall)
}

func (fake *FakeSyscall) NewErrorArgsForCall(i int) string {
	fake.newErrorMutex.RLock()
	defer fake.newErrorMutex.RUnlock()
	return fake.newErrorArgsForCall[i].s
}

func (fake *FakeSyscall) NewErrorReturns(result1 error) {
	fake.NewErrorStub = nil
	fake.newErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) NewErrorReturnsOnCall(i int, result1 error) {
	fake.NewErrorStub = nil
	if fake.newErrorReturnsOnCall == nil {
		fake.newErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.newErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Exit(code int) {
	fake.exitMutex.Lock()
	fake.exitArgsForCall = append(fake.exitArgsForCall, struct {
		code int
	}{code})
	fake.recordInvocation("Exit", []interface{}{code})
	fake.exitMutex.Unlock()
	if fake.ExitStub != nil {
		fake.ExitStub(code)
	}
}

func (fake *FakeSyscall) ExitCallCount() int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return len(fake.exitArgsForCall)
}

func (fake *FakeSyscall) ExitArgsForCall(i int) int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return fake.exitArgsForCall[i].code
}

func (fake *FakeSyscall) Fd2path(fd int) (path string, err error) {
	fake.fd2pathMutex.Lock()
	ret, specificReturn := fake.fd2pathReturnsOnCall[len(fake.fd2pathArgsForCall)]
	fake.fd2pathArgsForCall = append(fake.fd2pathArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("Fd2path", []interface{}{fd})
	fake.fd2pathMutex.Unlock()
	if fake.Fd2pathStub != nil {
		return fake.Fd2pathStub(fd)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fd2pathReturns.result1, fake.fd2pathReturns.result2
}

func (fake *FakeSyscall) Fd2pathCallCount() int {
	fake.fd2pathMutex.RLock()
	defer fake.fd2pathMutex.RUnlock()
	return len(fake.fd2pathArgsForCall)
}

func (fake *FakeSyscall) Fd2pathArgsForCall(i int) int {
	fake.fd2pathMutex.RLock()
	defer fake.fd2pathMutex.RUnlock()
	return fake.fd2pathArgsForCall[i].fd
}

func (fake *FakeSyscall) Fd2pathReturns(result1 string, result2 error) {
	fake.Fd2pathStub = nil
	fake.fd2pathReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Fd2pathReturnsOnCall(i int, result1 string, result2 error) {
	fake.Fd2pathStub = nil
	if fake.fd2pathReturnsOnCall == nil {
		fake.fd2pathReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.fd2pathReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Await(w *syscall.Waitmsg) (err error) {
	fake.awaitMutex.Lock()
	ret, specificReturn := fake.awaitReturnsOnCall[len(fake.awaitArgsForCall)]
	fake.awaitArgsForCall = append(fake.awaitArgsForCall, struct {
		w *syscall.Waitmsg
	}{w})
	fake.recordInvocation("Await", []interface{}{w})
	fake.awaitMutex.Unlock()
	if fake.AwaitStub != nil {
		return fake.AwaitStub(w)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.awaitReturns.result1
}

func (fake *FakeSyscall) AwaitCallCount() int {
	fake.awaitMutex.RLock()
	defer fake.awaitMutex.RUnlock()
	return len(fake.awaitArgsForCall)
}

func (fake *FakeSyscall) AwaitArgsForCall(i int) *syscall.Waitmsg {
	fake.awaitMutex.RLock()
	defer fake.awaitMutex.RUnlock()
	return fake.awaitArgsForCall[i].w
}

func (fake *FakeSyscall) AwaitReturns(result1 error) {
	fake.AwaitStub = nil
	fake.awaitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) AwaitReturnsOnCall(i int, result1 error) {
	fake.AwaitStub = nil
	if fake.awaitReturnsOnCall == nil {
		fake.awaitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.awaitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Unmount(name string, old string) (err error) {
	fake.unmountMutex.Lock()
	ret, specificReturn := fake.unmountReturnsOnCall[len(fake.unmountArgsForCall)]
	fake.unmountArgsForCall = append(fake.unmountArgsForCall, struct {
		name string
		old  string
	}{name, old})
	fake.recordInvocation("Unmount", []interface{}{name, old})
	fake.unmountMutex.Unlock()
	if fake.UnmountStub != nil {
		return fake.UnmountStub(name, old)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unmountReturns.result1
}

func (fake *FakeSyscall) UnmountCallCount() int {
	fake.unmountMutex.RLock()
	defer fake.unmountMutex.RUnlock()
	return len(fake.unmountArgsForCall)
}

func (fake *FakeSyscall) UnmountArgsForCall(i int) (string, string) {
	fake.unmountMutex.RLock()
	defer fake.unmountMutex.RUnlock()
	return fake.unmountArgsForCall[i].name, fake.unmountArgsForCall[i].old
}

func (fake *FakeSyscall) UnmountReturns(result1 error) {
	fake.UnmountStub = nil
	fake.unmountReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UnmountReturnsOnCall(i int, result1 error) {
	fake.UnmountStub = nil
	if fake.unmountReturnsOnCall == nil {
		fake.unmountReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unmountReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) NsecToTimeval(nsec int64) (tv syscall.Timeval) {
	fake.nsecToTimevalMutex.Lock()
	ret, specificReturn := fake.nsecToTimevalReturnsOnCall[len(fake.nsecToTimevalArgsForCall)]
	fake.nsecToTimevalArgsForCall = append(fake.nsecToTimevalArgsForCall, struct {
		nsec int64
	}{nsec})
	fake.recordInvocation("NsecToTimeval", []interface{}{nsec})
	fake.nsecToTimevalMutex.Unlock()
	if fake.NsecToTimevalStub != nil {
		return fake.NsecToTimevalStub(nsec)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nsecToTimevalReturns.result1
}

func (fake *FakeSyscall) NsecToTimevalCallCount() int {
	fake.nsecToTimevalMutex.RLock()
	defer fake.nsecToTimevalMutex.RUnlock()
	return len(fake.nsecToTimevalArgsForCall)
}

func (fake *FakeSyscall) NsecToTimevalArgsForCall(i int) int64 {
	fake.nsecToTimevalMutex.RLock()
	defer fake.nsecToTimevalMutex.RUnlock()
	return fake.nsecToTimevalArgsForCall[i].nsec
}

func (fake *FakeSyscall) NsecToTimevalReturns(result1 syscall.Timeval) {
	fake.NsecToTimevalStub = nil
	fake.nsecToTimevalReturns = struct {
		result1 syscall.Timeval
	}{result1}
}

func (fake *FakeSyscall) NsecToTimevalReturnsOnCall(i int, result1 syscall.Timeval) {
	fake.NsecToTimevalStub = nil
	if fake.nsecToTimevalReturnsOnCall == nil {
		fake.nsecToTimevalReturnsOnCall = make(map[int]struct {
			result1 syscall.Timeval
		})
	}
	fake.nsecToTimevalReturnsOnCall[i] = struct {
		result1 syscall.Timeval
	}{result1}
}

func (fake *FakeSyscall) Create(path string, mode int, perm uint32) (fd int, err error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		path string
		mode int
		perm uint32
	}{path, mode, perm})
	fake.recordInvocation("Create", []interface{}{path, mode, perm})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(path, mode, perm)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createReturns.result1, fake.createReturns.result2
}

func (fake *FakeSyscall) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeSyscall) CreateArgsForCall(i int) (string, int, uint32) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].path, fake.createArgsForCall[i].mode, fake.createArgsForCall[i].perm
}

func (fake *FakeSyscall) CreateReturns(result1 int, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CreateReturnsOnCall(i int, result1 int, result2 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Remove(path string) error {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("Remove", []interface{}{path})
	fake.removeMutex.Unlock()
	if fake.RemoveStub != nil {
		return fake.RemoveStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeReturns.result1
}

func (fake *FakeSyscall) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeSyscall) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return fake.removeArgsForCall[i].path
}

func (fake *FakeSyscall) RemoveReturns(result1 error) {
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RemoveReturnsOnCall(i int, result1 error) {
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Wstat(path string, edir []byte) (err error) {
	var edirCopy []byte
	if edir != nil {
		edirCopy = make([]byte, len(edir))
		copy(edirCopy, edir)
	}
	fake.wstatMutex.Lock()
	ret, specificReturn := fake.wstatReturnsOnCall[len(fake.wstatArgsForCall)]
	fake.wstatArgsForCall = append(fake.wstatArgsForCall, struct {
		path string
		edir []byte
	}{path, edirCopy})
	fake.recordInvocation("Wstat", []interface{}{path, edirCopy})
	fake.wstatMutex.Unlock()
	if fake.WstatStub != nil {
		return fake.WstatStub(path, edir)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.wstatReturns.result1
}

func (fake *FakeSyscall) WstatCallCount() int {
	fake.wstatMutex.RLock()
	defer fake.wstatMutex.RUnlock()
	return len(fake.wstatArgsForCall)
}

func (fake *FakeSyscall) WstatArgsForCall(i int) (string, []byte) {
	fake.wstatMutex.RLock()
	defer fake.wstatMutex.RUnlock()
	return fake.wstatArgsForCall[i].path, fake.wstatArgsForCall[i].edir
}

func (fake *FakeSyscall) WstatReturns(result1 error) {
	fake.WstatStub = nil
	fake.wstatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WstatReturnsOnCall(i int, result1 error) {
	fake.WstatStub = nil
	if fake.wstatReturnsOnCall == nil {
		fake.wstatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.wstatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Gethostname() (name string, err error) {
	fake.gethostnameMutex.Lock()
	ret, specificReturn := fake.gethostnameReturnsOnCall[len(fake.gethostnameArgsForCall)]
	fake.gethostnameArgsForCall = append(fake.gethostnameArgsForCall, struct{}{})
	fake.recordInvocation("Gethostname", []interface{}{})
	fake.gethostnameMutex.Unlock()
	if fake.GethostnameStub != nil {
		return fake.GethostnameStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.gethostnameReturns.result1, fake.gethostnameReturns.result2
}

func (fake *FakeSyscall) GethostnameCallCount() int {
	fake.gethostnameMutex.RLock()
	defer fake.gethostnameMutex.RUnlock()
	return len(fake.gethostnameArgsForCall)
}

func (fake *FakeSyscall) GethostnameReturns(result1 string, result2 error) {
	fake.GethostnameStub = nil
	fake.gethostnameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GethostnameReturnsOnCall(i int, result1 string, result2 error) {
	fake.GethostnameStub = nil
	if fake.gethostnameReturnsOnCall == nil {
		fake.gethostnameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.gethostnameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Getexecname() (path string, err error) {
	fake.getexecnameMutex.Lock()
	ret, specificReturn := fake.getexecnameReturnsOnCall[len(fake.getexecnameArgsForCall)]
	fake.getexecnameArgsForCall = append(fake.getexecnameArgsForCall, struct{}{})
	fake.recordInvocation("Getexecname", []interface{}{})
	fake.getexecnameMutex.Unlock()
	if fake.GetexecnameStub != nil {
		return fake.GetexecnameStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getexecnameReturns.result1, fake.getexecnameReturns.result2
}

func (fake *FakeSyscall) GetexecnameCallCount() int {
	fake.getexecnameMutex.RLock()
	defer fake.getexecnameMutex.RUnlock()
	return len(fake.getexecnameArgsForCall)
}

func (fake *FakeSyscall) GetexecnameReturns(result1 string, result2 error) {
	fake.GetexecnameStub = nil
	fake.getexecnameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetexecnameReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetexecnameStub = nil
	if fake.getexecnameReturnsOnCall == nil {
		fake.getexecnameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getexecnameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) StringToUTF16(s string) []uint16 {
	fake.stringToUTF16Mutex.Lock()
	ret, specificReturn := fake.stringToUTF16ReturnsOnCall[len(fake.stringToUTF16ArgsForCall)]
	fake.stringToUTF16ArgsForCall = append(fake.stringToUTF16ArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("StringToUTF16", []interface{}{s})
	fake.stringToUTF16Mutex.Unlock()
	if fake.StringToUTF16Stub != nil {
		return fake.StringToUTF16Stub(s)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stringToUTF16Returns.result1
}

func (fake *FakeSyscall) StringToUTF16CallCount() int {
	fake.stringToUTF16Mutex.RLock()
	defer fake.stringToUTF16Mutex.RUnlock()
	return len(fake.stringToUTF16ArgsForCall)
}

func (fake *FakeSyscall) StringToUTF16ArgsForCall(i int) string {
	fake.stringToUTF16Mutex.RLock()
	defer fake.stringToUTF16Mutex.RUnlock()
	return fake.stringToUTF16ArgsForCall[i].s
}

func (fake *FakeSyscall) StringToUTF16Returns(result1 []uint16) {
	fake.StringToUTF16Stub = nil
	fake.stringToUTF16Returns = struct {
		result1 []uint16
	}{result1}
}

func (fake *FakeSyscall) StringToUTF16ReturnsOnCall(i int, result1 []uint16) {
	fake.StringToUTF16Stub = nil
	if fake.stringToUTF16ReturnsOnCall == nil {
		fake.stringToUTF16ReturnsOnCall = make(map[int]struct {
			result1 []uint16
		})
	}
	fake.stringToUTF16ReturnsOnCall[i] = struct {
		result1 []uint16
	}{result1}
}

func (fake *FakeSyscall) UTF16FromString(s string) ([]uint16, error) {
	fake.uTF16FromStringMutex.Lock()
	ret, specificReturn := fake.uTF16FromStringReturnsOnCall[len(fake.uTF16FromStringArgsForCall)]
	fake.uTF16FromStringArgsForCall = append(fake.uTF16FromStringArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("UTF16FromString", []interface{}{s})
	fake.uTF16FromStringMutex.Unlock()
	if fake.UTF16FromStringStub != nil {
		return fake.UTF16FromStringStub(s)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.uTF16FromStringReturns.result1, fake.uTF16FromStringReturns.result2
}

func (fake *FakeSyscall) UTF16FromStringCallCount() int {
	fake.uTF16FromStringMutex.RLock()
	defer fake.uTF16FromStringMutex.RUnlock()
	return len(fake.uTF16FromStringArgsForCall)
}

func (fake *FakeSyscall) UTF16FromStringArgsForCall(i int) string {
	fake.uTF16FromStringMutex.RLock()
	defer fake.uTF16FromStringMutex.RUnlock()
	return fake.uTF16FromStringArgsForCall[i].s
}

func (fake *FakeSyscall) UTF16FromStringReturns(result1 []uint16, result2 error) {
	fake.UTF16FromStringStub = nil
	fake.uTF16FromStringReturns = struct {
		result1 []uint16
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) UTF16FromStringReturnsOnCall(i int, result1 []uint16, result2 error) {
	fake.UTF16FromStringStub = nil
	if fake.uTF16FromStringReturnsOnCall == nil {
		fake.uTF16FromStringReturnsOnCall = make(map[int]struct {
			result1 []uint16
			result2 error
		})
	}
	fake.uTF16FromStringReturnsOnCall[i] = struct {
		result1 []uint16
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) UTF16ToString(s []uint16) string {
	var sCopy []uint16
	if s != nil {
		sCopy = make([]uint16, len(s))
		copy(sCopy, s)
	}
	fake.uTF16ToStringMutex.Lock()
	ret, specificReturn := fake.uTF16ToStringReturnsOnCall[len(fake.uTF16ToStringArgsForCall)]
	fake.uTF16ToStringArgsForCall = append(fake.uTF16ToStringArgsForCall, struct {
		s []uint16
	}{sCopy})
	fake.recordInvocation("UTF16ToString", []interface{}{sCopy})
	fake.uTF16ToStringMutex.Unlock()
	if fake.UTF16ToStringStub != nil {
		return fake.UTF16ToStringStub(s)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uTF16ToStringReturns.result1
}

func (fake *FakeSyscall) UTF16ToStringCallCount() int {
	fake.uTF16ToStringMutex.RLock()
	defer fake.uTF16ToStringMutex.RUnlock()
	return len(fake.uTF16ToStringArgsForCall)
}

func (fake *FakeSyscall) UTF16ToStringArgsForCall(i int) []uint16 {
	fake.uTF16ToStringMutex.RLock()
	defer fake.uTF16ToStringMutex.RUnlock()
	return fake.uTF16ToStringArgsForCall[i].s
}

func (fake *FakeSyscall) UTF16ToStringReturns(result1 string) {
	fake.UTF16ToStringStub = nil
	fake.uTF16ToStringReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeSyscall) UTF16ToStringReturnsOnCall(i int, result1 string) {
	fake.UTF16ToStringStub = nil
	if fake.uTF16ToStringReturnsOnCall == nil {
		fake.uTF16ToStringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uTF16ToStringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeSyscall) StringToUTF16Ptr(s string) *uint16 {
	fake.stringToUTF16PtrMutex.Lock()
	ret, specificReturn := fake.stringToUTF16PtrReturnsOnCall[len(fake.stringToUTF16PtrArgsForCall)]
	fake.stringToUTF16PtrArgsForCall = append(fake.stringToUTF16PtrArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("StringToUTF16Ptr", []interface{}{s})
	fake.stringToUTF16PtrMutex.Unlock()
	if fake.StringToUTF16PtrStub != nil {
		return fake.StringToUTF16PtrStub(s)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stringToUTF16PtrReturns.result1
}

func (fake *FakeSyscall) StringToUTF16PtrCallCount() int {
	fake.stringToUTF16PtrMutex.RLock()
	defer fake.stringToUTF16PtrMutex.RUnlock()
	return len(fake.stringToUTF16PtrArgsForCall)
}

func (fake *FakeSyscall) StringToUTF16PtrArgsForCall(i int) string {
	fake.stringToUTF16PtrMutex.RLock()
	defer fake.stringToUTF16PtrMutex.RUnlock()
	return fake.stringToUTF16PtrArgsForCall[i].s
}

func (fake *FakeSyscall) StringToUTF16PtrReturns(result1 *uint16) {
	fake.StringToUTF16PtrStub = nil
	fake.stringToUTF16PtrReturns = struct {
		result1 *uint16
	}{result1}
}

func (fake *FakeSyscall) StringToUTF16PtrReturnsOnCall(i int, result1 *uint16) {
	fake.StringToUTF16PtrStub = nil
	if fake.stringToUTF16PtrReturnsOnCall == nil {
		fake.stringToUTF16PtrReturnsOnCall = make(map[int]struct {
			result1 *uint16
		})
	}
	fake.stringToUTF16PtrReturnsOnCall[i] = struct {
		result1 *uint16
	}{result1}
}

func (fake *FakeSyscall) UTF16PtrFromString(s string) (*uint16, error) {
	fake.uTF16PtrFromStringMutex.Lock()
	ret, specificReturn := fake.uTF16PtrFromStringReturnsOnCall[len(fake.uTF16PtrFromStringArgsForCall)]
	fake.uTF16PtrFromStringArgsForCall = append(fake.uTF16PtrFromStringArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("UTF16PtrFromString", []interface{}{s})
	fake.uTF16PtrFromStringMutex.Unlock()
	if fake.UTF16PtrFromStringStub != nil {
		return fake.UTF16PtrFromStringStub(s)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.uTF16PtrFromStringReturns.result1, fake.uTF16PtrFromStringReturns.result2
}

func (fake *FakeSyscall) UTF16PtrFromStringCallCount() int {
	fake.uTF16PtrFromStringMutex.RLock()
	defer fake.uTF16PtrFromStringMutex.RUnlock()
	return len(fake.uTF16PtrFromStringArgsForCall)
}

func (fake *FakeSyscall) UTF16PtrFromStringArgsForCall(i int) string {
	fake.uTF16PtrFromStringMutex.RLock()
	defer fake.uTF16PtrFromStringMutex.RUnlock()
	return fake.uTF16PtrFromStringArgsForCall[i].s
}

func (fake *FakeSyscall) UTF16PtrFromStringReturns(result1 *uint16, result2 error) {
	fake.UTF16PtrFromStringStub = nil
	fake.uTF16PtrFromStringReturns = struct {
		result1 *uint16
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) UTF16PtrFromStringReturnsOnCall(i int, result1 *uint16, result2 error) {
	fake.UTF16PtrFromStringStub = nil
	if fake.uTF16PtrFromStringReturnsOnCall == nil {
		fake.uTF16PtrFromStringReturnsOnCall = make(map[int]struct {
			result1 *uint16
			result2 error
		})
	}
	fake.uTF16PtrFromStringReturnsOnCall[i] = struct {
		result1 *uint16
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) FormatMessage(flags uint32, msgsrc uint32, msgid uint32, langid uint32, buf []uint16, args *byte) (n uint32, err error) {
	var bufCopy []uint16
	if buf != nil {
		bufCopy = make([]uint16, len(buf))
		copy(bufCopy, buf)
	}
	fake.formatMessageMutex.Lock()
	ret, specificReturn := fake.formatMessageReturnsOnCall[len(fake.formatMessageArgsForCall)]
	fake.formatMessageArgsForCall = append(fake.formatMessageArgsForCall, struct {
		flags  uint32
		msgsrc uint32
		msgid  uint32
		langid uint32
		buf    []uint16
		args   *byte
	}{flags, msgsrc, msgid, langid, bufCopy, args})
	fake.recordInvocation("FormatMessage", []interface{}{flags, msgsrc, msgid, langid, bufCopy, args})
	fake.formatMessageMutex.Unlock()
	if fake.FormatMessageStub != nil {
		return fake.FormatMessageStub(flags, msgsrc, msgid, langid, buf, args)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.formatMessageReturns.result1, fake.formatMessageReturns.result2
}

func (fake *FakeSyscall) FormatMessageCallCount() int {
	fake.formatMessageMutex.RLock()
	defer fake.formatMessageMutex.RUnlock()
	return len(fake.formatMessageArgsForCall)
}

func (fake *FakeSyscall) FormatMessageArgsForCall(i int) (uint32, uint32, uint32, uint32, []uint16, *byte) {
	fake.formatMessageMutex.RLock()
	defer fake.formatMessageMutex.RUnlock()
	return fake.formatMessageArgsForCall[i].flags, fake.formatMessageArgsForCall[i].msgsrc, fake.formatMessageArgsForCall[i].msgid, fake.formatMessageArgsForCall[i].langid, fake.formatMessageArgsForCall[i].buf, fake.formatMessageArgsForCall[i].args
}

func (fake *FakeSyscall) FormatMessageReturns(result1 uint32, result2 error) {
	fake.FormatMessageStub = nil
	fake.formatMessageReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) FormatMessageReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.FormatMessageStub = nil
	if fake.formatMessageReturnsOnCall == nil {
		fake.formatMessageReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.formatMessageReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) NewCallback(fn interface{}) uintptr {
	fake.newCallbackMutex.Lock()
	ret, specificReturn := fake.newCallbackReturnsOnCall[len(fake.newCallbackArgsForCall)]
	fake.newCallbackArgsForCall = append(fake.newCallbackArgsForCall, struct {
		fn interface{}
	}{fn})
	fake.recordInvocation("NewCallback", []interface{}{fn})
	fake.newCallbackMutex.Unlock()
	if fake.NewCallbackStub != nil {
		return fake.NewCallbackStub(fn)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newCallbackReturns.result1
}

func (fake *FakeSyscall) NewCallbackCallCount() int {
	fake.newCallbackMutex.RLock()
	defer fake.newCallbackMutex.RUnlock()
	return len(fake.newCallbackArgsForCall)
}

func (fake *FakeSyscall) NewCallbackArgsForCall(i int) interface{} {
	fake.newCallbackMutex.RLock()
	defer fake.newCallbackMutex.RUnlock()
	return fake.newCallbackArgsForCall[i].fn
}

func (fake *FakeSyscall) NewCallbackReturns(result1 uintptr) {
	fake.NewCallbackStub = nil
	fake.newCallbackReturns = struct {
		result1 uintptr
	}{result1}
}

func (fake *FakeSyscall) NewCallbackReturnsOnCall(i int, result1 uintptr) {
	fake.NewCallbackStub = nil
	if fake.newCallbackReturnsOnCall == nil {
		fake.newCallbackReturnsOnCall = make(map[int]struct {
			result1 uintptr
		})
	}
	fake.newCallbackReturnsOnCall[i] = struct {
		result1 uintptr
	}{result1}
}

func (fake *FakeSyscall) NewCallbackCDecl(fn interface{}) uintptr {
	fake.newCallbackCDeclMutex.Lock()
	ret, specificReturn := fake.newCallbackCDeclReturnsOnCall[len(fake.newCallbackCDeclArgsForCall)]
	fake.newCallbackCDeclArgsForCall = append(fake.newCallbackCDeclArgsForCall, struct {
		fn interface{}
	}{fn})
	fake.recordInvocation("NewCallbackCDecl", []interface{}{fn})
	fake.newCallbackCDeclMutex.Unlock()
	if fake.NewCallbackCDeclStub != nil {
		return fake.NewCallbackCDeclStub(fn)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newCallbackCDeclReturns.result1
}

func (fake *FakeSyscall) NewCallbackCDeclCallCount() int {
	fake.newCallbackCDeclMutex.RLock()
	defer fake.newCallbackCDeclMutex.RUnlock()
	return len(fake.newCallbackCDeclArgsForCall)
}

func (fake *FakeSyscall) NewCallbackCDeclArgsForCall(i int) interface{} {
	fake.newCallbackCDeclMutex.RLock()
	defer fake.newCallbackCDeclMutex.RUnlock()
	return fake.newCallbackCDeclArgsForCall[i].fn
}

func (fake *FakeSyscall) NewCallbackCDeclReturns(result1 uintptr) {
	fake.NewCallbackCDeclStub = nil
	fake.newCallbackCDeclReturns = struct {
		result1 uintptr
	}{result1}
}

func (fake *FakeSyscall) NewCallbackCDeclReturnsOnCall(i int, result1 uintptr) {
	fake.NewCallbackCDeclStub = nil
	if fake.newCallbackCDeclReturnsOnCall == nil {
		fake.newCallbackCDeclReturnsOnCall = make(map[int]struct {
			result1 uintptr
		})
	}
	fake.newCallbackCDeclReturnsOnCall[i] = struct {
		result1 uintptr
	}{result1}
}

func (fake *FakeSyscall) ComputerName() (name string, err error) {
	fake.computerNameMutex.Lock()
	ret, specificReturn := fake.computerNameReturnsOnCall[len(fake.computerNameArgsForCall)]
	fake.computerNameArgsForCall = append(fake.computerNameArgsForCall, struct{}{})
	fake.recordInvocation("ComputerName", []interface{}{})
	fake.computerNameMutex.Unlock()
	if fake.ComputerNameStub != nil {
		return fake.ComputerNameStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.computerNameReturns.result1, fake.computerNameReturns.result2
}

func (fake *FakeSyscall) ComputerNameCallCount() int {
	fake.computerNameMutex.RLock()
	defer fake.computerNameMutex.RUnlock()
	return len(fake.computerNameArgsForCall)
}

func (fake *FakeSyscall) ComputerNameReturns(result1 string, result2 error) {
	fake.ComputerNameStub = nil
	fake.computerNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ComputerNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.ComputerNameStub = nil
	if fake.computerNameReturnsOnCall == nil {
		fake.computerNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.computerNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) LoadCancelIoEx() error {
	fake.loadCancelIoExMutex.Lock()
	ret, specificReturn := fake.loadCancelIoExReturnsOnCall[len(fake.loadCancelIoExArgsForCall)]
	fake.loadCancelIoExArgsForCall = append(fake.loadCancelIoExArgsForCall, struct{}{})
	fake.recordInvocation("LoadCancelIoEx", []interface{}{})
	fake.loadCancelIoExMutex.Unlock()
	if fake.LoadCancelIoExStub != nil {
		return fake.LoadCancelIoExStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.loadCancelIoExReturns.result1
}

func (fake *FakeSyscall) LoadCancelIoExCallCount() int {
	fake.loadCancelIoExMutex.RLock()
	defer fake.loadCancelIoExMutex.RUnlock()
	return len(fake.loadCancelIoExArgsForCall)
}

func (fake *FakeSyscall) LoadCancelIoExReturns(result1 error) {
	fake.LoadCancelIoExStub = nil
	fake.loadCancelIoExReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LoadCancelIoExReturnsOnCall(i int, result1 error) {
	fake.LoadCancelIoExStub = nil
	if fake.loadCancelIoExReturnsOnCall == nil {
		fake.loadCancelIoExReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.loadCancelIoExReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LoadSetFileCompletionNotificationModes() error {
	fake.loadSetFileCompletionNotificationModesMutex.Lock()
	ret, specificReturn := fake.loadSetFileCompletionNotificationModesReturnsOnCall[len(fake.loadSetFileCompletionNotificationModesArgsForCall)]
	fake.loadSetFileCompletionNotificationModesArgsForCall = append(fake.loadSetFileCompletionNotificationModesArgsForCall, struct{}{})
	fake.recordInvocation("LoadSetFileCompletionNotificationModes", []interface{}{})
	fake.loadSetFileCompletionNotificationModesMutex.Unlock()
	if fake.LoadSetFileCompletionNotificationModesStub != nil {
		return fake.LoadSetFileCompletionNotificationModesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.loadSetFileCompletionNotificationModesReturns.result1
}

func (fake *FakeSyscall) LoadSetFileCompletionNotificationModesCallCount() int {
	fake.loadSetFileCompletionNotificationModesMutex.RLock()
	defer fake.loadSetFileCompletionNotificationModesMutex.RUnlock()
	return len(fake.loadSetFileCompletionNotificationModesArgsForCall)
}

func (fake *FakeSyscall) LoadSetFileCompletionNotificationModesReturns(result1 error) {
	fake.LoadSetFileCompletionNotificationModesStub = nil
	fake.loadSetFileCompletionNotificationModesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LoadSetFileCompletionNotificationModesReturnsOnCall(i int, result1 error) {
	fake.LoadSetFileCompletionNotificationModesStub = nil
	if fake.loadSetFileCompletionNotificationModesReturnsOnCall == nil {
		fake.loadSetFileCompletionNotificationModesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.loadSetFileCompletionNotificationModesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSASendto(s syscall.Handle, bufs *syscall.WSABuf, bufcnt uint32, sent *uint32, flags uint32, to syscall.Sockaddr, overlapped *syscall.Overlapped, croutine *byte) (err error) {
	fake.wSASendtoMutex.Lock()
	ret, specificReturn := fake.wSASendtoReturnsOnCall[len(fake.wSASendtoArgsForCall)]
	fake.wSASendtoArgsForCall = append(fake.wSASendtoArgsForCall, struct {
		s          syscall.Handle
		bufs       *syscall.WSABuf
		bufcnt     uint32
		sent       *uint32
		flags      uint32
		to         syscall.Sockaddr
		overlapped *syscall.Overlapped
		croutine   *byte
	}{s, bufs, bufcnt, sent, flags, to, overlapped, croutine})
	fake.recordInvocation("WSASendto", []interface{}{s, bufs, bufcnt, sent, flags, to, overlapped, croutine})
	fake.wSASendtoMutex.Unlock()
	if fake.WSASendtoStub != nil {
		return fake.WSASendtoStub(s, bufs, bufcnt, sent, flags, to, overlapped, croutine)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.wSASendtoReturns.result1
}

func (fake *FakeSyscall) WSASendtoCallCount() int {
	fake.wSASendtoMutex.RLock()
	defer fake.wSASendtoMutex.RUnlock()
	return len(fake.wSASendtoArgsForCall)
}

func (fake *FakeSyscall) WSASendtoArgsForCall(i int) (syscall.Handle, *syscall.WSABuf, uint32, *uint32, uint32, syscall.Sockaddr, *syscall.Overlapped, *byte) {
	fake.wSASendtoMutex.RLock()
	defer fake.wSASendtoMutex.RUnlock()
	return fake.wSASendtoArgsForCall[i].s, fake.wSASendtoArgsForCall[i].bufs, fake.wSASendtoArgsForCall[i].bufcnt, fake.wSASendtoArgsForCall[i].sent, fake.wSASendtoArgsForCall[i].flags, fake.wSASendtoArgsForCall[i].to, fake.wSASendtoArgsForCall[i].overlapped, fake.wSASendtoArgsForCall[i].croutine
}

func (fake *FakeSyscall) WSASendtoReturns(result1 error) {
	fake.WSASendtoStub = nil
	fake.wSASendtoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSASendtoReturnsOnCall(i int, result1 error) {
	fake.WSASendtoStub = nil
	if fake.wSASendtoReturnsOnCall == nil {
		fake.wSASendtoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.wSASendtoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LoadGetAddrInfo() error {
	fake.loadGetAddrInfoMutex.Lock()
	ret, specificReturn := fake.loadGetAddrInfoReturnsOnCall[len(fake.loadGetAddrInfoArgsForCall)]
	fake.loadGetAddrInfoArgsForCall = append(fake.loadGetAddrInfoArgsForCall, struct{}{})
	fake.recordInvocation("LoadGetAddrInfo", []interface{}{})
	fake.loadGetAddrInfoMutex.Unlock()
	if fake.LoadGetAddrInfoStub != nil {
		return fake.LoadGetAddrInfoStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.loadGetAddrInfoReturns.result1
}

func (fake *FakeSyscall) LoadGetAddrInfoCallCount() int {
	fake.loadGetAddrInfoMutex.RLock()
	defer fake.loadGetAddrInfoMutex.RUnlock()
	return len(fake.loadGetAddrInfoArgsForCall)
}

func (fake *FakeSyscall) LoadGetAddrInfoReturns(result1 error) {
	fake.LoadGetAddrInfoStub = nil
	fake.loadGetAddrInfoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LoadGetAddrInfoReturnsOnCall(i int, result1 error) {
	fake.LoadGetAddrInfoStub = nil
	if fake.loadGetAddrInfoReturnsOnCall == nil {
		fake.loadGetAddrInfoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.loadGetAddrInfoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LoadConnectEx() error {
	fake.loadConnectExMutex.Lock()
	ret, specificReturn := fake.loadConnectExReturnsOnCall[len(fake.loadConnectExArgsForCall)]
	fake.loadConnectExArgsForCall = append(fake.loadConnectExArgsForCall, struct{}{})
	fake.recordInvocation("LoadConnectEx", []interface{}{})
	fake.loadConnectExMutex.Unlock()
	if fake.LoadConnectExStub != nil {
		return fake.LoadConnectExStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.loadConnectExReturns.result1
}

func (fake *FakeSyscall) LoadConnectExCallCount() int {
	fake.loadConnectExMutex.RLock()
	defer fake.loadConnectExMutex.RUnlock()
	return len(fake.loadConnectExArgsForCall)
}

func (fake *FakeSyscall) LoadConnectExReturns(result1 error) {
	fake.LoadConnectExStub = nil
	fake.loadConnectExReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LoadConnectExReturnsOnCall(i int, result1 error) {
	fake.LoadConnectExStub = nil
	if fake.loadConnectExReturnsOnCall == nil {
		fake.loadConnectExReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.loadConnectExReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ConnectEx(fd syscall.Handle, sa syscall.Sockaddr, sendBuf *byte, sendDataLen uint32, bytesSent *uint32, overlapped *syscall.Overlapped) error {
	fake.connectExMutex.Lock()
	ret, specificReturn := fake.connectExReturnsOnCall[len(fake.connectExArgsForCall)]
	fake.connectExArgsForCall = append(fake.connectExArgsForCall, struct {
		fd          syscall.Handle
		sa          syscall.Sockaddr
		sendBuf     *byte
		sendDataLen uint32
		bytesSent   *uint32
		overlapped  *syscall.Overlapped
	}{fd, sa, sendBuf, sendDataLen, bytesSent, overlapped})
	fake.recordInvocation("ConnectEx", []interface{}{fd, sa, sendBuf, sendDataLen, bytesSent, overlapped})
	fake.connectExMutex.Unlock()
	if fake.ConnectExStub != nil {
		return fake.ConnectExStub(fd, sa, sendBuf, sendDataLen, bytesSent, overlapped)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.connectExReturns.result1
}

func (fake *FakeSyscall) ConnectExCallCount() int {
	fake.connectExMutex.RLock()
	defer fake.connectExMutex.RUnlock()
	return len(fake.connectExArgsForCall)
}

func (fake *FakeSyscall) ConnectExArgsForCall(i int) (syscall.Handle, syscall.Sockaddr, *byte, uint32, *uint32, *syscall.Overlapped) {
	fake.connectExMutex.RLock()
	defer fake.connectExMutex.RUnlock()
	return fake.connectExArgsForCall[i].fd, fake.connectExArgsForCall[i].sa, fake.connectExArgsForCall[i].sendBuf, fake.connectExArgsForCall[i].sendDataLen, fake.connectExArgsForCall[i].bytesSent, fake.connectExArgsForCall[i].overlapped
}

func (fake *FakeSyscall) ConnectExReturns(result1 error) {
	fake.ConnectExStub = nil
	fake.connectExReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ConnectExReturnsOnCall(i int, result1 error) {
	fake.ConnectExStub = nil
	if fake.connectExReturnsOnCall == nil {
		fake.connectExReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.connectExReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) TimespecToNsec(ts syscall.Timespec) int64 {
	fake.timespecToNsecMutex.Lock()
	ret, specificReturn := fake.timespecToNsecReturnsOnCall[len(fake.timespecToNsecArgsForCall)]
	fake.timespecToNsecArgsForCall = append(fake.timespecToNsecArgsForCall, struct {
		ts syscall.Timespec
	}{ts})
	fake.recordInvocation("TimespecToNsec", []interface{}{ts})
	fake.timespecToNsecMutex.Unlock()
	if fake.TimespecToNsecStub != nil {
		return fake.TimespecToNsecStub(ts)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.timespecToNsecReturns.result1
}

func (fake *FakeSyscall) TimespecToNsecCallCount() int {
	fake.timespecToNsecMutex.RLock()
	defer fake.timespecToNsecMutex.RUnlock()
	return len(fake.timespecToNsecArgsForCall)
}

func (fake *FakeSyscall) TimespecToNsecArgsForCall(i int) syscall.Timespec {
	fake.timespecToNsecMutex.RLock()
	defer fake.timespecToNsecMutex.RUnlock()
	return fake.timespecToNsecArgsForCall[i].ts
}

func (fake *FakeSyscall) TimespecToNsecReturns(result1 int64) {
	fake.TimespecToNsecStub = nil
	fake.timespecToNsecReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeSyscall) TimespecToNsecReturnsOnCall(i int, result1 int64) {
	fake.TimespecToNsecStub = nil
	if fake.timespecToNsecReturnsOnCall == nil {
		fake.timespecToNsecReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.timespecToNsecReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeSyscall) NsecToTimespec(nsec int64) (ts syscall.Timespec) {
	fake.nsecToTimespecMutex.Lock()
	ret, specificReturn := fake.nsecToTimespecReturnsOnCall[len(fake.nsecToTimespecArgsForCall)]
	fake.nsecToTimespecArgsForCall = append(fake.nsecToTimespecArgsForCall, struct {
		nsec int64
	}{nsec})
	fake.recordInvocation("NsecToTimespec", []interface{}{nsec})
	fake.nsecToTimespecMutex.Unlock()
	if fake.NsecToTimespecStub != nil {
		return fake.NsecToTimespecStub(nsec)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nsecToTimespecReturns.result1
}

func (fake *FakeSyscall) NsecToTimespecCallCount() int {
	fake.nsecToTimespecMutex.RLock()
	defer fake.nsecToTimespecMutex.RUnlock()
	return len(fake.nsecToTimespecArgsForCall)
}

func (fake *FakeSyscall) NsecToTimespecArgsForCall(i int) int64 {
	fake.nsecToTimespecMutex.RLock()
	defer fake.nsecToTimespecMutex.RUnlock()
	return fake.nsecToTimespecArgsForCall[i].nsec
}

func (fake *FakeSyscall) NsecToTimespecReturns(result1 syscall.Timespec) {
	fake.NsecToTimespecStub = nil
	fake.nsecToTimespecReturns = struct {
		result1 syscall.Timespec
	}{result1}
}

func (fake *FakeSyscall) NsecToTimespecReturnsOnCall(i int, result1 syscall.Timespec) {
	fake.NsecToTimespecStub = nil
	if fake.nsecToTimespecReturnsOnCall == nil {
		fake.nsecToTimespecReturnsOnCall = make(map[int]struct {
			result1 syscall.Timespec
		})
	}
	fake.nsecToTimespecReturnsOnCall[i] = struct {
		result1 syscall.Timespec
	}{result1}
}

func (fake *FakeSyscall) FindFirstFile(name *uint16, data *syscall.Win32finddata) (handle syscall.Handle, err error) {
	fake.findFirstFileMutex.Lock()
	ret, specificReturn := fake.findFirstFileReturnsOnCall[len(fake.findFirstFileArgsForCall)]
	fake.findFirstFileArgsForCall = append(fake.findFirstFileArgsForCall, struct {
		name *uint16
		data *syscall.Win32finddata
	}{name, data})
	fake.recordInvocation("FindFirstFile", []interface{}{name, data})
	fake.findFirstFileMutex.Unlock()
	if fake.FindFirstFileStub != nil {
		return fake.FindFirstFileStub(name, data)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findFirstFileReturns.result1, fake.findFirstFileReturns.result2
}

func (fake *FakeSyscall) FindFirstFileCallCount() int {
	fake.findFirstFileMutex.RLock()
	defer fake.findFirstFileMutex.RUnlock()
	return len(fake.findFirstFileArgsForCall)
}

func (fake *FakeSyscall) FindFirstFileArgsForCall(i int) (*uint16, *syscall.Win32finddata) {
	fake.findFirstFileMutex.RLock()
	defer fake.findFirstFileMutex.RUnlock()
	return fake.findFirstFileArgsForCall[i].name, fake.findFirstFileArgsForCall[i].data
}

func (fake *FakeSyscall) FindFirstFileReturns(result1 syscall.Handle, result2 error) {
	fake.FindFirstFileStub = nil
	fake.findFirstFileReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) FindFirstFileReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.FindFirstFileStub = nil
	if fake.findFirstFileReturnsOnCall == nil {
		fake.findFirstFileReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.findFirstFileReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) FindNextFile(handle syscall.Handle, data *syscall.Win32finddata) (err error) {
	fake.findNextFileMutex.Lock()
	ret, specificReturn := fake.findNextFileReturnsOnCall[len(fake.findNextFileArgsForCall)]
	fake.findNextFileArgsForCall = append(fake.findNextFileArgsForCall, struct {
		handle syscall.Handle
		data   *syscall.Win32finddata
	}{handle, data})
	fake.recordInvocation("FindNextFile", []interface{}{handle, data})
	fake.findNextFileMutex.Unlock()
	if fake.FindNextFileStub != nil {
		return fake.FindNextFileStub(handle, data)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.findNextFileReturns.result1
}

func (fake *FakeSyscall) FindNextFileCallCount() int {
	fake.findNextFileMutex.RLock()
	defer fake.findNextFileMutex.RUnlock()
	return len(fake.findNextFileArgsForCall)
}

func (fake *FakeSyscall) FindNextFileArgsForCall(i int) (syscall.Handle, *syscall.Win32finddata) {
	fake.findNextFileMutex.RLock()
	defer fake.findNextFileMutex.RUnlock()
	return fake.findNextFileArgsForCall[i].handle, fake.findNextFileArgsForCall[i].data
}

func (fake *FakeSyscall) FindNextFileReturns(result1 error) {
	fake.FindNextFileStub = nil
	fake.findNextFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FindNextFileReturnsOnCall(i int, result1 error) {
	fake.FindNextFileStub = nil
	if fake.findNextFileReturnsOnCall == nil {
		fake.findNextFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.findNextFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LoadCreateSymbolicLink() error {
	fake.loadCreateSymbolicLinkMutex.Lock()
	ret, specificReturn := fake.loadCreateSymbolicLinkReturnsOnCall[len(fake.loadCreateSymbolicLinkArgsForCall)]
	fake.loadCreateSymbolicLinkArgsForCall = append(fake.loadCreateSymbolicLinkArgsForCall, struct{}{})
	fake.recordInvocation("LoadCreateSymbolicLink", []interface{}{})
	fake.loadCreateSymbolicLinkMutex.Unlock()
	if fake.LoadCreateSymbolicLinkStub != nil {
		return fake.LoadCreateSymbolicLinkStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.loadCreateSymbolicLinkReturns.result1
}

func (fake *FakeSyscall) LoadCreateSymbolicLinkCallCount() int {
	fake.loadCreateSymbolicLinkMutex.RLock()
	defer fake.loadCreateSymbolicLinkMutex.RUnlock()
	return len(fake.loadCreateSymbolicLinkArgsForCall)
}

func (fake *FakeSyscall) LoadCreateSymbolicLinkReturns(result1 error) {
	fake.LoadCreateSymbolicLinkStub = nil
	fake.loadCreateSymbolicLinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LoadCreateSymbolicLinkReturnsOnCall(i int, result1 error) {
	fake.LoadCreateSymbolicLinkStub = nil
	if fake.loadCreateSymbolicLinkReturnsOnCall == nil {
		fake.loadCreateSymbolicLinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.loadCreateSymbolicLinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) TimevalToNsec(tv syscall.Timeval) int64 {
	fake.timevalToNsecMutex.Lock()
	ret, specificReturn := fake.timevalToNsecReturnsOnCall[len(fake.timevalToNsecArgsForCall)]
	fake.timevalToNsecArgsForCall = append(fake.timevalToNsecArgsForCall, struct {
		tv syscall.Timeval
	}{tv})
	fake.recordInvocation("TimevalToNsec", []interface{}{tv})
	fake.timevalToNsecMutex.Unlock()
	if fake.TimevalToNsecStub != nil {
		return fake.TimevalToNsecStub(tv)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.timevalToNsecReturns.result1
}

func (fake *FakeSyscall) TimevalToNsecCallCount() int {
	fake.timevalToNsecMutex.RLock()
	defer fake.timevalToNsecMutex.RUnlock()
	return len(fake.timevalToNsecArgsForCall)
}

func (fake *FakeSyscall) TimevalToNsecArgsForCall(i int) syscall.Timeval {
	fake.timevalToNsecMutex.RLock()
	defer fake.timevalToNsecMutex.RUnlock()
	return fake.timevalToNsecArgsForCall[i].tv
}

func (fake *FakeSyscall) TimevalToNsecReturns(result1 int64) {
	fake.TimevalToNsecStub = nil
	fake.timevalToNsecReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeSyscall) TimevalToNsecReturnsOnCall(i int, result1 int64) {
	fake.TimevalToNsecStub = nil
	if fake.timevalToNsecReturnsOnCall == nil {
		fake.timevalToNsecReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.timevalToNsecReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeSyscall) Adjtime(delta *syscall.Timeval, olddelta *syscall.Timeval) (err error) {
	fake.adjtimeMutex.Lock()
	ret, specificReturn := fake.adjtimeReturnsOnCall[len(fake.adjtimeArgsForCall)]
	fake.adjtimeArgsForCall = append(fake.adjtimeArgsForCall, struct {
		delta    *syscall.Timeval
		olddelta *syscall.Timeval
	}{delta, olddelta})
	fake.recordInvocation("Adjtime", []interface{}{delta, olddelta})
	fake.adjtimeMutex.Unlock()
	if fake.AdjtimeStub != nil {
		return fake.AdjtimeStub(delta, olddelta)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.adjtimeReturns.result1
}

func (fake *FakeSyscall) AdjtimeCallCount() int {
	fake.adjtimeMutex.RLock()
	defer fake.adjtimeMutex.RUnlock()
	return len(fake.adjtimeArgsForCall)
}

func (fake *FakeSyscall) AdjtimeArgsForCall(i int) (*syscall.Timeval, *syscall.Timeval) {
	fake.adjtimeMutex.RLock()
	defer fake.adjtimeMutex.RUnlock()
	return fake.adjtimeArgsForCall[i].delta, fake.adjtimeArgsForCall[i].olddelta
}

func (fake *FakeSyscall) AdjtimeReturns(result1 error) {
	fake.AdjtimeStub = nil
	fake.adjtimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) AdjtimeReturnsOnCall(i int, result1 error) {
	fake.AdjtimeStub = nil
	if fake.adjtimeReturnsOnCall == nil {
		fake.adjtimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.adjtimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Chflags(path string, flags int) (err error) {
	fake.chflagsMutex.Lock()
	ret, specificReturn := fake.chflagsReturnsOnCall[len(fake.chflagsArgsForCall)]
	fake.chflagsArgsForCall = append(fake.chflagsArgsForCall, struct {
		path  string
		flags int
	}{path, flags})
	fake.recordInvocation("Chflags", []interface{}{path, flags})
	fake.chflagsMutex.Unlock()
	if fake.ChflagsStub != nil {
		return fake.ChflagsStub(path, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.chflagsReturns.result1
}

func (fake *FakeSyscall) ChflagsCallCount() int {
	fake.chflagsMutex.RLock()
	defer fake.chflagsMutex.RUnlock()
	return len(fake.chflagsArgsForCall)
}

func (fake *FakeSyscall) ChflagsArgsForCall(i int) (string, int) {
	fake.chflagsMutex.RLock()
	defer fake.chflagsMutex.RUnlock()
	return fake.chflagsArgsForCall[i].path, fake.chflagsArgsForCall[i].flags
}

func (fake *FakeSyscall) ChflagsReturns(result1 error) {
	fake.ChflagsStub = nil
	fake.chflagsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ChflagsReturnsOnCall(i int, result1 error) {
	fake.ChflagsStub = nil
	if fake.chflagsReturnsOnCall == nil {
		fake.chflagsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chflagsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Chroot(path string) (err error) {
	fake.chrootMutex.Lock()
	ret, specificReturn := fake.chrootReturnsOnCall[len(fake.chrootArgsForCall)]
	fake.chrootArgsForCall = append(fake.chrootArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("Chroot", []interface{}{path})
	fake.chrootMutex.Unlock()
	if fake.ChrootStub != nil {
		return fake.ChrootStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.chrootReturns.result1
}

func (fake *FakeSyscall) ChrootCallCount() int {
	fake.chrootMutex.RLock()
	defer fake.chrootMutex.RUnlock()
	return len(fake.chrootArgsForCall)
}

func (fake *FakeSyscall) ChrootArgsForCall(i int) string {
	fake.chrootMutex.RLock()
	defer fake.chrootMutex.RUnlock()
	return fake.chrootArgsForCall[i].path
}

func (fake *FakeSyscall) ChrootReturns(result1 error) {
	fake.ChrootStub = nil
	fake.chrootReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ChrootReturnsOnCall(i int, result1 error) {
	fake.ChrootStub = nil
	if fake.chrootReturnsOnCall == nil {
		fake.chrootReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chrootReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Exchangedata(path1 string, path2 string, options int) (err error) {
	fake.exchangedataMutex.Lock()
	ret, specificReturn := fake.exchangedataReturnsOnCall[len(fake.exchangedataArgsForCall)]
	fake.exchangedataArgsForCall = append(fake.exchangedataArgsForCall, struct {
		path1   string
		path2   string
		options int
	}{path1, path2, options})
	fake.recordInvocation("Exchangedata", []interface{}{path1, path2, options})
	fake.exchangedataMutex.Unlock()
	if fake.ExchangedataStub != nil {
		return fake.ExchangedataStub(path1, path2, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.exchangedataReturns.result1
}

func (fake *FakeSyscall) ExchangedataCallCount() int {
	fake.exchangedataMutex.RLock()
	defer fake.exchangedataMutex.RUnlock()
	return len(fake.exchangedataArgsForCall)
}

func (fake *FakeSyscall) ExchangedataArgsForCall(i int) (string, string, int) {
	fake.exchangedataMutex.RLock()
	defer fake.exchangedataMutex.RUnlock()
	return fake.exchangedataArgsForCall[i].path1, fake.exchangedataArgsForCall[i].path2, fake.exchangedataArgsForCall[i].options
}

func (fake *FakeSyscall) ExchangedataReturns(result1 error) {
	fake.ExchangedataStub = nil
	fake.exchangedataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ExchangedataReturnsOnCall(i int, result1 error) {
	fake.ExchangedataStub = nil
	if fake.exchangedataReturnsOnCall == nil {
		fake.exchangedataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.exchangedataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fchflags(fd int, flags int) (err error) {
	fake.fchflagsMutex.Lock()
	ret, specificReturn := fake.fchflagsReturnsOnCall[len(fake.fchflagsArgsForCall)]
	fake.fchflagsArgsForCall = append(fake.fchflagsArgsForCall, struct {
		fd    int
		flags int
	}{fd, flags})
	fake.recordInvocation("Fchflags", []interface{}{fd, flags})
	fake.fchflagsMutex.Unlock()
	if fake.FchflagsStub != nil {
		return fake.FchflagsStub(fd, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fchflagsReturns.result1
}

func (fake *FakeSyscall) FchflagsCallCount() int {
	fake.fchflagsMutex.RLock()
	defer fake.fchflagsMutex.RUnlock()
	return len(fake.fchflagsArgsForCall)
}

func (fake *FakeSyscall) FchflagsArgsForCall(i int) (int, int) {
	fake.fchflagsMutex.RLock()
	defer fake.fchflagsMutex.RUnlock()
	return fake.fchflagsArgsForCall[i].fd, fake.fchflagsArgsForCall[i].flags
}

func (fake *FakeSyscall) FchflagsReturns(result1 error) {
	fake.FchflagsStub = nil
	fake.fchflagsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FchflagsReturnsOnCall(i int, result1 error) {
	fake.FchflagsStub = nil
	if fake.fchflagsReturnsOnCall == nil {
		fake.fchflagsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fchflagsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Flock(fd int, how int) (err error) {
	fake.flockMutex.Lock()
	ret, specificReturn := fake.flockReturnsOnCall[len(fake.flockArgsForCall)]
	fake.flockArgsForCall = append(fake.flockArgsForCall, struct {
		fd  int
		how int
	}{fd, how})
	fake.recordInvocation("Flock", []interface{}{fd, how})
	fake.flockMutex.Unlock()
	if fake.FlockStub != nil {
		return fake.FlockStub(fd, how)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.flockReturns.result1
}

func (fake *FakeSyscall) FlockCallCount() int {
	fake.flockMutex.RLock()
	defer fake.flockMutex.RUnlock()
	return len(fake.flockArgsForCall)
}

func (fake *FakeSyscall) FlockArgsForCall(i int) (int, int) {
	fake.flockMutex.RLock()
	defer fake.flockMutex.RUnlock()
	return fake.flockArgsForCall[i].fd, fake.flockArgsForCall[i].how
}

func (fake *FakeSyscall) FlockReturns(result1 error) {
	fake.FlockStub = nil
	fake.flockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FlockReturnsOnCall(i int, result1 error) {
	fake.FlockStub = nil
	if fake.flockReturnsOnCall == nil {
		fake.flockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.flockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fpathconf(fd int, name int) (val int, err error) {
	fake.fpathconfMutex.Lock()
	ret, specificReturn := fake.fpathconfReturnsOnCall[len(fake.fpathconfArgsForCall)]
	fake.fpathconfArgsForCall = append(fake.fpathconfArgsForCall, struct {
		fd   int
		name int
	}{fd, name})
	fake.recordInvocation("Fpathconf", []interface{}{fd, name})
	fake.fpathconfMutex.Unlock()
	if fake.FpathconfStub != nil {
		return fake.FpathconfStub(fd, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fpathconfReturns.result1, fake.fpathconfReturns.result2
}

func (fake *FakeSyscall) FpathconfCallCount() int {
	fake.fpathconfMutex.RLock()
	defer fake.fpathconfMutex.RUnlock()
	return len(fake.fpathconfArgsForCall)
}

func (fake *FakeSyscall) FpathconfArgsForCall(i int) (int, int) {
	fake.fpathconfMutex.RLock()
	defer fake.fpathconfMutex.RUnlock()
	return fake.fpathconfArgsForCall[i].fd, fake.fpathconfArgsForCall[i].name
}

func (fake *FakeSyscall) FpathconfReturns(result1 int, result2 error) {
	fake.FpathconfStub = nil
	fake.fpathconfReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) FpathconfReturnsOnCall(i int, result1 int, result2 error) {
	fake.FpathconfStub = nil
	if fake.fpathconfReturnsOnCall == nil {
		fake.fpathconfReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.fpathconfReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Getdtablesize() (size int) {
	fake.getdtablesizeMutex.Lock()
	ret, specificReturn := fake.getdtablesizeReturnsOnCall[len(fake.getdtablesizeArgsForCall)]
	fake.getdtablesizeArgsForCall = append(fake.getdtablesizeArgsForCall, struct{}{})
	fake.recordInvocation("Getdtablesize", []interface{}{})
	fake.getdtablesizeMutex.Unlock()
	if fake.GetdtablesizeStub != nil {
		return fake.GetdtablesizeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getdtablesizeReturns.result1
}

func (fake *FakeSyscall) GetdtablesizeCallCount() int {
	fake.getdtablesizeMutex.RLock()
	defer fake.getdtablesizeMutex.RUnlock()
	return len(fake.getdtablesizeArgsForCall)
}

func (fake *FakeSyscall) GetdtablesizeReturns(result1 int) {
	fake.GetdtablesizeStub = nil
	fake.getdtablesizeReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) GetdtablesizeReturnsOnCall(i int, result1 int) {
	fake.GetdtablesizeStub = nil
	if fake.getdtablesizeReturnsOnCall == nil {
		fake.getdtablesizeReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getdtablesizeReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) Getpgid(pid int) (pgid int, err error) {
	fake.getpgidMutex.Lock()
	ret, specificReturn := fake.getpgidReturnsOnCall[len(fake.getpgidArgsForCall)]
	fake.getpgidArgsForCall = append(fake.getpgidArgsForCall, struct {
		pid int
	}{pid})
	fake.recordInvocation("Getpgid", []interface{}{pid})
	fake.getpgidMutex.Unlock()
	if fake.GetpgidStub != nil {
		return fake.GetpgidStub(pid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getpgidReturns.result1, fake.getpgidReturns.result2
}

func (fake *FakeSyscall) GetpgidCallCount() int {
	fake.getpgidMutex.RLock()
	defer fake.getpgidMutex.RUnlock()
	return len(fake.getpgidArgsForCall)
}

func (fake *FakeSyscall) GetpgidArgsForCall(i int) int {
	fake.getpgidMutex.RLock()
	defer fake.getpgidMutex.RUnlock()
	return fake.getpgidArgsForCall[i].pid
}

func (fake *FakeSyscall) GetpgidReturns(result1 int, result2 error) {
	fake.GetpgidStub = nil
	fake.getpgidReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetpgidReturnsOnCall(i int, result1 int, result2 error) {
	fake.GetpgidStub = nil
	if fake.getpgidReturnsOnCall == nil {
		fake.getpgidReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getpgidReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Getpriority(which int, who int) (prio int, err error) {
	fake.getpriorityMutex.Lock()
	ret, specificReturn := fake.getpriorityReturnsOnCall[len(fake.getpriorityArgsForCall)]
	fake.getpriorityArgsForCall = append(fake.getpriorityArgsForCall, struct {
		which int
		who   int
	}{which, who})
	fake.recordInvocation("Getpriority", []interface{}{which, who})
	fake.getpriorityMutex.Unlock()
	if fake.GetpriorityStub != nil {
		return fake.GetpriorityStub(which, who)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getpriorityReturns.result1, fake.getpriorityReturns.result2
}

func (fake *FakeSyscall) GetpriorityCallCount() int {
	fake.getpriorityMutex.RLock()
	defer fake.getpriorityMutex.RUnlock()
	return len(fake.getpriorityArgsForCall)
}

func (fake *FakeSyscall) GetpriorityArgsForCall(i int) (int, int) {
	fake.getpriorityMutex.RLock()
	defer fake.getpriorityMutex.RUnlock()
	return fake.getpriorityArgsForCall[i].which, fake.getpriorityArgsForCall[i].who
}

func (fake *FakeSyscall) GetpriorityReturns(result1 int, result2 error) {
	fake.GetpriorityStub = nil
	fake.getpriorityReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetpriorityReturnsOnCall(i int, result1 int, result2 error) {
	fake.GetpriorityStub = nil
	if fake.getpriorityReturnsOnCall == nil {
		fake.getpriorityReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getpriorityReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Getrusage(who int, rusage *syscall.Rusage) (err error) {
	fake.getrusageMutex.Lock()
	ret, specificReturn := fake.getrusageReturnsOnCall[len(fake.getrusageArgsForCall)]
	fake.getrusageArgsForCall = append(fake.getrusageArgsForCall, struct {
		who    int
		rusage *syscall.Rusage
	}{who, rusage})
	fake.recordInvocation("Getrusage", []interface{}{who, rusage})
	fake.getrusageMutex.Unlock()
	if fake.GetrusageStub != nil {
		return fake.GetrusageStub(who, rusage)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getrusageReturns.result1
}

func (fake *FakeSyscall) GetrusageCallCount() int {
	fake.getrusageMutex.RLock()
	defer fake.getrusageMutex.RUnlock()
	return len(fake.getrusageArgsForCall)
}

func (fake *FakeSyscall) GetrusageArgsForCall(i int) (int, *syscall.Rusage) {
	fake.getrusageMutex.RLock()
	defer fake.getrusageMutex.RUnlock()
	return fake.getrusageArgsForCall[i].who, fake.getrusageArgsForCall[i].rusage
}

func (fake *FakeSyscall) GetrusageReturns(result1 error) {
	fake.GetrusageStub = nil
	fake.getrusageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetrusageReturnsOnCall(i int, result1 error) {
	fake.GetrusageStub = nil
	if fake.getrusageReturnsOnCall == nil {
		fake.getrusageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getrusageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Getsid(pid int) (sid int, err error) {
	fake.getsidMutex.Lock()
	ret, specificReturn := fake.getsidReturnsOnCall[len(fake.getsidArgsForCall)]
	fake.getsidArgsForCall = append(fake.getsidArgsForCall, struct {
		pid int
	}{pid})
	fake.recordInvocation("Getsid", []interface{}{pid})
	fake.getsidMutex.Unlock()
	if fake.GetsidStub != nil {
		return fake.GetsidStub(pid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getsidReturns.result1, fake.getsidReturns.result2
}

func (fake *FakeSyscall) GetsidCallCount() int {
	fake.getsidMutex.RLock()
	defer fake.getsidMutex.RUnlock()
	return len(fake.getsidArgsForCall)
}

func (fake *FakeSyscall) GetsidArgsForCall(i int) int {
	fake.getsidMutex.RLock()
	defer fake.getsidMutex.RUnlock()
	return fake.getsidArgsForCall[i].pid
}

func (fake *FakeSyscall) GetsidReturns(result1 int, result2 error) {
	fake.GetsidStub = nil
	fake.getsidReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetsidReturnsOnCall(i int, result1 int, result2 error) {
	fake.GetsidStub = nil
	if fake.getsidReturnsOnCall == nil {
		fake.getsidReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getsidReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Issetugid() (tainted bool) {
	fake.issetugidMutex.Lock()
	ret, specificReturn := fake.issetugidReturnsOnCall[len(fake.issetugidArgsForCall)]
	fake.issetugidArgsForCall = append(fake.issetugidArgsForCall, struct{}{})
	fake.recordInvocation("Issetugid", []interface{}{})
	fake.issetugidMutex.Unlock()
	if fake.IssetugidStub != nil {
		return fake.IssetugidStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.issetugidReturns.result1
}

func (fake *FakeSyscall) IssetugidCallCount() int {
	fake.issetugidMutex.RLock()
	defer fake.issetugidMutex.RUnlock()
	return len(fake.issetugidArgsForCall)
}

func (fake *FakeSyscall) IssetugidReturns(result1 bool) {
	fake.IssetugidStub = nil
	fake.issetugidReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSyscall) IssetugidReturnsOnCall(i int, result1 bool) {
	fake.IssetugidStub = nil
	if fake.issetugidReturnsOnCall == nil {
		fake.issetugidReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.issetugidReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSyscall) Kqueue() (fd int, err error) {
	fake.kqueueMutex.Lock()
	ret, specificReturn := fake.kqueueReturnsOnCall[len(fake.kqueueArgsForCall)]
	fake.kqueueArgsForCall = append(fake.kqueueArgsForCall, struct{}{})
	fake.recordInvocation("Kqueue", []interface{}{})
	fake.kqueueMutex.Unlock()
	if fake.KqueueStub != nil {
		return fake.KqueueStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.kqueueReturns.result1, fake.kqueueReturns.result2
}

func (fake *FakeSyscall) KqueueCallCount() int {
	fake.kqueueMutex.RLock()
	defer fake.kqueueMutex.RUnlock()
	return len(fake.kqueueArgsForCall)
}

func (fake *FakeSyscall) KqueueReturns(result1 int, result2 error) {
	fake.KqueueStub = nil
	fake.kqueueReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) KqueueReturnsOnCall(i int, result1 int, result2 error) {
	fake.KqueueStub = nil
	if fake.kqueueReturnsOnCall == nil {
		fake.kqueueReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.kqueueReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Mlock(b []byte) (err error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.mlockMutex.Lock()
	ret, specificReturn := fake.mlockReturnsOnCall[len(fake.mlockArgsForCall)]
	fake.mlockArgsForCall = append(fake.mlockArgsForCall, struct {
		b []byte
	}{bCopy})
	fake.recordInvocation("Mlock", []interface{}{bCopy})
	fake.mlockMutex.Unlock()
	if fake.MlockStub != nil {
		return fake.MlockStub(b)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mlockReturns.result1
}

func (fake *FakeSyscall) MlockCallCount() int {
	fake.mlockMutex.RLock()
	defer fake.mlockMutex.RUnlock()
	return len(fake.mlockArgsForCall)
}

func (fake *FakeSyscall) MlockArgsForCall(i int) []byte {
	fake.mlockMutex.RLock()
	defer fake.mlockMutex.RUnlock()
	return fake.mlockArgsForCall[i].b
}

func (fake *FakeSyscall) MlockReturns(result1 error) {
	fake.MlockStub = nil
	fake.mlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MlockReturnsOnCall(i int, result1 error) {
	fake.MlockStub = nil
	if fake.mlockReturnsOnCall == nil {
		fake.mlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Mlockall(flags int) (err error) {
	fake.mlockallMutex.Lock()
	ret, specificReturn := fake.mlockallReturnsOnCall[len(fake.mlockallArgsForCall)]
	fake.mlockallArgsForCall = append(fake.mlockallArgsForCall, struct {
		flags int
	}{flags})
	fake.recordInvocation("Mlockall", []interface{}{flags})
	fake.mlockallMutex.Unlock()
	if fake.MlockallStub != nil {
		return fake.MlockallStub(flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mlockallReturns.result1
}

func (fake *FakeSyscall) MlockallCallCount() int {
	fake.mlockallMutex.RLock()
	defer fake.mlockallMutex.RUnlock()
	return len(fake.mlockallArgsForCall)
}

func (fake *FakeSyscall) MlockallArgsForCall(i int) int {
	fake.mlockallMutex.RLock()
	defer fake.mlockallMutex.RUnlock()
	return fake.mlockallArgsForCall[i].flags
}

func (fake *FakeSyscall) MlockallReturns(result1 error) {
	fake.MlockallStub = nil
	fake.mlockallReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MlockallReturnsOnCall(i int, result1 error) {
	fake.MlockallStub = nil
	if fake.mlockallReturnsOnCall == nil {
		fake.mlockallReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mlockallReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Mprotect(b []byte, prot int) (err error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.mprotectMutex.Lock()
	ret, specificReturn := fake.mprotectReturnsOnCall[len(fake.mprotectArgsForCall)]
	fake.mprotectArgsForCall = append(fake.mprotectArgsForCall, struct {
		b    []byte
		prot int
	}{bCopy, prot})
	fake.recordInvocation("Mprotect", []interface{}{bCopy, prot})
	fake.mprotectMutex.Unlock()
	if fake.MprotectStub != nil {
		return fake.MprotectStub(b, prot)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mprotectReturns.result1
}

func (fake *FakeSyscall) MprotectCallCount() int {
	fake.mprotectMutex.RLock()
	defer fake.mprotectMutex.RUnlock()
	return len(fake.mprotectArgsForCall)
}

func (fake *FakeSyscall) MprotectArgsForCall(i int) ([]byte, int) {
	fake.mprotectMutex.RLock()
	defer fake.mprotectMutex.RUnlock()
	return fake.mprotectArgsForCall[i].b, fake.mprotectArgsForCall[i].prot
}

func (fake *FakeSyscall) MprotectReturns(result1 error) {
	fake.MprotectStub = nil
	fake.mprotectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MprotectReturnsOnCall(i int, result1 error) {
	fake.MprotectStub = nil
	if fake.mprotectReturnsOnCall == nil {
		fake.mprotectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mprotectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Munlock(b []byte) (err error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.munlockMutex.Lock()
	ret, specificReturn := fake.munlockReturnsOnCall[len(fake.munlockArgsForCall)]
	fake.munlockArgsForCall = append(fake.munlockArgsForCall, struct {
		b []byte
	}{bCopy})
	fake.recordInvocation("Munlock", []interface{}{bCopy})
	fake.munlockMutex.Unlock()
	if fake.MunlockStub != nil {
		return fake.MunlockStub(b)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.munlockReturns.result1
}

func (fake *FakeSyscall) MunlockCallCount() int {
	fake.munlockMutex.RLock()
	defer fake.munlockMutex.RUnlock()
	return len(fake.munlockArgsForCall)
}

func (fake *FakeSyscall) MunlockArgsForCall(i int) []byte {
	fake.munlockMutex.RLock()
	defer fake.munlockMutex.RUnlock()
	return fake.munlockArgsForCall[i].b
}

func (fake *FakeSyscall) MunlockReturns(result1 error) {
	fake.MunlockStub = nil
	fake.munlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MunlockReturnsOnCall(i int, result1 error) {
	fake.MunlockStub = nil
	if fake.munlockReturnsOnCall == nil {
		fake.munlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.munlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Munlockall() (err error) {
	fake.munlockallMutex.Lock()
	ret, specificReturn := fake.munlockallReturnsOnCall[len(fake.munlockallArgsForCall)]
	fake.munlockallArgsForCall = append(fake.munlockallArgsForCall, struct{}{})
	fake.recordInvocation("Munlockall", []interface{}{})
	fake.munlockallMutex.Unlock()
	if fake.MunlockallStub != nil {
		return fake.MunlockallStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.munlockallReturns.result1
}

func (fake *FakeSyscall) MunlockallCallCount() int {
	fake.munlockallMutex.RLock()
	defer fake.munlockallMutex.RUnlock()
	return len(fake.munlockallArgsForCall)
}

func (fake *FakeSyscall) MunlockallReturns(result1 error) {
	fake.MunlockallStub = nil
	fake.munlockallReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MunlockallReturnsOnCall(i int, result1 error) {
	fake.MunlockallStub = nil
	if fake.munlockallReturnsOnCall == nil {
		fake.munlockallReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.munlockallReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Pathconf(path string, name int) (val int, err error) {
	fake.pathconfMutex.Lock()
	ret, specificReturn := fake.pathconfReturnsOnCall[len(fake.pathconfArgsForCall)]
	fake.pathconfArgsForCall = append(fake.pathconfArgsForCall, struct {
		path string
		name int
	}{path, name})
	fake.recordInvocation("Pathconf", []interface{}{path, name})
	fake.pathconfMutex.Unlock()
	if fake.PathconfStub != nil {
		return fake.PathconfStub(path, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pathconfReturns.result1, fake.pathconfReturns.result2
}

func (fake *FakeSyscall) PathconfCallCount() int {
	fake.pathconfMutex.RLock()
	defer fake.pathconfMutex.RUnlock()
	return len(fake.pathconfArgsForCall)
}

func (fake *FakeSyscall) PathconfArgsForCall(i int) (string, int) {
	fake.pathconfMutex.RLock()
	defer fake.pathconfMutex.RUnlock()
	return fake.pathconfArgsForCall[i].path, fake.pathconfArgsForCall[i].name
}

func (fake *FakeSyscall) PathconfReturns(result1 int, result2 error) {
	fake.PathconfStub = nil
	fake.pathconfReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) PathconfReturnsOnCall(i int, result1 int, result2 error) {
	fake.PathconfStub = nil
	if fake.pathconfReturnsOnCall == nil {
		fake.pathconfReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.pathconfReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Revoke(path string) (err error) {
	fake.revokeMutex.Lock()
	ret, specificReturn := fake.revokeReturnsOnCall[len(fake.revokeArgsForCall)]
	fake.revokeArgsForCall = append(fake.revokeArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("Revoke", []interface{}{path})
	fake.revokeMutex.Unlock()
	if fake.RevokeStub != nil {
		return fake.RevokeStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.revokeReturns.result1
}

func (fake *FakeSyscall) RevokeCallCount() int {
	fake.revokeMutex.RLock()
	defer fake.revokeMutex.RUnlock()
	return len(fake.revokeArgsForCall)
}

func (fake *FakeSyscall) RevokeArgsForCall(i int) string {
	fake.revokeMutex.RLock()
	defer fake.revokeMutex.RUnlock()
	return fake.revokeArgsForCall[i].path
}

func (fake *FakeSyscall) RevokeReturns(result1 error) {
	fake.RevokeStub = nil
	fake.revokeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RevokeReturnsOnCall(i int, result1 error) {
	fake.RevokeStub = nil
	if fake.revokeReturnsOnCall == nil {
		fake.revokeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.revokeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Select(n int, r *syscall.FdSet, w *syscall.FdSet, e *syscall.FdSet, timeout *syscall.Timeval) (err error) {
	fake.selectMutex.Lock()
	ret, specificReturn := fake.selectReturnsOnCall[len(fake.selectArgsForCall)]
	fake.selectArgsForCall = append(fake.selectArgsForCall, struct {
		n       int
		r       *syscall.FdSet
		w       *syscall.FdSet
		e       *syscall.FdSet
		timeout *syscall.Timeval
	}{n, r, w, e, timeout})
	fake.recordInvocation("Select", []interface{}{n, r, w, e, timeout})
	fake.selectMutex.Unlock()
	if fake.SelectStub != nil {
		return fake.SelectStub(n, r, w, e, timeout)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.selectReturns.result1
}

func (fake *FakeSyscall) SelectCallCount() int {
	fake.selectMutex.RLock()
	defer fake.selectMutex.RUnlock()
	return len(fake.selectArgsForCall)
}

func (fake *FakeSyscall) SelectArgsForCall(i int) (int, *syscall.FdSet, *syscall.FdSet, *syscall.FdSet, *syscall.Timeval) {
	fake.selectMutex.RLock()
	defer fake.selectMutex.RUnlock()
	return fake.selectArgsForCall[i].n, fake.selectArgsForCall[i].r, fake.selectArgsForCall[i].w, fake.selectArgsForCall[i].e, fake.selectArgsForCall[i].timeout
}

func (fake *FakeSyscall) SelectReturns(result1 error) {
	fake.SelectStub = nil
	fake.selectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SelectReturnsOnCall(i int, result1 error) {
	fake.SelectStub = nil
	if fake.selectReturnsOnCall == nil {
		fake.selectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.selectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setegid(egid int) (err error) {
	fake.setegidMutex.Lock()
	ret, specificReturn := fake.setegidReturnsOnCall[len(fake.setegidArgsForCall)]
	fake.setegidArgsForCall = append(fake.setegidArgsForCall, struct {
		egid int
	}{egid})
	fake.recordInvocation("Setegid", []interface{}{egid})
	fake.setegidMutex.Unlock()
	if fake.SetegidStub != nil {
		return fake.SetegidStub(egid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setegidReturns.result1
}

func (fake *FakeSyscall) SetegidCallCount() int {
	fake.setegidMutex.RLock()
	defer fake.setegidMutex.RUnlock()
	return len(fake.setegidArgsForCall)
}

func (fake *FakeSyscall) SetegidArgsForCall(i int) int {
	fake.setegidMutex.RLock()
	defer fake.setegidMutex.RUnlock()
	return fake.setegidArgsForCall[i].egid
}

func (fake *FakeSyscall) SetegidReturns(result1 error) {
	fake.SetegidStub = nil
	fake.setegidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetegidReturnsOnCall(i int, result1 error) {
	fake.SetegidStub = nil
	if fake.setegidReturnsOnCall == nil {
		fake.setegidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setegidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Seteuid(euid int) (err error) {
	fake.seteuidMutex.Lock()
	ret, specificReturn := fake.seteuidReturnsOnCall[len(fake.seteuidArgsForCall)]
	fake.seteuidArgsForCall = append(fake.seteuidArgsForCall, struct {
		euid int
	}{euid})
	fake.recordInvocation("Seteuid", []interface{}{euid})
	fake.seteuidMutex.Unlock()
	if fake.SeteuidStub != nil {
		return fake.SeteuidStub(euid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.seteuidReturns.result1
}

func (fake *FakeSyscall) SeteuidCallCount() int {
	fake.seteuidMutex.RLock()
	defer fake.seteuidMutex.RUnlock()
	return len(fake.seteuidArgsForCall)
}

func (fake *FakeSyscall) SeteuidArgsForCall(i int) int {
	fake.seteuidMutex.RLock()
	defer fake.seteuidMutex.RUnlock()
	return fake.seteuidArgsForCall[i].euid
}

func (fake *FakeSyscall) SeteuidReturns(result1 error) {
	fake.SeteuidStub = nil
	fake.seteuidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SeteuidReturnsOnCall(i int, result1 error) {
	fake.SeteuidStub = nil
	if fake.seteuidReturnsOnCall == nil {
		fake.seteuidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.seteuidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setlogin(name string) (err error) {
	fake.setloginMutex.Lock()
	ret, specificReturn := fake.setloginReturnsOnCall[len(fake.setloginArgsForCall)]
	fake.setloginArgsForCall = append(fake.setloginArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Setlogin", []interface{}{name})
	fake.setloginMutex.Unlock()
	if fake.SetloginStub != nil {
		return fake.SetloginStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setloginReturns.result1
}

func (fake *FakeSyscall) SetloginCallCount() int {
	fake.setloginMutex.RLock()
	defer fake.setloginMutex.RUnlock()
	return len(fake.setloginArgsForCall)
}

func (fake *FakeSyscall) SetloginArgsForCall(i int) string {
	fake.setloginMutex.RLock()
	defer fake.setloginMutex.RUnlock()
	return fake.setloginArgsForCall[i].name
}

func (fake *FakeSyscall) SetloginReturns(result1 error) {
	fake.SetloginStub = nil
	fake.setloginReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetloginReturnsOnCall(i int, result1 error) {
	fake.SetloginStub = nil
	if fake.setloginReturnsOnCall == nil {
		fake.setloginReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setloginReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setpgid(pid int, pgid int) (err error) {
	fake.setpgidMutex.Lock()
	ret, specificReturn := fake.setpgidReturnsOnCall[len(fake.setpgidArgsForCall)]
	fake.setpgidArgsForCall = append(fake.setpgidArgsForCall, struct {
		pid  int
		pgid int
	}{pid, pgid})
	fake.recordInvocation("Setpgid", []interface{}{pid, pgid})
	fake.setpgidMutex.Unlock()
	if fake.SetpgidStub != nil {
		return fake.SetpgidStub(pid, pgid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setpgidReturns.result1
}

func (fake *FakeSyscall) SetpgidCallCount() int {
	fake.setpgidMutex.RLock()
	defer fake.setpgidMutex.RUnlock()
	return len(fake.setpgidArgsForCall)
}

func (fake *FakeSyscall) SetpgidArgsForCall(i int) (int, int) {
	fake.setpgidMutex.RLock()
	defer fake.setpgidMutex.RUnlock()
	return fake.setpgidArgsForCall[i].pid, fake.setpgidArgsForCall[i].pgid
}

func (fake *FakeSyscall) SetpgidReturns(result1 error) {
	fake.SetpgidStub = nil
	fake.setpgidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetpgidReturnsOnCall(i int, result1 error) {
	fake.SetpgidStub = nil
	if fake.setpgidReturnsOnCall == nil {
		fake.setpgidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setpgidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setpriority(which int, who int, prio int) (err error) {
	fake.setpriorityMutex.Lock()
	ret, specificReturn := fake.setpriorityReturnsOnCall[len(fake.setpriorityArgsForCall)]
	fake.setpriorityArgsForCall = append(fake.setpriorityArgsForCall, struct {
		which int
		who   int
		prio  int
	}{which, who, prio})
	fake.recordInvocation("Setpriority", []interface{}{which, who, prio})
	fake.setpriorityMutex.Unlock()
	if fake.SetpriorityStub != nil {
		return fake.SetpriorityStub(which, who, prio)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setpriorityReturns.result1
}

func (fake *FakeSyscall) SetpriorityCallCount() int {
	fake.setpriorityMutex.RLock()
	defer fake.setpriorityMutex.RUnlock()
	return len(fake.setpriorityArgsForCall)
}

func (fake *FakeSyscall) SetpriorityArgsForCall(i int) (int, int, int) {
	fake.setpriorityMutex.RLock()
	defer fake.setpriorityMutex.RUnlock()
	return fake.setpriorityArgsForCall[i].which, fake.setpriorityArgsForCall[i].who, fake.setpriorityArgsForCall[i].prio
}

func (fake *FakeSyscall) SetpriorityReturns(result1 error) {
	fake.SetpriorityStub = nil
	fake.setpriorityReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetpriorityReturnsOnCall(i int, result1 error) {
	fake.SetpriorityStub = nil
	if fake.setpriorityReturnsOnCall == nil {
		fake.setpriorityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setpriorityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setprivexec(flag int) (err error) {
	fake.setprivexecMutex.Lock()
	ret, specificReturn := fake.setprivexecReturnsOnCall[len(fake.setprivexecArgsForCall)]
	fake.setprivexecArgsForCall = append(fake.setprivexecArgsForCall, struct {
		flag int
	}{flag})
	fake.recordInvocation("Setprivexec", []interface{}{flag})
	fake.setprivexecMutex.Unlock()
	if fake.SetprivexecStub != nil {
		return fake.SetprivexecStub(flag)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setprivexecReturns.result1
}

func (fake *FakeSyscall) SetprivexecCallCount() int {
	fake.setprivexecMutex.RLock()
	defer fake.setprivexecMutex.RUnlock()
	return len(fake.setprivexecArgsForCall)
}

func (fake *FakeSyscall) SetprivexecArgsForCall(i int) int {
	fake.setprivexecMutex.RLock()
	defer fake.setprivexecMutex.RUnlock()
	return fake.setprivexecArgsForCall[i].flag
}

func (fake *FakeSyscall) SetprivexecReturns(result1 error) {
	fake.SetprivexecStub = nil
	fake.setprivexecReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetprivexecReturnsOnCall(i int, result1 error) {
	fake.SetprivexecStub = nil
	if fake.setprivexecReturnsOnCall == nil {
		fake.setprivexecReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setprivexecReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setregid(rgid int, egid int) (err error) {
	fake.setregidMutex.Lock()
	ret, specificReturn := fake.setregidReturnsOnCall[len(fake.setregidArgsForCall)]
	fake.setregidArgsForCall = append(fake.setregidArgsForCall, struct {
		rgid int
		egid int
	}{rgid, egid})
	fake.recordInvocation("Setregid", []interface{}{rgid, egid})
	fake.setregidMutex.Unlock()
	if fake.SetregidStub != nil {
		return fake.SetregidStub(rgid, egid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setregidReturns.result1
}

func (fake *FakeSyscall) SetregidCallCount() int {
	fake.setregidMutex.RLock()
	defer fake.setregidMutex.RUnlock()
	return len(fake.setregidArgsForCall)
}

func (fake *FakeSyscall) SetregidArgsForCall(i int) (int, int) {
	fake.setregidMutex.RLock()
	defer fake.setregidMutex.RUnlock()
	return fake.setregidArgsForCall[i].rgid, fake.setregidArgsForCall[i].egid
}

func (fake *FakeSyscall) SetregidReturns(result1 error) {
	fake.SetregidStub = nil
	fake.setregidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetregidReturnsOnCall(i int, result1 error) {
	fake.SetregidStub = nil
	if fake.setregidReturnsOnCall == nil {
		fake.setregidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setregidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setreuid(ruid int, euid int) (err error) {
	fake.setreuidMutex.Lock()
	ret, specificReturn := fake.setreuidReturnsOnCall[len(fake.setreuidArgsForCall)]
	fake.setreuidArgsForCall = append(fake.setreuidArgsForCall, struct {
		ruid int
		euid int
	}{ruid, euid})
	fake.recordInvocation("Setreuid", []interface{}{ruid, euid})
	fake.setreuidMutex.Unlock()
	if fake.SetreuidStub != nil {
		return fake.SetreuidStub(ruid, euid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setreuidReturns.result1
}

func (fake *FakeSyscall) SetreuidCallCount() int {
	fake.setreuidMutex.RLock()
	defer fake.setreuidMutex.RUnlock()
	return len(fake.setreuidArgsForCall)
}

func (fake *FakeSyscall) SetreuidArgsForCall(i int) (int, int) {
	fake.setreuidMutex.RLock()
	defer fake.setreuidMutex.RUnlock()
	return fake.setreuidArgsForCall[i].ruid, fake.setreuidArgsForCall[i].euid
}

func (fake *FakeSyscall) SetreuidReturns(result1 error) {
	fake.SetreuidStub = nil
	fake.setreuidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetreuidReturnsOnCall(i int, result1 error) {
	fake.SetreuidStub = nil
	if fake.setreuidReturnsOnCall == nil {
		fake.setreuidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setreuidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setsid() (pid int, err error) {
	fake.setsidMutex.Lock()
	ret, specificReturn := fake.setsidReturnsOnCall[len(fake.setsidArgsForCall)]
	fake.setsidArgsForCall = append(fake.setsidArgsForCall, struct{}{})
	fake.recordInvocation("Setsid", []interface{}{})
	fake.setsidMutex.Unlock()
	if fake.SetsidStub != nil {
		return fake.SetsidStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setsidReturns.result1, fake.setsidReturns.result2
}

func (fake *FakeSyscall) SetsidCallCount() int {
	fake.setsidMutex.RLock()
	defer fake.setsidMutex.RUnlock()
	return len(fake.setsidArgsForCall)
}

func (fake *FakeSyscall) SetsidReturns(result1 int, result2 error) {
	fake.SetsidStub = nil
	fake.setsidReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetsidReturnsOnCall(i int, result1 int, result2 error) {
	fake.SetsidStub = nil
	if fake.setsidReturnsOnCall == nil {
		fake.setsidReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.setsidReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Settimeofday(tp *syscall.Timeval) (err error) {
	fake.settimeofdayMutex.Lock()
	ret, specificReturn := fake.settimeofdayReturnsOnCall[len(fake.settimeofdayArgsForCall)]
	fake.settimeofdayArgsForCall = append(fake.settimeofdayArgsForCall, struct {
		tp *syscall.Timeval
	}{tp})
	fake.recordInvocation("Settimeofday", []interface{}{tp})
	fake.settimeofdayMutex.Unlock()
	if fake.SettimeofdayStub != nil {
		return fake.SettimeofdayStub(tp)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.settimeofdayReturns.result1
}

func (fake *FakeSyscall) SettimeofdayCallCount() int {
	fake.settimeofdayMutex.RLock()
	defer fake.settimeofdayMutex.RUnlock()
	return len(fake.settimeofdayArgsForCall)
}

func (fake *FakeSyscall) SettimeofdayArgsForCall(i int) *syscall.Timeval {
	fake.settimeofdayMutex.RLock()
	defer fake.settimeofdayMutex.RUnlock()
	return fake.settimeofdayArgsForCall[i].tp
}

func (fake *FakeSyscall) SettimeofdayReturns(result1 error) {
	fake.SettimeofdayStub = nil
	fake.settimeofdayReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SettimeofdayReturnsOnCall(i int, result1 error) {
	fake.SettimeofdayStub = nil
	if fake.settimeofdayReturnsOnCall == nil {
		fake.settimeofdayReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.settimeofdayReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Sync() (err error) {
	fake.syncMutex.Lock()
	ret, specificReturn := fake.syncReturnsOnCall[len(fake.syncArgsForCall)]
	fake.syncArgsForCall = append(fake.syncArgsForCall, struct{}{})
	fake.recordInvocation("Sync", []interface{}{})
	fake.syncMutex.Unlock()
	if fake.SyncStub != nil {
		return fake.SyncStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.syncReturns.result1
}

func (fake *FakeSyscall) SyncCallCount() int {
	fake.syncMutex.RLock()
	defer fake.syncMutex.RUnlock()
	return len(fake.syncArgsForCall)
}

func (fake *FakeSyscall) SyncReturns(result1 error) {
	fake.SyncStub = nil
	fake.syncReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SyncReturnsOnCall(i int, result1 error) {
	fake.SyncStub = nil
	if fake.syncReturnsOnCall == nil {
		fake.syncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.syncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Umask(newmask int) (oldmask int) {
	fake.umaskMutex.Lock()
	ret, specificReturn := fake.umaskReturnsOnCall[len(fake.umaskArgsForCall)]
	fake.umaskArgsForCall = append(fake.umaskArgsForCall, struct {
		newmask int
	}{newmask})
	fake.recordInvocation("Umask", []interface{}{newmask})
	fake.umaskMutex.Unlock()
	if fake.UmaskStub != nil {
		return fake.UmaskStub(newmask)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.umaskReturns.result1
}

func (fake *FakeSyscall) UmaskCallCount() int {
	fake.umaskMutex.RLock()
	defer fake.umaskMutex.RUnlock()
	return len(fake.umaskArgsForCall)
}

func (fake *FakeSyscall) UmaskArgsForCall(i int) int {
	fake.umaskMutex.RLock()
	defer fake.umaskMutex.RUnlock()
	return fake.umaskArgsForCall[i].newmask
}

func (fake *FakeSyscall) UmaskReturns(result1 int) {
	fake.UmaskStub = nil
	fake.umaskReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) UmaskReturnsOnCall(i int, result1 int) {
	fake.UmaskStub = nil
	if fake.umaskReturnsOnCall == nil {
		fake.umaskReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.umaskReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) Undelete(path string) (err error) {
	fake.undeleteMutex.Lock()
	ret, specificReturn := fake.undeleteReturnsOnCall[len(fake.undeleteArgsForCall)]
	fake.undeleteArgsForCall = append(fake.undeleteArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("Undelete", []interface{}{path})
	fake.undeleteMutex.Unlock()
	if fake.UndeleteStub != nil {
		return fake.UndeleteStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.undeleteReturns.result1
}

func (fake *FakeSyscall) UndeleteCallCount() int {
	fake.undeleteMutex.RLock()
	defer fake.undeleteMutex.RUnlock()
	return len(fake.undeleteArgsForCall)
}

func (fake *FakeSyscall) UndeleteArgsForCall(i int) string {
	fake.undeleteMutex.RLock()
	defer fake.undeleteMutex.RUnlock()
	return fake.undeleteArgsForCall[i].path
}

func (fake *FakeSyscall) UndeleteReturns(result1 error) {
	fake.UndeleteStub = nil
	fake.undeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UndeleteReturnsOnCall(i int, result1 error) {
	fake.UndeleteStub = nil
	if fake.undeleteReturnsOnCall == nil {
		fake.undeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.undeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Nanosleep(time *syscall.Timespec, leftover *syscall.Timespec) (err error) {
	fake.nanosleepMutex.Lock()
	ret, specificReturn := fake.nanosleepReturnsOnCall[len(fake.nanosleepArgsForCall)]
	fake.nanosleepArgsForCall = append(fake.nanosleepArgsForCall, struct {
		time     *syscall.Timespec
		leftover *syscall.Timespec
	}{time, leftover})
	fake.recordInvocation("Nanosleep", []interface{}{time, leftover})
	fake.nanosleepMutex.Unlock()
	if fake.NanosleepStub != nil {
		return fake.NanosleepStub(time, leftover)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nanosleepReturns.result1
}

func (fake *FakeSyscall) NanosleepCallCount() int {
	fake.nanosleepMutex.RLock()
	defer fake.nanosleepMutex.RUnlock()
	return len(fake.nanosleepArgsForCall)
}

func (fake *FakeSyscall) NanosleepArgsForCall(i int) (*syscall.Timespec, *syscall.Timespec) {
	fake.nanosleepMutex.RLock()
	defer fake.nanosleepMutex.RUnlock()
	return fake.nanosleepArgsForCall[i].time, fake.nanosleepArgsForCall[i].leftover
}

func (fake *FakeSyscall) NanosleepReturns(result1 error) {
	fake.NanosleepStub = nil
	fake.nanosleepReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) NanosleepReturnsOnCall(i int, result1 error) {
	fake.NanosleepStub = nil
	if fake.nanosleepReturnsOnCall == nil {
		fake.nanosleepReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.nanosleepReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Acct(path string) (err error) {
	fake.acctMutex.Lock()
	ret, specificReturn := fake.acctReturnsOnCall[len(fake.acctArgsForCall)]
	fake.acctArgsForCall = append(fake.acctArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("Acct", []interface{}{path})
	fake.acctMutex.Unlock()
	if fake.AcctStub != nil {
		return fake.AcctStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.acctReturns.result1
}

func (fake *FakeSyscall) AcctCallCount() int {
	fake.acctMutex.RLock()
	defer fake.acctMutex.RUnlock()
	return len(fake.acctArgsForCall)
}

func (fake *FakeSyscall) AcctArgsForCall(i int) string {
	fake.acctMutex.RLock()
	defer fake.acctMutex.RUnlock()
	return fake.acctArgsForCall[i].path
}

func (fake *FakeSyscall) AcctReturns(result1 error) {
	fake.AcctStub = nil
	fake.acctReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) AcctReturnsOnCall(i int, result1 error) {
	fake.AcctStub = nil
	if fake.acctReturnsOnCall == nil {
		fake.acctReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.acctReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Adjtimex(buf *syscall.Timex) (state int, err error) {
	fake.adjtimexMutex.Lock()
	ret, specificReturn := fake.adjtimexReturnsOnCall[len(fake.adjtimexArgsForCall)]
	fake.adjtimexArgsForCall = append(fake.adjtimexArgsForCall, struct {
		buf *syscall.Timex
	}{buf})
	fake.recordInvocation("Adjtimex", []interface{}{buf})
	fake.adjtimexMutex.Unlock()
	if fake.AdjtimexStub != nil {
		return fake.AdjtimexStub(buf)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.adjtimexReturns.result1, fake.adjtimexReturns.result2
}

func (fake *FakeSyscall) AdjtimexCallCount() int {
	fake.adjtimexMutex.RLock()
	defer fake.adjtimexMutex.RUnlock()
	return len(fake.adjtimexArgsForCall)
}

func (fake *FakeSyscall) AdjtimexArgsForCall(i int) *syscall.Timex {
	fake.adjtimexMutex.RLock()
	defer fake.adjtimexMutex.RUnlock()
	return fake.adjtimexArgsForCall[i].buf
}

func (fake *FakeSyscall) AdjtimexReturns(result1 int, result2 error) {
	fake.AdjtimexStub = nil
	fake.adjtimexReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) AdjtimexReturnsOnCall(i int, result1 int, result2 error) {
	fake.AdjtimexStub = nil
	if fake.adjtimexReturnsOnCall == nil {
		fake.adjtimexReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.adjtimexReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Dup3(oldfd int, newfd int, flags int) (err error) {
	fake.dup3Mutex.Lock()
	ret, specificReturn := fake.dup3ReturnsOnCall[len(fake.dup3ArgsForCall)]
	fake.dup3ArgsForCall = append(fake.dup3ArgsForCall, struct {
		oldfd int
		newfd int
		flags int
	}{oldfd, newfd, flags})
	fake.recordInvocation("Dup3", []interface{}{oldfd, newfd, flags})
	fake.dup3Mutex.Unlock()
	if fake.Dup3Stub != nil {
		return fake.Dup3Stub(oldfd, newfd, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.dup3Returns.result1
}

func (fake *FakeSyscall) Dup3CallCount() int {
	fake.dup3Mutex.RLock()
	defer fake.dup3Mutex.RUnlock()
	return len(fake.dup3ArgsForCall)
}

func (fake *FakeSyscall) Dup3ArgsForCall(i int) (int, int, int) {
	fake.dup3Mutex.RLock()
	defer fake.dup3Mutex.RUnlock()
	return fake.dup3ArgsForCall[i].oldfd, fake.dup3ArgsForCall[i].newfd, fake.dup3ArgsForCall[i].flags
}

func (fake *FakeSyscall) Dup3Returns(result1 error) {
	fake.Dup3Stub = nil
	fake.dup3Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Dup3ReturnsOnCall(i int, result1 error) {
	fake.Dup3Stub = nil
	if fake.dup3ReturnsOnCall == nil {
		fake.dup3ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dup3ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) EpollCreate(size int) (fd int, err error) {
	fake.epollCreateMutex.Lock()
	ret, specificReturn := fake.epollCreateReturnsOnCall[len(fake.epollCreateArgsForCall)]
	fake.epollCreateArgsForCall = append(fake.epollCreateArgsForCall, struct {
		size int
	}{size})
	fake.recordInvocation("EpollCreate", []interface{}{size})
	fake.epollCreateMutex.Unlock()
	if fake.EpollCreateStub != nil {
		return fake.EpollCreateStub(size)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.epollCreateReturns.result1, fake.epollCreateReturns.result2
}

func (fake *FakeSyscall) EpollCreateCallCount() int {
	fake.epollCreateMutex.RLock()
	defer fake.epollCreateMutex.RUnlock()
	return len(fake.epollCreateArgsForCall)
}

func (fake *FakeSyscall) EpollCreateArgsForCall(i int) int {
	fake.epollCreateMutex.RLock()
	defer fake.epollCreateMutex.RUnlock()
	return fake.epollCreateArgsForCall[i].size
}

func (fake *FakeSyscall) EpollCreateReturns(result1 int, result2 error) {
	fake.EpollCreateStub = nil
	fake.epollCreateReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) EpollCreateReturnsOnCall(i int, result1 int, result2 error) {
	fake.EpollCreateStub = nil
	if fake.epollCreateReturnsOnCall == nil {
		fake.epollCreateReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.epollCreateReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) EpollCreate1(flag int) (fd int, err error) {
	fake.epollCreate1Mutex.Lock()
	ret, specificReturn := fake.epollCreate1ReturnsOnCall[len(fake.epollCreate1ArgsForCall)]
	fake.epollCreate1ArgsForCall = append(fake.epollCreate1ArgsForCall, struct {
		flag int
	}{flag})
	fake.recordInvocation("EpollCreate1", []interface{}{flag})
	fake.epollCreate1Mutex.Unlock()
	if fake.EpollCreate1Stub != nil {
		return fake.EpollCreate1Stub(flag)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.epollCreate1Returns.result1, fake.epollCreate1Returns.result2
}

func (fake *FakeSyscall) EpollCreate1CallCount() int {
	fake.epollCreate1Mutex.RLock()
	defer fake.epollCreate1Mutex.RUnlock()
	return len(fake.epollCreate1ArgsForCall)
}

func (fake *FakeSyscall) EpollCreate1ArgsForCall(i int) int {
	fake.epollCreate1Mutex.RLock()
	defer fake.epollCreate1Mutex.RUnlock()
	return fake.epollCreate1ArgsForCall[i].flag
}

func (fake *FakeSyscall) EpollCreate1Returns(result1 int, result2 error) {
	fake.EpollCreate1Stub = nil
	fake.epollCreate1Returns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) EpollCreate1ReturnsOnCall(i int, result1 int, result2 error) {
	fake.EpollCreate1Stub = nil
	if fake.epollCreate1ReturnsOnCall == nil {
		fake.epollCreate1ReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.epollCreate1ReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) EpollCtl(epfd int, op int, fd int, event *syscall.EpollEvent) (err error) {
	fake.epollCtlMutex.Lock()
	ret, specificReturn := fake.epollCtlReturnsOnCall[len(fake.epollCtlArgsForCall)]
	fake.epollCtlArgsForCall = append(fake.epollCtlArgsForCall, struct {
		epfd  int
		op    int
		fd    int
		event *syscall.EpollEvent
	}{epfd, op, fd, event})
	fake.recordInvocation("EpollCtl", []interface{}{epfd, op, fd, event})
	fake.epollCtlMutex.Unlock()
	if fake.EpollCtlStub != nil {
		return fake.EpollCtlStub(epfd, op, fd, event)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.epollCtlReturns.result1
}

func (fake *FakeSyscall) EpollCtlCallCount() int {
	fake.epollCtlMutex.RLock()
	defer fake.epollCtlMutex.RUnlock()
	return len(fake.epollCtlArgsForCall)
}

func (fake *FakeSyscall) EpollCtlArgsForCall(i int) (int, int, int, *syscall.EpollEvent) {
	fake.epollCtlMutex.RLock()
	defer fake.epollCtlMutex.RUnlock()
	return fake.epollCtlArgsForCall[i].epfd, fake.epollCtlArgsForCall[i].op, fake.epollCtlArgsForCall[i].fd, fake.epollCtlArgsForCall[i].event
}

func (fake *FakeSyscall) EpollCtlReturns(result1 error) {
	fake.EpollCtlStub = nil
	fake.epollCtlReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) EpollCtlReturnsOnCall(i int, result1 error) {
	fake.EpollCtlStub = nil
	if fake.epollCtlReturnsOnCall == nil {
		fake.epollCtlReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.epollCtlReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) EpollWait(epfd int, events []syscall.EpollEvent, msec int) (n int, err error) {
	var eventsCopy []syscall.EpollEvent
	if events != nil {
		eventsCopy = make([]syscall.EpollEvent, len(events))
		copy(eventsCopy, events)
	}
	fake.epollWaitMutex.Lock()
	ret, specificReturn := fake.epollWaitReturnsOnCall[len(fake.epollWaitArgsForCall)]
	fake.epollWaitArgsForCall = append(fake.epollWaitArgsForCall, struct {
		epfd   int
		events []syscall.EpollEvent
		msec   int
	}{epfd, eventsCopy, msec})
	fake.recordInvocation("EpollWait", []interface{}{epfd, eventsCopy, msec})
	fake.epollWaitMutex.Unlock()
	if fake.EpollWaitStub != nil {
		return fake.EpollWaitStub(epfd, events, msec)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.epollWaitReturns.result1, fake.epollWaitReturns.result2
}

func (fake *FakeSyscall) EpollWaitCallCount() int {
	fake.epollWaitMutex.RLock()
	defer fake.epollWaitMutex.RUnlock()
	return len(fake.epollWaitArgsForCall)
}

func (fake *FakeSyscall) EpollWaitArgsForCall(i int) (int, []syscall.EpollEvent, int) {
	fake.epollWaitMutex.RLock()
	defer fake.epollWaitMutex.RUnlock()
	return fake.epollWaitArgsForCall[i].epfd, fake.epollWaitArgsForCall[i].events, fake.epollWaitArgsForCall[i].msec
}

func (fake *FakeSyscall) EpollWaitReturns(result1 int, result2 error) {
	fake.EpollWaitStub = nil
	fake.epollWaitReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) EpollWaitReturnsOnCall(i int, result1 int, result2 error) {
	fake.EpollWaitStub = nil
	if fake.epollWaitReturnsOnCall == nil {
		fake.epollWaitReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.epollWaitReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {
	fake.faccessatMutex.Lock()
	ret, specificReturn := fake.faccessatReturnsOnCall[len(fake.faccessatArgsForCall)]
	fake.faccessatArgsForCall = append(fake.faccessatArgsForCall, struct {
		dirfd int
		path  string
		mode  uint32
		flags int
	}{dirfd, path, mode, flags})
	fake.recordInvocation("Faccessat", []interface{}{dirfd, path, mode, flags})
	fake.faccessatMutex.Unlock()
	if fake.FaccessatStub != nil {
		return fake.FaccessatStub(dirfd, path, mode, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.faccessatReturns.result1
}

func (fake *FakeSyscall) FaccessatCallCount() int {
	fake.faccessatMutex.RLock()
	defer fake.faccessatMutex.RUnlock()
	return len(fake.faccessatArgsForCall)
}

func (fake *FakeSyscall) FaccessatArgsForCall(i int) (int, string, uint32, int) {
	fake.faccessatMutex.RLock()
	defer fake.faccessatMutex.RUnlock()
	return fake.faccessatArgsForCall[i].dirfd, fake.faccessatArgsForCall[i].path, fake.faccessatArgsForCall[i].mode, fake.faccessatArgsForCall[i].flags
}

func (fake *FakeSyscall) FaccessatReturns(result1 error) {
	fake.FaccessatStub = nil
	fake.faccessatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FaccessatReturnsOnCall(i int, result1 error) {
	fake.FaccessatStub = nil
	if fake.faccessatReturnsOnCall == nil {
		fake.faccessatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.faccessatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	fake.fallocateMutex.Lock()
	ret, specificReturn := fake.fallocateReturnsOnCall[len(fake.fallocateArgsForCall)]
	fake.fallocateArgsForCall = append(fake.fallocateArgsForCall, struct {
		fd   int
		mode uint32
		off  int64
		len  int64
	}{fd, mode, off, len})
	fake.recordInvocation("Fallocate", []interface{}{fd, mode, off, len})
	fake.fallocateMutex.Unlock()
	if fake.FallocateStub != nil {
		return fake.FallocateStub(fd, mode, off, len)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fallocateReturns.result1
}

func (fake *FakeSyscall) FallocateCallCount() int {
	fake.fallocateMutex.RLock()
	defer fake.fallocateMutex.RUnlock()
	return len(fake.fallocateArgsForCall)
}

func (fake *FakeSyscall) FallocateArgsForCall(i int) (int, uint32, int64, int64) {
	fake.fallocateMutex.RLock()
	defer fake.fallocateMutex.RUnlock()
	return fake.fallocateArgsForCall[i].fd, fake.fallocateArgsForCall[i].mode, fake.fallocateArgsForCall[i].off, fake.fallocateArgsForCall[i].len
}

func (fake *FakeSyscall) FallocateReturns(result1 error) {
	fake.FallocateStub = nil
	fake.fallocateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FallocateReturnsOnCall(i int, result1 error) {
	fake.FallocateStub = nil
	if fake.fallocateReturnsOnCall == nil {
		fake.fallocateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fallocateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) {
	fake.fchmodatMutex.Lock()
	ret, specificReturn := fake.fchmodatReturnsOnCall[len(fake.fchmodatArgsForCall)]
	fake.fchmodatArgsForCall = append(fake.fchmodatArgsForCall, struct {
		dirfd int
		path  string
		mode  uint32
		flags int
	}{dirfd, path, mode, flags})
	fake.recordInvocation("Fchmodat", []interface{}{dirfd, path, mode, flags})
	fake.fchmodatMutex.Unlock()
	if fake.FchmodatStub != nil {
		return fake.FchmodatStub(dirfd, path, mode, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fchmodatReturns.result1
}

func (fake *FakeSyscall) FchmodatCallCount() int {
	fake.fchmodatMutex.RLock()
	defer fake.fchmodatMutex.RUnlock()
	return len(fake.fchmodatArgsForCall)
}

func (fake *FakeSyscall) FchmodatArgsForCall(i int) (int, string, uint32, int) {
	fake.fchmodatMutex.RLock()
	defer fake.fchmodatMutex.RUnlock()
	return fake.fchmodatArgsForCall[i].dirfd, fake.fchmodatArgsForCall[i].path, fake.fchmodatArgsForCall[i].mode, fake.fchmodatArgsForCall[i].flags
}

func (fake *FakeSyscall) FchmodatReturns(result1 error) {
	fake.FchmodatStub = nil
	fake.fchmodatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FchmodatReturnsOnCall(i int, result1 error) {
	fake.FchmodatStub = nil
	if fake.fchmodatReturnsOnCall == nil {
		fake.fchmodatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fchmodatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
	fake.fchownatMutex.Lock()
	ret, specificReturn := fake.fchownatReturnsOnCall[len(fake.fchownatArgsForCall)]
	fake.fchownatArgsForCall = append(fake.fchownatArgsForCall, struct {
		dirfd int
		path  string
		uid   int
		gid   int
		flags int
	}{dirfd, path, uid, gid, flags})
	fake.recordInvocation("Fchownat", []interface{}{dirfd, path, uid, gid, flags})
	fake.fchownatMutex.Unlock()
	if fake.FchownatStub != nil {
		return fake.FchownatStub(dirfd, path, uid, gid, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fchownatReturns.result1
}

func (fake *FakeSyscall) FchownatCallCount() int {
	fake.fchownatMutex.RLock()
	defer fake.fchownatMutex.RUnlock()
	return len(fake.fchownatArgsForCall)
}

func (fake *FakeSyscall) FchownatArgsForCall(i int) (int, string, int, int, int) {
	fake.fchownatMutex.RLock()
	defer fake.fchownatMutex.RUnlock()
	return fake.fchownatArgsForCall[i].dirfd, fake.fchownatArgsForCall[i].path, fake.fchownatArgsForCall[i].uid, fake.fchownatArgsForCall[i].gid, fake.fchownatArgsForCall[i].flags
}

func (fake *FakeSyscall) FchownatReturns(result1 error) {
	fake.FchownatStub = nil
	fake.fchownatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FchownatReturnsOnCall(i int, result1 error) {
	fake.FchownatStub = nil
	if fake.fchownatReturnsOnCall == nil {
		fake.fchownatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fchownatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fdatasync(fd int) (err error) {
	fake.fdatasyncMutex.Lock()
	ret, specificReturn := fake.fdatasyncReturnsOnCall[len(fake.fdatasyncArgsForCall)]
	fake.fdatasyncArgsForCall = append(fake.fdatasyncArgsForCall, struct {
		fd int
	}{fd})
	fake.recordInvocation("Fdatasync", []interface{}{fd})
	fake.fdatasyncMutex.Unlock()
	if fake.FdatasyncStub != nil {
		return fake.FdatasyncStub(fd)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fdatasyncReturns.result1
}

func (fake *FakeSyscall) FdatasyncCallCount() int {
	fake.fdatasyncMutex.RLock()
	defer fake.fdatasyncMutex.RUnlock()
	return len(fake.fdatasyncArgsForCall)
}

func (fake *FakeSyscall) FdatasyncArgsForCall(i int) int {
	fake.fdatasyncMutex.RLock()
	defer fake.fdatasyncMutex.RUnlock()
	return fake.fdatasyncArgsForCall[i].fd
}

func (fake *FakeSyscall) FdatasyncReturns(result1 error) {
	fake.FdatasyncStub = nil
	fake.fdatasyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FdatasyncReturnsOnCall(i int, result1 error) {
	fake.FdatasyncStub = nil
	if fake.fdatasyncReturnsOnCall == nil {
		fake.fdatasyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fdatasyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Getdents(fd int, buf []byte) (n int, err error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.getdentsMutex.Lock()
	ret, specificReturn := fake.getdentsReturnsOnCall[len(fake.getdentsArgsForCall)]
	fake.getdentsArgsForCall = append(fake.getdentsArgsForCall, struct {
		fd  int
		buf []byte
	}{fd, bufCopy})
	fake.recordInvocation("Getdents", []interface{}{fd, bufCopy})
	fake.getdentsMutex.Unlock()
	if fake.GetdentsStub != nil {
		return fake.GetdentsStub(fd, buf)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getdentsReturns.result1, fake.getdentsReturns.result2
}

func (fake *FakeSyscall) GetdentsCallCount() int {
	fake.getdentsMutex.RLock()
	defer fake.getdentsMutex.RUnlock()
	return len(fake.getdentsArgsForCall)
}

func (fake *FakeSyscall) GetdentsArgsForCall(i int) (int, []byte) {
	fake.getdentsMutex.RLock()
	defer fake.getdentsMutex.RUnlock()
	return fake.getdentsArgsForCall[i].fd, fake.getdentsArgsForCall[i].buf
}

func (fake *FakeSyscall) GetdentsReturns(result1 int, result2 error) {
	fake.GetdentsStub = nil
	fake.getdentsReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetdentsReturnsOnCall(i int, result1 int, result2 error) {
	fake.GetdentsStub = nil
	if fake.getdentsReturnsOnCall == nil {
		fake.getdentsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getdentsReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Gettid() (tid int) {
	fake.gettidMutex.Lock()
	ret, specificReturn := fake.gettidReturnsOnCall[len(fake.gettidArgsForCall)]
	fake.gettidArgsForCall = append(fake.gettidArgsForCall, struct{}{})
	fake.recordInvocation("Gettid", []interface{}{})
	fake.gettidMutex.Unlock()
	if fake.GettidStub != nil {
		return fake.GettidStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.gettidReturns.result1
}

func (fake *FakeSyscall) GettidCallCount() int {
	fake.gettidMutex.RLock()
	defer fake.gettidMutex.RUnlock()
	return len(fake.gettidArgsForCall)
}

func (fake *FakeSyscall) GettidReturns(result1 int) {
	fake.GettidStub = nil
	fake.gettidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) GettidReturnsOnCall(i int, result1 int) {
	fake.GettidStub = nil
	if fake.gettidReturnsOnCall == nil {
		fake.gettidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.gettidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSyscall) Getxattr(path string, attr string, dest []byte) (sz int, err error) {
	var destCopy []byte
	if dest != nil {
		destCopy = make([]byte, len(dest))
		copy(destCopy, dest)
	}
	fake.getxattrMutex.Lock()
	ret, specificReturn := fake.getxattrReturnsOnCall[len(fake.getxattrArgsForCall)]
	fake.getxattrArgsForCall = append(fake.getxattrArgsForCall, struct {
		path string
		attr string
		dest []byte
	}{path, attr, destCopy})
	fake.recordInvocation("Getxattr", []interface{}{path, attr, destCopy})
	fake.getxattrMutex.Unlock()
	if fake.GetxattrStub != nil {
		return fake.GetxattrStub(path, attr, dest)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getxattrReturns.result1, fake.getxattrReturns.result2
}

func (fake *FakeSyscall) GetxattrCallCount() int {
	fake.getxattrMutex.RLock()
	defer fake.getxattrMutex.RUnlock()
	return len(fake.getxattrArgsForCall)
}

func (fake *FakeSyscall) GetxattrArgsForCall(i int) (string, string, []byte) {
	fake.getxattrMutex.RLock()
	defer fake.getxattrMutex.RUnlock()
	return fake.getxattrArgsForCall[i].path, fake.getxattrArgsForCall[i].attr, fake.getxattrArgsForCall[i].dest
}

func (fake *FakeSyscall) GetxattrReturns(result1 int, result2 error) {
	fake.GetxattrStub = nil
	fake.getxattrReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetxattrReturnsOnCall(i int, result1 int, result2 error) {
	fake.GetxattrStub = nil
	if fake.getxattrReturnsOnCall == nil {
		fake.getxattrReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getxattrReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
	fake.inotifyAddWatchMutex.Lock()
	ret, specificReturn := fake.inotifyAddWatchReturnsOnCall[len(fake.inotifyAddWatchArgsForCall)]
	fake.inotifyAddWatchArgsForCall = append(fake.inotifyAddWatchArgsForCall, struct {
		fd       int
		pathname string
		mask     uint32
	}{fd, pathname, mask})
	fake.recordInvocation("InotifyAddWatch", []interface{}{fd, pathname, mask})
	fake.inotifyAddWatchMutex.Unlock()
	if fake.InotifyAddWatchStub != nil {
		return fake.InotifyAddWatchStub(fd, pathname, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.inotifyAddWatchReturns.result1, fake.inotifyAddWatchReturns.result2
}

func (fake *FakeSyscall) InotifyAddWatchCallCount() int {
	fake.inotifyAddWatchMutex.RLock()
	defer fake.inotifyAddWatchMutex.RUnlock()
	return len(fake.inotifyAddWatchArgsForCall)
}

func (fake *FakeSyscall) InotifyAddWatchArgsForCall(i int) (int, string, uint32) {
	fake.inotifyAddWatchMutex.RLock()
	defer fake.inotifyAddWatchMutex.RUnlock()
	return fake.inotifyAddWatchArgsForCall[i].fd, fake.inotifyAddWatchArgsForCall[i].pathname, fake.inotifyAddWatchArgsForCall[i].mask
}

func (fake *FakeSyscall) InotifyAddWatchReturns(result1 int, result2 error) {
	fake.InotifyAddWatchStub = nil
	fake.inotifyAddWatchReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) InotifyAddWatchReturnsOnCall(i int, result1 int, result2 error) {
	fake.InotifyAddWatchStub = nil
	if fake.inotifyAddWatchReturnsOnCall == nil {
		fake.inotifyAddWatchReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.inotifyAddWatchReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) InotifyInit1(flags int) (fd int, err error) {
	fake.inotifyInit1Mutex.Lock()
	ret, specificReturn := fake.inotifyInit1ReturnsOnCall[len(fake.inotifyInit1ArgsForCall)]
	fake.inotifyInit1ArgsForCall = append(fake.inotifyInit1ArgsForCall, struct {
		flags int
	}{flags})
	fake.recordInvocation("InotifyInit1", []interface{}{flags})
	fake.inotifyInit1Mutex.Unlock()
	if fake.InotifyInit1Stub != nil {
		return fake.InotifyInit1Stub(flags)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.inotifyInit1Returns.result1, fake.inotifyInit1Returns.result2
}

func (fake *FakeSyscall) InotifyInit1CallCount() int {
	fake.inotifyInit1Mutex.RLock()
	defer fake.inotifyInit1Mutex.RUnlock()
	return len(fake.inotifyInit1ArgsForCall)
}

func (fake *FakeSyscall) InotifyInit1ArgsForCall(i int) int {
	fake.inotifyInit1Mutex.RLock()
	defer fake.inotifyInit1Mutex.RUnlock()
	return fake.inotifyInit1ArgsForCall[i].flags
}

func (fake *FakeSyscall) InotifyInit1Returns(result1 int, result2 error) {
	fake.InotifyInit1Stub = nil
	fake.inotifyInit1Returns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) InotifyInit1ReturnsOnCall(i int, result1 int, result2 error) {
	fake.InotifyInit1Stub = nil
	if fake.inotifyInit1ReturnsOnCall == nil {
		fake.inotifyInit1ReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.inotifyInit1ReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) {
	fake.inotifyRmWatchMutex.Lock()
	ret, specificReturn := fake.inotifyRmWatchReturnsOnCall[len(fake.inotifyRmWatchArgsForCall)]
	fake.inotifyRmWatchArgsForCall = append(fake.inotifyRmWatchArgsForCall, struct {
		fd        int
		watchdesc uint32
	}{fd, watchdesc})
	fake.recordInvocation("InotifyRmWatch", []interface{}{fd, watchdesc})
	fake.inotifyRmWatchMutex.Unlock()
	if fake.InotifyRmWatchStub != nil {
		return fake.InotifyRmWatchStub(fd, watchdesc)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.inotifyRmWatchReturns.result1, fake.inotifyRmWatchReturns.result2
}

func (fake *FakeSyscall) InotifyRmWatchCallCount() int {
	fake.inotifyRmWatchMutex.RLock()
	defer fake.inotifyRmWatchMutex.RUnlock()
	return len(fake.inotifyRmWatchArgsForCall)
}

func (fake *FakeSyscall) InotifyRmWatchArgsForCall(i int) (int, uint32) {
	fake.inotifyRmWatchMutex.RLock()
	defer fake.inotifyRmWatchMutex.RUnlock()
	return fake.inotifyRmWatchArgsForCall[i].fd, fake.inotifyRmWatchArgsForCall[i].watchdesc
}

func (fake *FakeSyscall) InotifyRmWatchReturns(result1 int, result2 error) {
	fake.InotifyRmWatchStub = nil
	fake.inotifyRmWatchReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) InotifyRmWatchReturnsOnCall(i int, result1 int, result2 error) {
	fake.InotifyRmWatchStub = nil
	if fake.inotifyRmWatchReturnsOnCall == nil {
		fake.inotifyRmWatchReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.inotifyRmWatchReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Klogctl(typ int, buf []byte) (n int, err error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.klogctlMutex.Lock()
	ret, specificReturn := fake.klogctlReturnsOnCall[len(fake.klogctlArgsForCall)]
	fake.klogctlArgsForCall = append(fake.klogctlArgsForCall, struct {
		typ int
		buf []byte
	}{typ, bufCopy})
	fake.recordInvocation("Klogctl", []interface{}{typ, bufCopy})
	fake.klogctlMutex.Unlock()
	if fake.KlogctlStub != nil {
		return fake.KlogctlStub(typ, buf)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.klogctlReturns.result1, fake.klogctlReturns.result2
}

func (fake *FakeSyscall) KlogctlCallCount() int {
	fake.klogctlMutex.RLock()
	defer fake.klogctlMutex.RUnlock()
	return len(fake.klogctlArgsForCall)
}

func (fake *FakeSyscall) KlogctlArgsForCall(i int) (int, []byte) {
	fake.klogctlMutex.RLock()
	defer fake.klogctlMutex.RUnlock()
	return fake.klogctlArgsForCall[i].typ, fake.klogctlArgsForCall[i].buf
}

func (fake *FakeSyscall) KlogctlReturns(result1 int, result2 error) {
	fake.KlogctlStub = nil
	fake.klogctlReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) KlogctlReturnsOnCall(i int, result1 int, result2 error) {
	fake.KlogctlStub = nil
	if fake.klogctlReturnsOnCall == nil {
		fake.klogctlReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.klogctlReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Listxattr(path string, dest []byte) (sz int, err error) {
	var destCopy []byte
	if dest != nil {
		destCopy = make([]byte, len(dest))
		copy(destCopy, dest)
	}
	fake.listxattrMutex.Lock()
	ret, specificReturn := fake.listxattrReturnsOnCall[len(fake.listxattrArgsForCall)]
	fake.listxattrArgsForCall = append(fake.listxattrArgsForCall, struct {
		path string
		dest []byte
	}{path, destCopy})
	fake.recordInvocation("Listxattr", []interface{}{path, destCopy})
	fake.listxattrMutex.Unlock()
	if fake.ListxattrStub != nil {
		return fake.ListxattrStub(path, dest)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listxattrReturns.result1, fake.listxattrReturns.result2
}

func (fake *FakeSyscall) ListxattrCallCount() int {
	fake.listxattrMutex.RLock()
	defer fake.listxattrMutex.RUnlock()
	return len(fake.listxattrArgsForCall)
}

func (fake *FakeSyscall) ListxattrArgsForCall(i int) (string, []byte) {
	fake.listxattrMutex.RLock()
	defer fake.listxattrMutex.RUnlock()
	return fake.listxattrArgsForCall[i].path, fake.listxattrArgsForCall[i].dest
}

func (fake *FakeSyscall) ListxattrReturns(result1 int, result2 error) {
	fake.ListxattrStub = nil
	fake.listxattrReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ListxattrReturnsOnCall(i int, result1 int, result2 error) {
	fake.ListxattrStub = nil
	if fake.listxattrReturnsOnCall == nil {
		fake.listxattrReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.listxattrReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Mkdirat(dirfd int, path string, mode uint32) (err error) {
	fake.mkdiratMutex.Lock()
	ret, specificReturn := fake.mkdiratReturnsOnCall[len(fake.mkdiratArgsForCall)]
	fake.mkdiratArgsForCall = append(fake.mkdiratArgsForCall, struct {
		dirfd int
		path  string
		mode  uint32
	}{dirfd, path, mode})
	fake.recordInvocation("Mkdirat", []interface{}{dirfd, path, mode})
	fake.mkdiratMutex.Unlock()
	if fake.MkdiratStub != nil {
		return fake.MkdiratStub(dirfd, path, mode)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mkdiratReturns.result1
}

func (fake *FakeSyscall) MkdiratCallCount() int {
	fake.mkdiratMutex.RLock()
	defer fake.mkdiratMutex.RUnlock()
	return len(fake.mkdiratArgsForCall)
}

func (fake *FakeSyscall) MkdiratArgsForCall(i int) (int, string, uint32) {
	fake.mkdiratMutex.RLock()
	defer fake.mkdiratMutex.RUnlock()
	return fake.mkdiratArgsForCall[i].dirfd, fake.mkdiratArgsForCall[i].path, fake.mkdiratArgsForCall[i].mode
}

func (fake *FakeSyscall) MkdiratReturns(result1 error) {
	fake.MkdiratStub = nil
	fake.mkdiratReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MkdiratReturnsOnCall(i int, result1 error) {
	fake.MkdiratStub = nil
	if fake.mkdiratReturnsOnCall == nil {
		fake.mkdiratReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdiratReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
	fake.mknodatMutex.Lock()
	ret, specificReturn := fake.mknodatReturnsOnCall[len(fake.mknodatArgsForCall)]
	fake.mknodatArgsForCall = append(fake.mknodatArgsForCall, struct {
		dirfd int
		path  string
		mode  uint32
		dev   int
	}{dirfd, path, mode, dev})
	fake.recordInvocation("Mknodat", []interface{}{dirfd, path, mode, dev})
	fake.mknodatMutex.Unlock()
	if fake.MknodatStub != nil {
		return fake.MknodatStub(dirfd, path, mode, dev)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mknodatReturns.result1
}

func (fake *FakeSyscall) MknodatCallCount() int {
	fake.mknodatMutex.RLock()
	defer fake.mknodatMutex.RUnlock()
	return len(fake.mknodatArgsForCall)
}

func (fake *FakeSyscall) MknodatArgsForCall(i int) (int, string, uint32, int) {
	fake.mknodatMutex.RLock()
	defer fake.mknodatMutex.RUnlock()
	return fake.mknodatArgsForCall[i].dirfd, fake.mknodatArgsForCall[i].path, fake.mknodatArgsForCall[i].mode, fake.mknodatArgsForCall[i].dev
}

func (fake *FakeSyscall) MknodatReturns(result1 error) {
	fake.MknodatStub = nil
	fake.mknodatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MknodatReturnsOnCall(i int, result1 error) {
	fake.MknodatStub = nil
	if fake.mknodatReturnsOnCall == nil {
		fake.mknodatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mknodatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Pause() (err error) {
	fake.pauseMutex.Lock()
	ret, specificReturn := fake.pauseReturnsOnCall[len(fake.pauseArgsForCall)]
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct{}{})
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pauseReturns.result1
}

func (fake *FakeSyscall) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakeSyscall) PauseReturns(result1 error) {
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PauseReturnsOnCall(i int, result1 error) {
	fake.PauseStub = nil
	if fake.pauseReturnsOnCall == nil {
		fake.pauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PivotRoot(newroot string, putold string) (err error) {
	fake.pivotRootMutex.Lock()
	ret, specificReturn := fake.pivotRootReturnsOnCall[len(fake.pivotRootArgsForCall)]
	fake.pivotRootArgsForCall = append(fake.pivotRootArgsForCall, struct {
		newroot string
		putold  string
	}{newroot, putold})
	fake.recordInvocation("PivotRoot", []interface{}{newroot, putold})
	fake.pivotRootMutex.Unlock()
	if fake.PivotRootStub != nil {
		return fake.PivotRootStub(newroot, putold)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pivotRootReturns.result1
}

func (fake *FakeSyscall) PivotRootCallCount() int {
	fake.pivotRootMutex.RLock()
	defer fake.pivotRootMutex.RUnlock()
	return len(fake.pivotRootArgsForCall)
}

func (fake *FakeSyscall) PivotRootArgsForCall(i int) (string, string) {
	fake.pivotRootMutex.RLock()
	defer fake.pivotRootMutex.RUnlock()
	return fake.pivotRootArgsForCall[i].newroot, fake.pivotRootArgsForCall[i].putold
}

func (fake *FakeSyscall) PivotRootReturns(result1 error) {
	fake.PivotRootStub = nil
	fake.pivotRootReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PivotRootReturnsOnCall(i int, result1 error) {
	fake.PivotRootStub = nil
	if fake.pivotRootReturnsOnCall == nil {
		fake.pivotRootReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pivotRootReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Removexattr(path string, attr string) (err error) {
	fake.removexattrMutex.Lock()
	ret, specificReturn := fake.removexattrReturnsOnCall[len(fake.removexattrArgsForCall)]
	fake.removexattrArgsForCall = append(fake.removexattrArgsForCall, struct {
		path string
		attr string
	}{path, attr})
	fake.recordInvocation("Removexattr", []interface{}{path, attr})
	fake.removexattrMutex.Unlock()
	if fake.RemovexattrStub != nil {
		return fake.RemovexattrStub(path, attr)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removexattrReturns.result1
}

func (fake *FakeSyscall) RemovexattrCallCount() int {
	fake.removexattrMutex.RLock()
	defer fake.removexattrMutex.RUnlock()
	return len(fake.removexattrArgsForCall)
}

func (fake *FakeSyscall) RemovexattrArgsForCall(i int) (string, string) {
	fake.removexattrMutex.RLock()
	defer fake.removexattrMutex.RUnlock()
	return fake.removexattrArgsForCall[i].path, fake.removexattrArgsForCall[i].attr
}

func (fake *FakeSyscall) RemovexattrReturns(result1 error) {
	fake.RemovexattrStub = nil
	fake.removexattrReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RemovexattrReturnsOnCall(i int, result1 error) {
	fake.RemovexattrStub = nil
	if fake.removexattrReturnsOnCall == nil {
		fake.removexattrReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removexattrReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	fake.renameatMutex.Lock()
	ret, specificReturn := fake.renameatReturnsOnCall[len(fake.renameatArgsForCall)]
	fake.renameatArgsForCall = append(fake.renameatArgsForCall, struct {
		olddirfd int
		oldpath  string
		newdirfd int
		newpath  string
	}{olddirfd, oldpath, newdirfd, newpath})
	fake.recordInvocation("Renameat", []interface{}{olddirfd, oldpath, newdirfd, newpath})
	fake.renameatMutex.Unlock()
	if fake.RenameatStub != nil {
		return fake.RenameatStub(olddirfd, oldpath, newdirfd, newpath)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.renameatReturns.result1
}

func (fake *FakeSyscall) RenameatCallCount() int {
	fake.renameatMutex.RLock()
	defer fake.renameatMutex.RUnlock()
	return len(fake.renameatArgsForCall)
}

func (fake *FakeSyscall) RenameatArgsForCall(i int) (int, string, int, string) {
	fake.renameatMutex.RLock()
	defer fake.renameatMutex.RUnlock()
	return fake.renameatArgsForCall[i].olddirfd, fake.renameatArgsForCall[i].oldpath, fake.renameatArgsForCall[i].newdirfd, fake.renameatArgsForCall[i].newpath
}

func (fake *FakeSyscall) RenameatReturns(result1 error) {
	fake.RenameatStub = nil
	fake.renameatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RenameatReturnsOnCall(i int, result1 error) {
	fake.RenameatStub = nil
	if fake.renameatReturnsOnCall == nil {
		fake.renameatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setdomainname(p []byte) (err error) {
	var pCopy []byte
	if p != nil {
		pCopy = make([]byte, len(p))
		copy(pCopy, p)
	}
	fake.setdomainnameMutex.Lock()
	ret, specificReturn := fake.setdomainnameReturnsOnCall[len(fake.setdomainnameArgsForCall)]
	fake.setdomainnameArgsForCall = append(fake.setdomainnameArgsForCall, struct {
		p []byte
	}{pCopy})
	fake.recordInvocation("Setdomainname", []interface{}{pCopy})
	fake.setdomainnameMutex.Unlock()
	if fake.SetdomainnameStub != nil {
		return fake.SetdomainnameStub(p)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setdomainnameReturns.result1
}

func (fake *FakeSyscall) SetdomainnameCallCount() int {
	fake.setdomainnameMutex.RLock()
	defer fake.setdomainnameMutex.RUnlock()
	return len(fake.setdomainnameArgsForCall)
}

func (fake *FakeSyscall) SetdomainnameArgsForCall(i int) []byte {
	fake.setdomainnameMutex.RLock()
	defer fake.setdomainnameMutex.RUnlock()
	return fake.setdomainnameArgsForCall[i].p
}

func (fake *FakeSyscall) SetdomainnameReturns(result1 error) {
	fake.SetdomainnameStub = nil
	fake.setdomainnameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetdomainnameReturnsOnCall(i int, result1 error) {
	fake.SetdomainnameStub = nil
	if fake.setdomainnameReturnsOnCall == nil {
		fake.setdomainnameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setdomainnameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Sethostname(p []byte) (err error) {
	var pCopy []byte
	if p != nil {
		pCopy = make([]byte, len(p))
		copy(pCopy, p)
	}
	fake.sethostnameMutex.Lock()
	ret, specificReturn := fake.sethostnameReturnsOnCall[len(fake.sethostnameArgsForCall)]
	fake.sethostnameArgsForCall = append(fake.sethostnameArgsForCall, struct {
		p []byte
	}{pCopy})
	fake.recordInvocation("Sethostname", []interface{}{pCopy})
	fake.sethostnameMutex.Unlock()
	if fake.SethostnameStub != nil {
		return fake.SethostnameStub(p)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sethostnameReturns.result1
}

func (fake *FakeSyscall) SethostnameCallCount() int {
	fake.sethostnameMutex.RLock()
	defer fake.sethostnameMutex.RUnlock()
	return len(fake.sethostnameArgsForCall)
}

func (fake *FakeSyscall) SethostnameArgsForCall(i int) []byte {
	fake.sethostnameMutex.RLock()
	defer fake.sethostnameMutex.RUnlock()
	return fake.sethostnameArgsForCall[i].p
}

func (fake *FakeSyscall) SethostnameReturns(result1 error) {
	fake.SethostnameStub = nil
	fake.sethostnameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SethostnameReturnsOnCall(i int, result1 error) {
	fake.SethostnameStub = nil
	if fake.sethostnameReturnsOnCall == nil {
		fake.sethostnameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sethostnameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setxattr(path string, attr string, data []byte, flags int) (err error) {
	var dataCopy []byte
	if data != nil {
		dataCopy = make([]byte, len(data))
		copy(dataCopy, data)
	}
	fake.setxattrMutex.Lock()
	ret, specificReturn := fake.setxattrReturnsOnCall[len(fake.setxattrArgsForCall)]
	fake.setxattrArgsForCall = append(fake.setxattrArgsForCall, struct {
		path  string
		attr  string
		data  []byte
		flags int
	}{path, attr, dataCopy, flags})
	fake.recordInvocation("Setxattr", []interface{}{path, attr, dataCopy, flags})
	fake.setxattrMutex.Unlock()
	if fake.SetxattrStub != nil {
		return fake.SetxattrStub(path, attr, data, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setxattrReturns.result1
}

func (fake *FakeSyscall) SetxattrCallCount() int {
	fake.setxattrMutex.RLock()
	defer fake.setxattrMutex.RUnlock()
	return len(fake.setxattrArgsForCall)
}

func (fake *FakeSyscall) SetxattrArgsForCall(i int) (string, string, []byte, int) {
	fake.setxattrMutex.RLock()
	defer fake.setxattrMutex.RUnlock()
	return fake.setxattrArgsForCall[i].path, fake.setxattrArgsForCall[i].attr, fake.setxattrArgsForCall[i].data, fake.setxattrArgsForCall[i].flags
}

func (fake *FakeSyscall) SetxattrReturns(result1 error) {
	fake.SetxattrStub = nil
	fake.setxattrReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetxattrReturnsOnCall(i int, result1 error) {
	fake.SetxattrStub = nil
	if fake.setxattrReturnsOnCall == nil {
		fake.setxattrReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setxattrReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Sysinfo(info *syscall.Sysinfo_t) (err error) {
	fake.sysinfoMutex.Lock()
	ret, specificReturn := fake.sysinfoReturnsOnCall[len(fake.sysinfoArgsForCall)]
	fake.sysinfoArgsForCall = append(fake.sysinfoArgsForCall, struct {
		info *syscall.Sysinfo_t
	}{info})
	fake.recordInvocation("Sysinfo", []interface{}{info})
	fake.sysinfoMutex.Unlock()
	if fake.SysinfoStub != nil {
		return fake.SysinfoStub(info)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sysinfoReturns.result1
}

func (fake *FakeSyscall) SysinfoCallCount() int {
	fake.sysinfoMutex.RLock()
	defer fake.sysinfoMutex.RUnlock()
	return len(fake.sysinfoArgsForCall)
}

func (fake *FakeSyscall) SysinfoArgsForCall(i int) *syscall.Sysinfo_t {
	fake.sysinfoMutex.RLock()
	defer fake.sysinfoMutex.RUnlock()
	return fake.sysinfoArgsForCall[i].info
}

func (fake *FakeSyscall) SysinfoReturns(result1 error) {
	fake.SysinfoStub = nil
	fake.sysinfoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SysinfoReturnsOnCall(i int, result1 error) {
	fake.SysinfoStub = nil
	if fake.sysinfoReturnsOnCall == nil {
		fake.sysinfoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sysinfoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
	fake.teeMutex.Lock()
	ret, specificReturn := fake.teeReturnsOnCall[len(fake.teeArgsForCall)]
	fake.teeArgsForCall = append(fake.teeArgsForCall, struct {
		rfd   int
		wfd   int
		len   int
		flags int
	}{rfd, wfd, len, flags})
	fake.recordInvocation("Tee", []interface{}{rfd, wfd, len, flags})
	fake.teeMutex.Unlock()
	if fake.TeeStub != nil {
		return fake.TeeStub(rfd, wfd, len, flags)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.teeReturns.result1, fake.teeReturns.result2
}

func (fake *FakeSyscall) TeeCallCount() int {
	fake.teeMutex.RLock()
	defer fake.teeMutex.RUnlock()
	return len(fake.teeArgsForCall)
}

func (fake *FakeSyscall) TeeArgsForCall(i int) (int, int, int, int) {
	fake.teeMutex.RLock()
	defer fake.teeMutex.RUnlock()
	return fake.teeArgsForCall[i].rfd, fake.teeArgsForCall[i].wfd, fake.teeArgsForCall[i].len, fake.teeArgsForCall[i].flags
}

func (fake *FakeSyscall) TeeReturns(result1 int64, result2 error) {
	fake.TeeStub = nil
	fake.teeReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) TeeReturnsOnCall(i int, result1 int64, result2 error) {
	fake.TeeStub = nil
	if fake.teeReturnsOnCall == nil {
		fake.teeReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.teeReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Tgkill(tgid int, tid int, sig syscall.Signal) (err error) {
	fake.tgkillMutex.Lock()
	ret, specificReturn := fake.tgkillReturnsOnCall[len(fake.tgkillArgsForCall)]
	fake.tgkillArgsForCall = append(fake.tgkillArgsForCall, struct {
		tgid int
		tid  int
		sig  syscall.Signal
	}{tgid, tid, sig})
	fake.recordInvocation("Tgkill", []interface{}{tgid, tid, sig})
	fake.tgkillMutex.Unlock()
	if fake.TgkillStub != nil {
		return fake.TgkillStub(tgid, tid, sig)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.tgkillReturns.result1
}

func (fake *FakeSyscall) TgkillCallCount() int {
	fake.tgkillMutex.RLock()
	defer fake.tgkillMutex.RUnlock()
	return len(fake.tgkillArgsForCall)
}

func (fake *FakeSyscall) TgkillArgsForCall(i int) (int, int, syscall.Signal) {
	fake.tgkillMutex.RLock()
	defer fake.tgkillMutex.RUnlock()
	return fake.tgkillArgsForCall[i].tgid, fake.tgkillArgsForCall[i].tid, fake.tgkillArgsForCall[i].sig
}

func (fake *FakeSyscall) TgkillReturns(result1 error) {
	fake.TgkillStub = nil
	fake.tgkillReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) TgkillReturnsOnCall(i int, result1 error) {
	fake.TgkillStub = nil
	if fake.tgkillReturnsOnCall == nil {
		fake.tgkillReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.tgkillReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Times(tms *syscall.Tms) (ticks uintptr, err error) {
	fake.timesMutex.Lock()
	ret, specificReturn := fake.timesReturnsOnCall[len(fake.timesArgsForCall)]
	fake.timesArgsForCall = append(fake.timesArgsForCall, struct {
		tms *syscall.Tms
	}{tms})
	fake.recordInvocation("Times", []interface{}{tms})
	fake.timesMutex.Unlock()
	if fake.TimesStub != nil {
		return fake.TimesStub(tms)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.timesReturns.result1, fake.timesReturns.result2
}

func (fake *FakeSyscall) TimesCallCount() int {
	fake.timesMutex.RLock()
	defer fake.timesMutex.RUnlock()
	return len(fake.timesArgsForCall)
}

func (fake *FakeSyscall) TimesArgsForCall(i int) *syscall.Tms {
	fake.timesMutex.RLock()
	defer fake.timesMutex.RUnlock()
	return fake.timesArgsForCall[i].tms
}

func (fake *FakeSyscall) TimesReturns(result1 uintptr, result2 error) {
	fake.TimesStub = nil
	fake.timesReturns = struct {
		result1 uintptr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) TimesReturnsOnCall(i int, result1 uintptr, result2 error) {
	fake.TimesStub = nil
	if fake.timesReturnsOnCall == nil {
		fake.timesReturnsOnCall = make(map[int]struct {
			result1 uintptr
			result2 error
		})
	}
	fake.timesReturnsOnCall[i] = struct {
		result1 uintptr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Uname(buf *syscall.Utsname) (err error) {
	fake.unameMutex.Lock()
	ret, specificReturn := fake.unameReturnsOnCall[len(fake.unameArgsForCall)]
	fake.unameArgsForCall = append(fake.unameArgsForCall, struct {
		buf *syscall.Utsname
	}{buf})
	fake.recordInvocation("Uname", []interface{}{buf})
	fake.unameMutex.Unlock()
	if fake.UnameStub != nil {
		return fake.UnameStub(buf)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unameReturns.result1
}

func (fake *FakeSyscall) UnameCallCount() int {
	fake.unameMutex.RLock()
	defer fake.unameMutex.RUnlock()
	return len(fake.unameArgsForCall)
}

func (fake *FakeSyscall) UnameArgsForCall(i int) *syscall.Utsname {
	fake.unameMutex.RLock()
	defer fake.unameMutex.RUnlock()
	return fake.unameArgsForCall[i].buf
}

func (fake *FakeSyscall) UnameReturns(result1 error) {
	fake.UnameStub = nil
	fake.unameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UnameReturnsOnCall(i int, result1 error) {
	fake.UnameStub = nil
	if fake.unameReturnsOnCall == nil {
		fake.unameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Unshare(flags int) (err error) {
	fake.unshareMutex.Lock()
	ret, specificReturn := fake.unshareReturnsOnCall[len(fake.unshareArgsForCall)]
	fake.unshareArgsForCall = append(fake.unshareArgsForCall, struct {
		flags int
	}{flags})
	fake.recordInvocation("Unshare", []interface{}{flags})
	fake.unshareMutex.Unlock()
	if fake.UnshareStub != nil {
		return fake.UnshareStub(flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unshareReturns.result1
}

func (fake *FakeSyscall) UnshareCallCount() int {
	fake.unshareMutex.RLock()
	defer fake.unshareMutex.RUnlock()
	return len(fake.unshareArgsForCall)
}

func (fake *FakeSyscall) UnshareArgsForCall(i int) int {
	fake.unshareMutex.RLock()
	defer fake.unshareMutex.RUnlock()
	return fake.unshareArgsForCall[i].flags
}

func (fake *FakeSyscall) UnshareReturns(result1 error) {
	fake.UnshareStub = nil
	fake.unshareReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UnshareReturnsOnCall(i int, result1 error) {
	fake.UnshareStub = nil
	if fake.unshareReturnsOnCall == nil {
		fake.unshareReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unshareReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Ustat(dev int, ubuf *syscall.Ustat_t) (err error) {
	fake.ustatMutex.Lock()
	ret, specificReturn := fake.ustatReturnsOnCall[len(fake.ustatArgsForCall)]
	fake.ustatArgsForCall = append(fake.ustatArgsForCall, struct {
		dev  int
		ubuf *syscall.Ustat_t
	}{dev, ubuf})
	fake.recordInvocation("Ustat", []interface{}{dev, ubuf})
	fake.ustatMutex.Unlock()
	if fake.UstatStub != nil {
		return fake.UstatStub(dev, ubuf)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ustatReturns.result1
}

func (fake *FakeSyscall) UstatCallCount() int {
	fake.ustatMutex.RLock()
	defer fake.ustatMutex.RUnlock()
	return len(fake.ustatArgsForCall)
}

func (fake *FakeSyscall) UstatArgsForCall(i int) (int, *syscall.Ustat_t) {
	fake.ustatMutex.RLock()
	defer fake.ustatMutex.RUnlock()
	return fake.ustatArgsForCall[i].dev, fake.ustatArgsForCall[i].ubuf
}

func (fake *FakeSyscall) UstatReturns(result1 error) {
	fake.UstatStub = nil
	fake.ustatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UstatReturnsOnCall(i int, result1 error) {
	fake.UstatStub = nil
	if fake.ustatReturnsOnCall == nil {
		fake.ustatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ustatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Utime(path string, buf *syscall.Utimbuf) (err error) {
	fake.utimeMutex.Lock()
	ret, specificReturn := fake.utimeReturnsOnCall[len(fake.utimeArgsForCall)]
	fake.utimeArgsForCall = append(fake.utimeArgsForCall, struct {
		path string
		buf  *syscall.Utimbuf
	}{path, buf})
	fake.recordInvocation("Utime", []interface{}{path, buf})
	fake.utimeMutex.Unlock()
	if fake.UtimeStub != nil {
		return fake.UtimeStub(path, buf)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.utimeReturns.result1
}

func (fake *FakeSyscall) UtimeCallCount() int {
	fake.utimeMutex.RLock()
	defer fake.utimeMutex.RUnlock()
	return len(fake.utimeArgsForCall)
}

func (fake *FakeSyscall) UtimeArgsForCall(i int) (string, *syscall.Utimbuf) {
	fake.utimeMutex.RLock()
	defer fake.utimeMutex.RUnlock()
	return fake.utimeArgsForCall[i].path, fake.utimeArgsForCall[i].buf
}

func (fake *FakeSyscall) UtimeReturns(result1 error) {
	fake.UtimeStub = nil
	fake.utimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UtimeReturnsOnCall(i int, result1 error) {
	fake.UtimeStub = nil
	if fake.utimeReturnsOnCall == nil {
		fake.utimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.utimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Madvise(b []byte, advice int) (err error) {
	var bCopy []byte
	if b != nil {
		bCopy = make([]byte, len(b))
		copy(bCopy, b)
	}
	fake.madviseMutex.Lock()
	ret, specificReturn := fake.madviseReturnsOnCall[len(fake.madviseArgsForCall)]
	fake.madviseArgsForCall = append(fake.madviseArgsForCall, struct {
		b      []byte
		advice int
	}{bCopy, advice})
	fake.recordInvocation("Madvise", []interface{}{bCopy, advice})
	fake.madviseMutex.Unlock()
	if fake.MadviseStub != nil {
		return fake.MadviseStub(b, advice)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.madviseReturns.result1
}

func (fake *FakeSyscall) MadviseCallCount() int {
	fake.madviseMutex.RLock()
	defer fake.madviseMutex.RUnlock()
	return len(fake.madviseArgsForCall)
}

func (fake *FakeSyscall) MadviseArgsForCall(i int) ([]byte, int) {
	fake.madviseMutex.RLock()
	defer fake.madviseMutex.RUnlock()
	return fake.madviseArgsForCall[i].b, fake.madviseArgsForCall[i].advice
}

func (fake *FakeSyscall) MadviseReturns(result1 error) {
	fake.MadviseStub = nil
	fake.madviseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MadviseReturnsOnCall(i int, result1 error) {
	fake.MadviseStub = nil
	if fake.madviseReturnsOnCall == nil {
		fake.madviseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.madviseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setfsgid(gid int) (err error) {
	fake.setfsgidMutex.Lock()
	ret, specificReturn := fake.setfsgidReturnsOnCall[len(fake.setfsgidArgsForCall)]
	fake.setfsgidArgsForCall = append(fake.setfsgidArgsForCall, struct {
		gid int
	}{gid})
	fake.recordInvocation("Setfsgid", []interface{}{gid})
	fake.setfsgidMutex.Unlock()
	if fake.SetfsgidStub != nil {
		return fake.SetfsgidStub(gid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setfsgidReturns.result1
}

func (fake *FakeSyscall) SetfsgidCallCount() int {
	fake.setfsgidMutex.RLock()
	defer fake.setfsgidMutex.RUnlock()
	return len(fake.setfsgidArgsForCall)
}

func (fake *FakeSyscall) SetfsgidArgsForCall(i int) int {
	fake.setfsgidMutex.RLock()
	defer fake.setfsgidMutex.RUnlock()
	return fake.setfsgidArgsForCall[i].gid
}

func (fake *FakeSyscall) SetfsgidReturns(result1 error) {
	fake.SetfsgidStub = nil
	fake.setfsgidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetfsgidReturnsOnCall(i int, result1 error) {
	fake.SetfsgidStub = nil
	if fake.setfsgidReturnsOnCall == nil {
		fake.setfsgidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setfsgidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setfsuid(uid int) (err error) {
	fake.setfsuidMutex.Lock()
	ret, specificReturn := fake.setfsuidReturnsOnCall[len(fake.setfsuidArgsForCall)]
	fake.setfsuidArgsForCall = append(fake.setfsuidArgsForCall, struct {
		uid int
	}{uid})
	fake.recordInvocation("Setfsuid", []interface{}{uid})
	fake.setfsuidMutex.Unlock()
	if fake.SetfsuidStub != nil {
		return fake.SetfsuidStub(uid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setfsuidReturns.result1
}

func (fake *FakeSyscall) SetfsuidCallCount() int {
	fake.setfsuidMutex.RLock()
	defer fake.setfsuidMutex.RUnlock()
	return len(fake.setfsuidArgsForCall)
}

func (fake *FakeSyscall) SetfsuidArgsForCall(i int) int {
	fake.setfsuidMutex.RLock()
	defer fake.setfsuidMutex.RUnlock()
	return fake.setfsuidArgsForCall[i].uid
}

func (fake *FakeSyscall) SetfsuidReturns(result1 error) {
	fake.SetfsuidStub = nil
	fake.setfsuidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetfsuidReturnsOnCall(i int, result1 error) {
	fake.SetfsuidStub = nil
	if fake.setfsuidReturnsOnCall == nil {
		fake.setfsuidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setfsuidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setresgid(rgid int, egid int, sgid int) (err error) {
	fake.setresgidMutex.Lock()
	ret, specificReturn := fake.setresgidReturnsOnCall[len(fake.setresgidArgsForCall)]
	fake.setresgidArgsForCall = append(fake.setresgidArgsForCall, struct {
		rgid int
		egid int
		sgid int
	}{rgid, egid, sgid})
	fake.recordInvocation("Setresgid", []interface{}{rgid, egid, sgid})
	fake.setresgidMutex.Unlock()
	if fake.SetresgidStub != nil {
		return fake.SetresgidStub(rgid, egid, sgid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setresgidReturns.result1
}

func (fake *FakeSyscall) SetresgidCallCount() int {
	fake.setresgidMutex.RLock()
	defer fake.setresgidMutex.RUnlock()
	return len(fake.setresgidArgsForCall)
}

func (fake *FakeSyscall) SetresgidArgsForCall(i int) (int, int, int) {
	fake.setresgidMutex.RLock()
	defer fake.setresgidMutex.RUnlock()
	return fake.setresgidArgsForCall[i].rgid, fake.setresgidArgsForCall[i].egid, fake.setresgidArgsForCall[i].sgid
}

func (fake *FakeSyscall) SetresgidReturns(result1 error) {
	fake.SetresgidStub = nil
	fake.setresgidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetresgidReturnsOnCall(i int, result1 error) {
	fake.SetresgidStub = nil
	if fake.setresgidReturnsOnCall == nil {
		fake.setresgidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setresgidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setresuid(ruid int, euid int, suid int) (err error) {
	fake.setresuidMutex.Lock()
	ret, specificReturn := fake.setresuidReturnsOnCall[len(fake.setresuidArgsForCall)]
	fake.setresuidArgsForCall = append(fake.setresuidArgsForCall, struct {
		ruid int
		euid int
		suid int
	}{ruid, euid, suid})
	fake.recordInvocation("Setresuid", []interface{}{ruid, euid, suid})
	fake.setresuidMutex.Unlock()
	if fake.SetresuidStub != nil {
		return fake.SetresuidStub(ruid, euid, suid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setresuidReturns.result1
}

func (fake *FakeSyscall) SetresuidCallCount() int {
	fake.setresuidMutex.RLock()
	defer fake.setresuidMutex.RUnlock()
	return len(fake.setresuidArgsForCall)
}

func (fake *FakeSyscall) SetresuidArgsForCall(i int) (int, int, int) {
	fake.setresuidMutex.RLock()
	defer fake.setresuidMutex.RUnlock()
	return fake.setresuidArgsForCall[i].ruid, fake.setresuidArgsForCall[i].euid, fake.setresuidArgsForCall[i].suid
}

func (fake *FakeSyscall) SetresuidReturns(result1 error) {
	fake.SetresuidStub = nil
	fake.setresuidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetresuidReturnsOnCall(i int, result1 error) {
	fake.SetresuidStub = nil
	if fake.setresuidReturnsOnCall == nil {
		fake.setresuidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setresuidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) {
	fake.spliceMutex.Lock()
	ret, specificReturn := fake.spliceReturnsOnCall[len(fake.spliceArgsForCall)]
	fake.spliceArgsForCall = append(fake.spliceArgsForCall, struct {
		rfd   int
		roff  *int64
		wfd   int
		woff  *int64
		len   int
		flags int
	}{rfd, roff, wfd, woff, len, flags})
	fake.recordInvocation("Splice", []interface{}{rfd, roff, wfd, woff, len, flags})
	fake.spliceMutex.Unlock()
	if fake.SpliceStub != nil {
		return fake.SpliceStub(rfd, roff, wfd, woff, len, flags)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.spliceReturns.result1, fake.spliceReturns.result2
}

func (fake *FakeSyscall) SpliceCallCount() int {
	fake.spliceMutex.RLock()
	defer fake.spliceMutex.RUnlock()
	return len(fake.spliceArgsForCall)
}

func (fake *FakeSyscall) SpliceArgsForCall(i int) (int, *int64, int, *int64, int, int) {
	fake.spliceMutex.RLock()
	defer fake.spliceMutex.RUnlock()
	return fake.spliceArgsForCall[i].rfd, fake.spliceArgsForCall[i].roff, fake.spliceArgsForCall[i].wfd, fake.spliceArgsForCall[i].woff, fake.spliceArgsForCall[i].len, fake.spliceArgsForCall[i].flags
}

func (fake *FakeSyscall) SpliceReturns(result1 int, result2 error) {
	fake.SpliceStub = nil
	fake.spliceReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SpliceReturnsOnCall(i int, result1 int, result2 error) {
	fake.SpliceStub = nil
	if fake.spliceReturnsOnCall == nil {
		fake.spliceReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.spliceReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SyncFileRange(fd int, off int64, n int64, flags int) (err error) {
	fake.syncFileRangeMutex.Lock()
	ret, specificReturn := fake.syncFileRangeReturnsOnCall[len(fake.syncFileRangeArgsForCall)]
	fake.syncFileRangeArgsForCall = append(fake.syncFileRangeArgsForCall, struct {
		fd    int
		off   int64
		n     int64
		flags int
	}{fd, off, n, flags})
	fake.recordInvocation("SyncFileRange", []interface{}{fd, off, n, flags})
	fake.syncFileRangeMutex.Unlock()
	if fake.SyncFileRangeStub != nil {
		return fake.SyncFileRangeStub(fd, off, n, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.syncFileRangeReturns.result1
}

func (fake *FakeSyscall) SyncFileRangeCallCount() int {
	fake.syncFileRangeMutex.RLock()
	defer fake.syncFileRangeMutex.RUnlock()
	return len(fake.syncFileRangeArgsForCall)
}

func (fake *FakeSyscall) SyncFileRangeArgsForCall(i int) (int, int64, int64, int) {
	fake.syncFileRangeMutex.RLock()
	defer fake.syncFileRangeMutex.RUnlock()
	return fake.syncFileRangeArgsForCall[i].fd, fake.syncFileRangeArgsForCall[i].off, fake.syncFileRangeArgsForCall[i].n, fake.syncFileRangeArgsForCall[i].flags
}

func (fake *FakeSyscall) SyncFileRangeReturns(result1 error) {
	fake.SyncFileRangeStub = nil
	fake.syncFileRangeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SyncFileRangeReturnsOnCall(i int, result1 error) {
	fake.SyncFileRangeStub = nil
	if fake.syncFileRangeReturnsOnCall == nil {
		fake.syncFileRangeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.syncFileRangeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fstatat(fd int, path string, stat *syscall.Stat_t, flags int) (err error) {
	fake.fstatatMutex.Lock()
	ret, specificReturn := fake.fstatatReturnsOnCall[len(fake.fstatatArgsForCall)]
	fake.fstatatArgsForCall = append(fake.fstatatArgsForCall, struct {
		fd    int
		path  string
		stat  *syscall.Stat_t
		flags int
	}{fd, path, stat, flags})
	fake.recordInvocation("Fstatat", []interface{}{fd, path, stat, flags})
	fake.fstatatMutex.Unlock()
	if fake.FstatatStub != nil {
		return fake.FstatatStub(fd, path, stat, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fstatatReturns.result1
}

func (fake *FakeSyscall) FstatatCallCount() int {
	fake.fstatatMutex.RLock()
	defer fake.fstatatMutex.RUnlock()
	return len(fake.fstatatArgsForCall)
}

func (fake *FakeSyscall) FstatatArgsForCall(i int) (int, string, *syscall.Stat_t, int) {
	fake.fstatatMutex.RLock()
	defer fake.fstatatMutex.RUnlock()
	return fake.fstatatArgsForCall[i].fd, fake.fstatatArgsForCall[i].path, fake.fstatatArgsForCall[i].stat, fake.fstatatArgsForCall[i].flags
}

func (fake *FakeSyscall) FstatatReturns(result1 error) {
	fake.FstatatStub = nil
	fake.fstatatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FstatatReturnsOnCall(i int, result1 error) {
	fake.FstatatStub = nil
	if fake.fstatatReturnsOnCall == nil {
		fake.fstatatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fstatatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Fwstat(fd int, edir []byte) (err error) {
	var edirCopy []byte
	if edir != nil {
		edirCopy = make([]byte, len(edir))
		copy(edirCopy, edir)
	}
	fake.fwstatMutex.Lock()
	ret, specificReturn := fake.fwstatReturnsOnCall[len(fake.fwstatArgsForCall)]
	fake.fwstatArgsForCall = append(fake.fwstatArgsForCall, struct {
		fd   int
		edir []byte
	}{fd, edirCopy})
	fake.recordInvocation("Fwstat", []interface{}{fd, edirCopy})
	fake.fwstatMutex.Unlock()
	if fake.FwstatStub != nil {
		return fake.FwstatStub(fd, edir)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fwstatReturns.result1
}

func (fake *FakeSyscall) FwstatCallCount() int {
	fake.fwstatMutex.RLock()
	defer fake.fwstatMutex.RUnlock()
	return len(fake.fwstatArgsForCall)
}

func (fake *FakeSyscall) FwstatArgsForCall(i int) (int, []byte) {
	fake.fwstatMutex.RLock()
	defer fake.fwstatMutex.RUnlock()
	return fake.fwstatArgsForCall[i].fd, fake.fwstatArgsForCall[i].edir
}

func (fake *FakeSyscall) FwstatReturns(result1 error) {
	fake.FwstatStub = nil
	fake.fwstatReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FwstatReturnsOnCall(i int, result1 error) {
	fake.FwstatStub = nil
	if fake.fwstatReturnsOnCall == nil {
		fake.fwstatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fwstatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetLastError() (lasterr error) {
	fake.getLastErrorMutex.Lock()
	ret, specificReturn := fake.getLastErrorReturnsOnCall[len(fake.getLastErrorArgsForCall)]
	fake.getLastErrorArgsForCall = append(fake.getLastErrorArgsForCall, struct{}{})
	fake.recordInvocation("GetLastError", []interface{}{})
	fake.getLastErrorMutex.Unlock()
	if fake.GetLastErrorStub != nil {
		return fake.GetLastErrorStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getLastErrorReturns.result1
}

func (fake *FakeSyscall) GetLastErrorCallCount() int {
	fake.getLastErrorMutex.RLock()
	defer fake.getLastErrorMutex.RUnlock()
	return len(fake.getLastErrorArgsForCall)
}

func (fake *FakeSyscall) GetLastErrorReturns(result1 error) {
	fake.GetLastErrorStub = nil
	fake.getLastErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetLastErrorReturnsOnCall(i int, result1 error) {
	fake.GetLastErrorStub = nil
	if fake.getLastErrorReturnsOnCall == nil {
		fake.getLastErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getLastErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LoadLibrary(libname string) (handle syscall.Handle, err error) {
	fake.loadLibraryMutex.Lock()
	ret, specificReturn := fake.loadLibraryReturnsOnCall[len(fake.loadLibraryArgsForCall)]
	fake.loadLibraryArgsForCall = append(fake.loadLibraryArgsForCall, struct {
		libname string
	}{libname})
	fake.recordInvocation("LoadLibrary", []interface{}{libname})
	fake.loadLibraryMutex.Unlock()
	if fake.LoadLibraryStub != nil {
		return fake.LoadLibraryStub(libname)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.loadLibraryReturns.result1, fake.loadLibraryReturns.result2
}

func (fake *FakeSyscall) LoadLibraryCallCount() int {
	fake.loadLibraryMutex.RLock()
	defer fake.loadLibraryMutex.RUnlock()
	return len(fake.loadLibraryArgsForCall)
}

func (fake *FakeSyscall) LoadLibraryArgsForCall(i int) string {
	fake.loadLibraryMutex.RLock()
	defer fake.loadLibraryMutex.RUnlock()
	return fake.loadLibraryArgsForCall[i].libname
}

func (fake *FakeSyscall) LoadLibraryReturns(result1 syscall.Handle, result2 error) {
	fake.LoadLibraryStub = nil
	fake.loadLibraryReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) LoadLibraryReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.LoadLibraryStub = nil
	if fake.loadLibraryReturnsOnCall == nil {
		fake.loadLibraryReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.loadLibraryReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) FreeLibrary(handle syscall.Handle) (err error) {
	fake.freeLibraryMutex.Lock()
	ret, specificReturn := fake.freeLibraryReturnsOnCall[len(fake.freeLibraryArgsForCall)]
	fake.freeLibraryArgsForCall = append(fake.freeLibraryArgsForCall, struct {
		handle syscall.Handle
	}{handle})
	fake.recordInvocation("FreeLibrary", []interface{}{handle})
	fake.freeLibraryMutex.Unlock()
	if fake.FreeLibraryStub != nil {
		return fake.FreeLibraryStub(handle)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.freeLibraryReturns.result1
}

func (fake *FakeSyscall) FreeLibraryCallCount() int {
	fake.freeLibraryMutex.RLock()
	defer fake.freeLibraryMutex.RUnlock()
	return len(fake.freeLibraryArgsForCall)
}

func (fake *FakeSyscall) FreeLibraryArgsForCall(i int) syscall.Handle {
	fake.freeLibraryMutex.RLock()
	defer fake.freeLibraryMutex.RUnlock()
	return fake.freeLibraryArgsForCall[i].handle
}

func (fake *FakeSyscall) FreeLibraryReturns(result1 error) {
	fake.FreeLibraryStub = nil
	fake.freeLibraryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FreeLibraryReturnsOnCall(i int, result1 error) {
	fake.FreeLibraryStub = nil
	if fake.freeLibraryReturnsOnCall == nil {
		fake.freeLibraryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.freeLibraryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetProcAddress(module syscall.Handle, procname string) (proc uintptr, err error) {
	fake.getProcAddressMutex.Lock()
	ret, specificReturn := fake.getProcAddressReturnsOnCall[len(fake.getProcAddressArgsForCall)]
	fake.getProcAddressArgsForCall = append(fake.getProcAddressArgsForCall, struct {
		module   syscall.Handle
		procname string
	}{module, procname})
	fake.recordInvocation("GetProcAddress", []interface{}{module, procname})
	fake.getProcAddressMutex.Unlock()
	if fake.GetProcAddressStub != nil {
		return fake.GetProcAddressStub(module, procname)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getProcAddressReturns.result1, fake.getProcAddressReturns.result2
}

func (fake *FakeSyscall) GetProcAddressCallCount() int {
	fake.getProcAddressMutex.RLock()
	defer fake.getProcAddressMutex.RUnlock()
	return len(fake.getProcAddressArgsForCall)
}

func (fake *FakeSyscall) GetProcAddressArgsForCall(i int) (syscall.Handle, string) {
	fake.getProcAddressMutex.RLock()
	defer fake.getProcAddressMutex.RUnlock()
	return fake.getProcAddressArgsForCall[i].module, fake.getProcAddressArgsForCall[i].procname
}

func (fake *FakeSyscall) GetProcAddressReturns(result1 uintptr, result2 error) {
	fake.GetProcAddressStub = nil
	fake.getProcAddressReturns = struct {
		result1 uintptr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetProcAddressReturnsOnCall(i int, result1 uintptr, result2 error) {
	fake.GetProcAddressStub = nil
	if fake.getProcAddressReturnsOnCall == nil {
		fake.getProcAddressReturnsOnCall = make(map[int]struct {
			result1 uintptr
			result2 error
		})
	}
	fake.getProcAddressReturnsOnCall[i] = struct {
		result1 uintptr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetVersion() (ver uint32, err error) {
	fake.getVersionMutex.Lock()
	ret, specificReturn := fake.getVersionReturnsOnCall[len(fake.getVersionArgsForCall)]
	fake.getVersionArgsForCall = append(fake.getVersionArgsForCall, struct{}{})
	fake.recordInvocation("GetVersion", []interface{}{})
	fake.getVersionMutex.Unlock()
	if fake.GetVersionStub != nil {
		return fake.GetVersionStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getVersionReturns.result1, fake.getVersionReturns.result2
}

func (fake *FakeSyscall) GetVersionCallCount() int {
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	return len(fake.getVersionArgsForCall)
}

func (fake *FakeSyscall) GetVersionReturns(result1 uint32, result2 error) {
	fake.GetVersionStub = nil
	fake.getVersionReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetVersionReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.GetVersionStub = nil
	if fake.getVersionReturnsOnCall == nil {
		fake.getVersionReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.getVersionReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ExitProcess(exitcode uint32) {
	fake.exitProcessMutex.Lock()
	fake.exitProcessArgsForCall = append(fake.exitProcessArgsForCall, struct {
		exitcode uint32
	}{exitcode})
	fake.recordInvocation("ExitProcess", []interface{}{exitcode})
	fake.exitProcessMutex.Unlock()
	if fake.ExitProcessStub != nil {
		fake.ExitProcessStub(exitcode)
	}
}

func (fake *FakeSyscall) ExitProcessCallCount() int {
	fake.exitProcessMutex.RLock()
	defer fake.exitProcessMutex.RUnlock()
	return len(fake.exitProcessArgsForCall)
}

func (fake *FakeSyscall) ExitProcessArgsForCall(i int) uint32 {
	fake.exitProcessMutex.RLock()
	defer fake.exitProcessMutex.RUnlock()
	return fake.exitProcessArgsForCall[i].exitcode
}

func (fake *FakeSyscall) CreateFile(name *uint16, access uint32, mode uint32, sa *syscall.SecurityAttributes, createmode uint32, attrs uint32, templatefile int32) (handle syscall.Handle, err error) {
	fake.createFileMutex.Lock()
	ret, specificReturn := fake.createFileReturnsOnCall[len(fake.createFileArgsForCall)]
	fake.createFileArgsForCall = append(fake.createFileArgsForCall, struct {
		name         *uint16
		access       uint32
		mode         uint32
		sa           *syscall.SecurityAttributes
		createmode   uint32
		attrs        uint32
		templatefile int32
	}{name, access, mode, sa, createmode, attrs, templatefile})
	fake.recordInvocation("CreateFile", []interface{}{name, access, mode, sa, createmode, attrs, templatefile})
	fake.createFileMutex.Unlock()
	if fake.CreateFileStub != nil {
		return fake.CreateFileStub(name, access, mode, sa, createmode, attrs, templatefile)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createFileReturns.result1, fake.createFileReturns.result2
}

func (fake *FakeSyscall) CreateFileCallCount() int {
	fake.createFileMutex.RLock()
	defer fake.createFileMutex.RUnlock()
	return len(fake.createFileArgsForCall)
}

func (fake *FakeSyscall) CreateFileArgsForCall(i int) (*uint16, uint32, uint32, *syscall.SecurityAttributes, uint32, uint32, int32) {
	fake.createFileMutex.RLock()
	defer fake.createFileMutex.RUnlock()
	return fake.createFileArgsForCall[i].name, fake.createFileArgsForCall[i].access, fake.createFileArgsForCall[i].mode, fake.createFileArgsForCall[i].sa, fake.createFileArgsForCall[i].createmode, fake.createFileArgsForCall[i].attrs, fake.createFileArgsForCall[i].templatefile
}

func (fake *FakeSyscall) CreateFileReturns(result1 syscall.Handle, result2 error) {
	fake.CreateFileStub = nil
	fake.createFileReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CreateFileReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.CreateFileStub = nil
	if fake.createFileReturnsOnCall == nil {
		fake.createFileReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.createFileReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) ReadFile(handle syscall.Handle, buf []byte, done *uint32, overlapped *syscall.Overlapped) (err error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.readFileMutex.Lock()
	ret, specificReturn := fake.readFileReturnsOnCall[len(fake.readFileArgsForCall)]
	fake.readFileArgsForCall = append(fake.readFileArgsForCall, struct {
		handle     syscall.Handle
		buf        []byte
		done       *uint32
		overlapped *syscall.Overlapped
	}{handle, bufCopy, done, overlapped})
	fake.recordInvocation("ReadFile", []interface{}{handle, bufCopy, done, overlapped})
	fake.readFileMutex.Unlock()
	if fake.ReadFileStub != nil {
		return fake.ReadFileStub(handle, buf, done, overlapped)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.readFileReturns.result1
}

func (fake *FakeSyscall) ReadFileCallCount() int {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	return len(fake.readFileArgsForCall)
}

func (fake *FakeSyscall) ReadFileArgsForCall(i int) (syscall.Handle, []byte, *uint32, *syscall.Overlapped) {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	return fake.readFileArgsForCall[i].handle, fake.readFileArgsForCall[i].buf, fake.readFileArgsForCall[i].done, fake.readFileArgsForCall[i].overlapped
}

func (fake *FakeSyscall) ReadFileReturns(result1 error) {
	fake.ReadFileStub = nil
	fake.readFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ReadFileReturnsOnCall(i int, result1 error) {
	fake.ReadFileStub = nil
	if fake.readFileReturnsOnCall == nil {
		fake.readFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.readFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WriteFile(handle syscall.Handle, buf []byte, done *uint32, overlapped *syscall.Overlapped) (err error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.writeFileMutex.Lock()
	ret, specificReturn := fake.writeFileReturnsOnCall[len(fake.writeFileArgsForCall)]
	fake.writeFileArgsForCall = append(fake.writeFileArgsForCall, struct {
		handle     syscall.Handle
		buf        []byte
		done       *uint32
		overlapped *syscall.Overlapped
	}{handle, bufCopy, done, overlapped})
	fake.recordInvocation("WriteFile", []interface{}{handle, bufCopy, done, overlapped})
	fake.writeFileMutex.Unlock()
	if fake.WriteFileStub != nil {
		return fake.WriteFileStub(handle, buf, done, overlapped)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.writeFileReturns.result1
}

func (fake *FakeSyscall) WriteFileCallCount() int {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	return len(fake.writeFileArgsForCall)
}

func (fake *FakeSyscall) WriteFileArgsForCall(i int) (syscall.Handle, []byte, *uint32, *syscall.Overlapped) {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	return fake.writeFileArgsForCall[i].handle, fake.writeFileArgsForCall[i].buf, fake.writeFileArgsForCall[i].done, fake.writeFileArgsForCall[i].overlapped
}

func (fake *FakeSyscall) WriteFileReturns(result1 error) {
	fake.WriteFileStub = nil
	fake.writeFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WriteFileReturnsOnCall(i int, result1 error) {
	fake.WriteFileStub = nil
	if fake.writeFileReturnsOnCall == nil {
		fake.writeFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetFilePointer(handle syscall.Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, err error) {
	fake.setFilePointerMutex.Lock()
	ret, specificReturn := fake.setFilePointerReturnsOnCall[len(fake.setFilePointerArgsForCall)]
	fake.setFilePointerArgsForCall = append(fake.setFilePointerArgsForCall, struct {
		handle        syscall.Handle
		lowoffset     int32
		highoffsetptr *int32
		whence        uint32
	}{handle, lowoffset, highoffsetptr, whence})
	fake.recordInvocation("SetFilePointer", []interface{}{handle, lowoffset, highoffsetptr, whence})
	fake.setFilePointerMutex.Unlock()
	if fake.SetFilePointerStub != nil {
		return fake.SetFilePointerStub(handle, lowoffset, highoffsetptr, whence)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setFilePointerReturns.result1, fake.setFilePointerReturns.result2
}

func (fake *FakeSyscall) SetFilePointerCallCount() int {
	fake.setFilePointerMutex.RLock()
	defer fake.setFilePointerMutex.RUnlock()
	return len(fake.setFilePointerArgsForCall)
}

func (fake *FakeSyscall) SetFilePointerArgsForCall(i int) (syscall.Handle, int32, *int32, uint32) {
	fake.setFilePointerMutex.RLock()
	defer fake.setFilePointerMutex.RUnlock()
	return fake.setFilePointerArgsForCall[i].handle, fake.setFilePointerArgsForCall[i].lowoffset, fake.setFilePointerArgsForCall[i].highoffsetptr, fake.setFilePointerArgsForCall[i].whence
}

func (fake *FakeSyscall) SetFilePointerReturns(result1 uint32, result2 error) {
	fake.SetFilePointerStub = nil
	fake.setFilePointerReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetFilePointerReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.SetFilePointerStub = nil
	if fake.setFilePointerReturnsOnCall == nil {
		fake.setFilePointerReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.setFilePointerReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CloseHandle(handle syscall.Handle) (err error) {
	fake.closeHandleMutex.Lock()
	ret, specificReturn := fake.closeHandleReturnsOnCall[len(fake.closeHandleArgsForCall)]
	fake.closeHandleArgsForCall = append(fake.closeHandleArgsForCall, struct {
		handle syscall.Handle
	}{handle})
	fake.recordInvocation("CloseHandle", []interface{}{handle})
	fake.closeHandleMutex.Unlock()
	if fake.CloseHandleStub != nil {
		return fake.CloseHandleStub(handle)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.closeHandleReturns.result1
}

func (fake *FakeSyscall) CloseHandleCallCount() int {
	fake.closeHandleMutex.RLock()
	defer fake.closeHandleMutex.RUnlock()
	return len(fake.closeHandleArgsForCall)
}

func (fake *FakeSyscall) CloseHandleArgsForCall(i int) syscall.Handle {
	fake.closeHandleMutex.RLock()
	defer fake.closeHandleMutex.RUnlock()
	return fake.closeHandleArgsForCall[i].handle
}

func (fake *FakeSyscall) CloseHandleReturns(result1 error) {
	fake.CloseHandleStub = nil
	fake.closeHandleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CloseHandleReturnsOnCall(i int, result1 error) {
	fake.CloseHandleStub = nil
	if fake.closeHandleReturnsOnCall == nil {
		fake.closeHandleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeHandleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetStdHandle(stdhandle int) (handle syscall.Handle, err error) {
	fake.getStdHandleMutex.Lock()
	ret, specificReturn := fake.getStdHandleReturnsOnCall[len(fake.getStdHandleArgsForCall)]
	fake.getStdHandleArgsForCall = append(fake.getStdHandleArgsForCall, struct {
		stdhandle int
	}{stdhandle})
	fake.recordInvocation("GetStdHandle", []interface{}{stdhandle})
	fake.getStdHandleMutex.Unlock()
	if fake.GetStdHandleStub != nil {
		return fake.GetStdHandleStub(stdhandle)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getStdHandleReturns.result1, fake.getStdHandleReturns.result2
}

func (fake *FakeSyscall) GetStdHandleCallCount() int {
	fake.getStdHandleMutex.RLock()
	defer fake.getStdHandleMutex.RUnlock()
	return len(fake.getStdHandleArgsForCall)
}

func (fake *FakeSyscall) GetStdHandleArgsForCall(i int) int {
	fake.getStdHandleMutex.RLock()
	defer fake.getStdHandleMutex.RUnlock()
	return fake.getStdHandleArgsForCall[i].stdhandle
}

func (fake *FakeSyscall) GetStdHandleReturns(result1 syscall.Handle, result2 error) {
	fake.GetStdHandleStub = nil
	fake.getStdHandleReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetStdHandleReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.GetStdHandleStub = nil
	if fake.getStdHandleReturnsOnCall == nil {
		fake.getStdHandleReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.getStdHandleReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) FindClose(handle syscall.Handle) (err error) {
	fake.findCloseMutex.Lock()
	ret, specificReturn := fake.findCloseReturnsOnCall[len(fake.findCloseArgsForCall)]
	fake.findCloseArgsForCall = append(fake.findCloseArgsForCall, struct {
		handle syscall.Handle
	}{handle})
	fake.recordInvocation("FindClose", []interface{}{handle})
	fake.findCloseMutex.Unlock()
	if fake.FindCloseStub != nil {
		return fake.FindCloseStub(handle)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.findCloseReturns.result1
}

func (fake *FakeSyscall) FindCloseCallCount() int {
	fake.findCloseMutex.RLock()
	defer fake.findCloseMutex.RUnlock()
	return len(fake.findCloseArgsForCall)
}

func (fake *FakeSyscall) FindCloseArgsForCall(i int) syscall.Handle {
	fake.findCloseMutex.RLock()
	defer fake.findCloseMutex.RUnlock()
	return fake.findCloseArgsForCall[i].handle
}

func (fake *FakeSyscall) FindCloseReturns(result1 error) {
	fake.FindCloseStub = nil
	fake.findCloseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FindCloseReturnsOnCall(i int, result1 error) {
	fake.FindCloseStub = nil
	if fake.findCloseReturnsOnCall == nil {
		fake.findCloseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.findCloseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetFileInformationByHandle(handle syscall.Handle, data *syscall.ByHandleFileInformation) (err error) {
	fake.getFileInformationByHandleMutex.Lock()
	ret, specificReturn := fake.getFileInformationByHandleReturnsOnCall[len(fake.getFileInformationByHandleArgsForCall)]
	fake.getFileInformationByHandleArgsForCall = append(fake.getFileInformationByHandleArgsForCall, struct {
		handle syscall.Handle
		data   *syscall.ByHandleFileInformation
	}{handle, data})
	fake.recordInvocation("GetFileInformationByHandle", []interface{}{handle, data})
	fake.getFileInformationByHandleMutex.Unlock()
	if fake.GetFileInformationByHandleStub != nil {
		return fake.GetFileInformationByHandleStub(handle, data)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getFileInformationByHandleReturns.result1
}

func (fake *FakeSyscall) GetFileInformationByHandleCallCount() int {
	fake.getFileInformationByHandleMutex.RLock()
	defer fake.getFileInformationByHandleMutex.RUnlock()
	return len(fake.getFileInformationByHandleArgsForCall)
}

func (fake *FakeSyscall) GetFileInformationByHandleArgsForCall(i int) (syscall.Handle, *syscall.ByHandleFileInformation) {
	fake.getFileInformationByHandleMutex.RLock()
	defer fake.getFileInformationByHandleMutex.RUnlock()
	return fake.getFileInformationByHandleArgsForCall[i].handle, fake.getFileInformationByHandleArgsForCall[i].data
}

func (fake *FakeSyscall) GetFileInformationByHandleReturns(result1 error) {
	fake.GetFileInformationByHandleStub = nil
	fake.getFileInformationByHandleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetFileInformationByHandleReturnsOnCall(i int, result1 error) {
	fake.GetFileInformationByHandleStub = nil
	if fake.getFileInformationByHandleReturnsOnCall == nil {
		fake.getFileInformationByHandleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getFileInformationByHandleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, err error) {
	fake.getCurrentDirectoryMutex.Lock()
	ret, specificReturn := fake.getCurrentDirectoryReturnsOnCall[len(fake.getCurrentDirectoryArgsForCall)]
	fake.getCurrentDirectoryArgsForCall = append(fake.getCurrentDirectoryArgsForCall, struct {
		buflen uint32
		buf    *uint16
	}{buflen, buf})
	fake.recordInvocation("GetCurrentDirectory", []interface{}{buflen, buf})
	fake.getCurrentDirectoryMutex.Unlock()
	if fake.GetCurrentDirectoryStub != nil {
		return fake.GetCurrentDirectoryStub(buflen, buf)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getCurrentDirectoryReturns.result1, fake.getCurrentDirectoryReturns.result2
}

func (fake *FakeSyscall) GetCurrentDirectoryCallCount() int {
	fake.getCurrentDirectoryMutex.RLock()
	defer fake.getCurrentDirectoryMutex.RUnlock()
	return len(fake.getCurrentDirectoryArgsForCall)
}

func (fake *FakeSyscall) GetCurrentDirectoryArgsForCall(i int) (uint32, *uint16) {
	fake.getCurrentDirectoryMutex.RLock()
	defer fake.getCurrentDirectoryMutex.RUnlock()
	return fake.getCurrentDirectoryArgsForCall[i].buflen, fake.getCurrentDirectoryArgsForCall[i].buf
}

func (fake *FakeSyscall) GetCurrentDirectoryReturns(result1 uint32, result2 error) {
	fake.GetCurrentDirectoryStub = nil
	fake.getCurrentDirectoryReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetCurrentDirectoryReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.GetCurrentDirectoryStub = nil
	if fake.getCurrentDirectoryReturnsOnCall == nil {
		fake.getCurrentDirectoryReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.getCurrentDirectoryReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetCurrentDirectory(path *uint16) (err error) {
	fake.setCurrentDirectoryMutex.Lock()
	ret, specificReturn := fake.setCurrentDirectoryReturnsOnCall[len(fake.setCurrentDirectoryArgsForCall)]
	fake.setCurrentDirectoryArgsForCall = append(fake.setCurrentDirectoryArgsForCall, struct {
		path *uint16
	}{path})
	fake.recordInvocation("SetCurrentDirectory", []interface{}{path})
	fake.setCurrentDirectoryMutex.Unlock()
	if fake.SetCurrentDirectoryStub != nil {
		return fake.SetCurrentDirectoryStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setCurrentDirectoryReturns.result1
}

func (fake *FakeSyscall) SetCurrentDirectoryCallCount() int {
	fake.setCurrentDirectoryMutex.RLock()
	defer fake.setCurrentDirectoryMutex.RUnlock()
	return len(fake.setCurrentDirectoryArgsForCall)
}

func (fake *FakeSyscall) SetCurrentDirectoryArgsForCall(i int) *uint16 {
	fake.setCurrentDirectoryMutex.RLock()
	defer fake.setCurrentDirectoryMutex.RUnlock()
	return fake.setCurrentDirectoryArgsForCall[i].path
}

func (fake *FakeSyscall) SetCurrentDirectoryReturns(result1 error) {
	fake.SetCurrentDirectoryStub = nil
	fake.setCurrentDirectoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetCurrentDirectoryReturnsOnCall(i int, result1 error) {
	fake.SetCurrentDirectoryStub = nil
	if fake.setCurrentDirectoryReturnsOnCall == nil {
		fake.setCurrentDirectoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setCurrentDirectoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CreateDirectory(path *uint16, sa *syscall.SecurityAttributes) (err error) {
	fake.createDirectoryMutex.Lock()
	ret, specificReturn := fake.createDirectoryReturnsOnCall[len(fake.createDirectoryArgsForCall)]
	fake.createDirectoryArgsForCall = append(fake.createDirectoryArgsForCall, struct {
		path *uint16
		sa   *syscall.SecurityAttributes
	}{path, sa})
	fake.recordInvocation("CreateDirectory", []interface{}{path, sa})
	fake.createDirectoryMutex.Unlock()
	if fake.CreateDirectoryStub != nil {
		return fake.CreateDirectoryStub(path, sa)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createDirectoryReturns.result1
}

func (fake *FakeSyscall) CreateDirectoryCallCount() int {
	fake.createDirectoryMutex.RLock()
	defer fake.createDirectoryMutex.RUnlock()
	return len(fake.createDirectoryArgsForCall)
}

func (fake *FakeSyscall) CreateDirectoryArgsForCall(i int) (*uint16, *syscall.SecurityAttributes) {
	fake.createDirectoryMutex.RLock()
	defer fake.createDirectoryMutex.RUnlock()
	return fake.createDirectoryArgsForCall[i].path, fake.createDirectoryArgsForCall[i].sa
}

func (fake *FakeSyscall) CreateDirectoryReturns(result1 error) {
	fake.CreateDirectoryStub = nil
	fake.createDirectoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CreateDirectoryReturnsOnCall(i int, result1 error) {
	fake.CreateDirectoryStub = nil
	if fake.createDirectoryReturnsOnCall == nil {
		fake.createDirectoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createDirectoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RemoveDirectory(path *uint16) (err error) {
	fake.removeDirectoryMutex.Lock()
	ret, specificReturn := fake.removeDirectoryReturnsOnCall[len(fake.removeDirectoryArgsForCall)]
	fake.removeDirectoryArgsForCall = append(fake.removeDirectoryArgsForCall, struct {
		path *uint16
	}{path})
	fake.recordInvocation("RemoveDirectory", []interface{}{path})
	fake.removeDirectoryMutex.Unlock()
	if fake.RemoveDirectoryStub != nil {
		return fake.RemoveDirectoryStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeDirectoryReturns.result1
}

func (fake *FakeSyscall) RemoveDirectoryCallCount() int {
	fake.removeDirectoryMutex.RLock()
	defer fake.removeDirectoryMutex.RUnlock()
	return len(fake.removeDirectoryArgsForCall)
}

func (fake *FakeSyscall) RemoveDirectoryArgsForCall(i int) *uint16 {
	fake.removeDirectoryMutex.RLock()
	defer fake.removeDirectoryMutex.RUnlock()
	return fake.removeDirectoryArgsForCall[i].path
}

func (fake *FakeSyscall) RemoveDirectoryReturns(result1 error) {
	fake.RemoveDirectoryStub = nil
	fake.removeDirectoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RemoveDirectoryReturnsOnCall(i int, result1 error) {
	fake.RemoveDirectoryStub = nil
	if fake.removeDirectoryReturnsOnCall == nil {
		fake.removeDirectoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeDirectoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) DeleteFile(path *uint16) (err error) {
	fake.deleteFileMutex.Lock()
	ret, specificReturn := fake.deleteFileReturnsOnCall[len(fake.deleteFileArgsForCall)]
	fake.deleteFileArgsForCall = append(fake.deleteFileArgsForCall, struct {
		path *uint16
	}{path})
	fake.recordInvocation("DeleteFile", []interface{}{path})
	fake.deleteFileMutex.Unlock()
	if fake.DeleteFileStub != nil {
		return fake.DeleteFileStub(path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteFileReturns.result1
}

func (fake *FakeSyscall) DeleteFileCallCount() int {
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	return len(fake.deleteFileArgsForCall)
}

func (fake *FakeSyscall) DeleteFileArgsForCall(i int) *uint16 {
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	return fake.deleteFileArgsForCall[i].path
}

func (fake *FakeSyscall) DeleteFileReturns(result1 error) {
	fake.DeleteFileStub = nil
	fake.deleteFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) DeleteFileReturnsOnCall(i int, result1 error) {
	fake.DeleteFileStub = nil
	if fake.deleteFileReturnsOnCall == nil {
		fake.deleteFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MoveFile(from *uint16, to *uint16) (err error) {
	fake.moveFileMutex.Lock()
	ret, specificReturn := fake.moveFileReturnsOnCall[len(fake.moveFileArgsForCall)]
	fake.moveFileArgsForCall = append(fake.moveFileArgsForCall, struct {
		from *uint16
		to   *uint16
	}{from, to})
	fake.recordInvocation("MoveFile", []interface{}{from, to})
	fake.moveFileMutex.Unlock()
	if fake.MoveFileStub != nil {
		return fake.MoveFileStub(from, to)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.moveFileReturns.result1
}

func (fake *FakeSyscall) MoveFileCallCount() int {
	fake.moveFileMutex.RLock()
	defer fake.moveFileMutex.RUnlock()
	return len(fake.moveFileArgsForCall)
}

func (fake *FakeSyscall) MoveFileArgsForCall(i int) (*uint16, *uint16) {
	fake.moveFileMutex.RLock()
	defer fake.moveFileMutex.RUnlock()
	return fake.moveFileArgsForCall[i].from, fake.moveFileArgsForCall[i].to
}

func (fake *FakeSyscall) MoveFileReturns(result1 error) {
	fake.MoveFileStub = nil
	fake.moveFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) MoveFileReturnsOnCall(i int, result1 error) {
	fake.MoveFileStub = nil
	if fake.moveFileReturnsOnCall == nil {
		fake.moveFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.moveFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetComputerName(buf *uint16, n *uint32) (err error) {
	fake.getComputerNameMutex.Lock()
	ret, specificReturn := fake.getComputerNameReturnsOnCall[len(fake.getComputerNameArgsForCall)]
	fake.getComputerNameArgsForCall = append(fake.getComputerNameArgsForCall, struct {
		buf *uint16
		n   *uint32
	}{buf, n})
	fake.recordInvocation("GetComputerName", []interface{}{buf, n})
	fake.getComputerNameMutex.Unlock()
	if fake.GetComputerNameStub != nil {
		return fake.GetComputerNameStub(buf, n)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getComputerNameReturns.result1
}

func (fake *FakeSyscall) GetComputerNameCallCount() int {
	fake.getComputerNameMutex.RLock()
	defer fake.getComputerNameMutex.RUnlock()
	return len(fake.getComputerNameArgsForCall)
}

func (fake *FakeSyscall) GetComputerNameArgsForCall(i int) (*uint16, *uint32) {
	fake.getComputerNameMutex.RLock()
	defer fake.getComputerNameMutex.RUnlock()
	return fake.getComputerNameArgsForCall[i].buf, fake.getComputerNameArgsForCall[i].n
}

func (fake *FakeSyscall) GetComputerNameReturns(result1 error) {
	fake.GetComputerNameStub = nil
	fake.getComputerNameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetComputerNameReturnsOnCall(i int, result1 error) {
	fake.GetComputerNameStub = nil
	if fake.getComputerNameReturnsOnCall == nil {
		fake.getComputerNameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getComputerNameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetEndOfFile(handle syscall.Handle) (err error) {
	fake.setEndOfFileMutex.Lock()
	ret, specificReturn := fake.setEndOfFileReturnsOnCall[len(fake.setEndOfFileArgsForCall)]
	fake.setEndOfFileArgsForCall = append(fake.setEndOfFileArgsForCall, struct {
		handle syscall.Handle
	}{handle})
	fake.recordInvocation("SetEndOfFile", []interface{}{handle})
	fake.setEndOfFileMutex.Unlock()
	if fake.SetEndOfFileStub != nil {
		return fake.SetEndOfFileStub(handle)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setEndOfFileReturns.result1
}

func (fake *FakeSyscall) SetEndOfFileCallCount() int {
	fake.setEndOfFileMutex.RLock()
	defer fake.setEndOfFileMutex.RUnlock()
	return len(fake.setEndOfFileArgsForCall)
}

func (fake *FakeSyscall) SetEndOfFileArgsForCall(i int) syscall.Handle {
	fake.setEndOfFileMutex.RLock()
	defer fake.setEndOfFileMutex.RUnlock()
	return fake.setEndOfFileArgsForCall[i].handle
}

func (fake *FakeSyscall) SetEndOfFileReturns(result1 error) {
	fake.SetEndOfFileStub = nil
	fake.setEndOfFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetEndOfFileReturnsOnCall(i int, result1 error) {
	fake.SetEndOfFileStub = nil
	if fake.setEndOfFileReturnsOnCall == nil {
		fake.setEndOfFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setEndOfFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetSystemTimeAsFileTime(time *syscall.Filetime) {
	fake.getSystemTimeAsFileTimeMutex.Lock()
	fake.getSystemTimeAsFileTimeArgsForCall = append(fake.getSystemTimeAsFileTimeArgsForCall, struct {
		time *syscall.Filetime
	}{time})
	fake.recordInvocation("GetSystemTimeAsFileTime", []interface{}{time})
	fake.getSystemTimeAsFileTimeMutex.Unlock()
	if fake.GetSystemTimeAsFileTimeStub != nil {
		fake.GetSystemTimeAsFileTimeStub(time)
	}
}

func (fake *FakeSyscall) GetSystemTimeAsFileTimeCallCount() int {
	fake.getSystemTimeAsFileTimeMutex.RLock()
	defer fake.getSystemTimeAsFileTimeMutex.RUnlock()
	return len(fake.getSystemTimeAsFileTimeArgsForCall)
}

func (fake *FakeSyscall) GetSystemTimeAsFileTimeArgsForCall(i int) *syscall.Filetime {
	fake.getSystemTimeAsFileTimeMutex.RLock()
	defer fake.getSystemTimeAsFileTimeMutex.RUnlock()
	return fake.getSystemTimeAsFileTimeArgsForCall[i].time
}

func (fake *FakeSyscall) GetTimeZoneInformation(tzi *syscall.Timezoneinformation) (rc uint32, err error) {
	fake.getTimeZoneInformationMutex.Lock()
	ret, specificReturn := fake.getTimeZoneInformationReturnsOnCall[len(fake.getTimeZoneInformationArgsForCall)]
	fake.getTimeZoneInformationArgsForCall = append(fake.getTimeZoneInformationArgsForCall, struct {
		tzi *syscall.Timezoneinformation
	}{tzi})
	fake.recordInvocation("GetTimeZoneInformation", []interface{}{tzi})
	fake.getTimeZoneInformationMutex.Unlock()
	if fake.GetTimeZoneInformationStub != nil {
		return fake.GetTimeZoneInformationStub(tzi)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getTimeZoneInformationReturns.result1, fake.getTimeZoneInformationReturns.result2
}

func (fake *FakeSyscall) GetTimeZoneInformationCallCount() int {
	fake.getTimeZoneInformationMutex.RLock()
	defer fake.getTimeZoneInformationMutex.RUnlock()
	return len(fake.getTimeZoneInformationArgsForCall)
}

func (fake *FakeSyscall) GetTimeZoneInformationArgsForCall(i int) *syscall.Timezoneinformation {
	fake.getTimeZoneInformationMutex.RLock()
	defer fake.getTimeZoneInformationMutex.RUnlock()
	return fake.getTimeZoneInformationArgsForCall[i].tzi
}

func (fake *FakeSyscall) GetTimeZoneInformationReturns(result1 uint32, result2 error) {
	fake.GetTimeZoneInformationStub = nil
	fake.getTimeZoneInformationReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetTimeZoneInformationReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.GetTimeZoneInformationStub = nil
	if fake.getTimeZoneInformationReturnsOnCall == nil {
		fake.getTimeZoneInformationReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.getTimeZoneInformationReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CreateIoCompletionPort(filehandle syscall.Handle, cphandle syscall.Handle, key uint32, threadcnt uint32) (handle syscall.Handle, err error) {
	fake.createIoCompletionPortMutex.Lock()
	ret, specificReturn := fake.createIoCompletionPortReturnsOnCall[len(fake.createIoCompletionPortArgsForCall)]
	fake.createIoCompletionPortArgsForCall = append(fake.createIoCompletionPortArgsForCall, struct {
		filehandle syscall.Handle
		cphandle   syscall.Handle
		key        uint32
		threadcnt  uint32
	}{filehandle, cphandle, key, threadcnt})
	fake.recordInvocation("CreateIoCompletionPort", []interface{}{filehandle, cphandle, key, threadcnt})
	fake.createIoCompletionPortMutex.Unlock()
	if fake.CreateIoCompletionPortStub != nil {
		return fake.CreateIoCompletionPortStub(filehandle, cphandle, key, threadcnt)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createIoCompletionPortReturns.result1, fake.createIoCompletionPortReturns.result2
}

func (fake *FakeSyscall) CreateIoCompletionPortCallCount() int {
	fake.createIoCompletionPortMutex.RLock()
	defer fake.createIoCompletionPortMutex.RUnlock()
	return len(fake.createIoCompletionPortArgsForCall)
}

func (fake *FakeSyscall) CreateIoCompletionPortArgsForCall(i int) (syscall.Handle, syscall.Handle, uint32, uint32) {
	fake.createIoCompletionPortMutex.RLock()
	defer fake.createIoCompletionPortMutex.RUnlock()
	return fake.createIoCompletionPortArgsForCall[i].filehandle, fake.createIoCompletionPortArgsForCall[i].cphandle, fake.createIoCompletionPortArgsForCall[i].key, fake.createIoCompletionPortArgsForCall[i].threadcnt
}

func (fake *FakeSyscall) CreateIoCompletionPortReturns(result1 syscall.Handle, result2 error) {
	fake.CreateIoCompletionPortStub = nil
	fake.createIoCompletionPortReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CreateIoCompletionPortReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.CreateIoCompletionPortStub = nil
	if fake.createIoCompletionPortReturnsOnCall == nil {
		fake.createIoCompletionPortReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.createIoCompletionPortReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetQueuedCompletionStatus(cphandle syscall.Handle, qty *uint32, key *uint32, overlapped **syscall.Overlapped, timeout uint32) (err error) {
	fake.getQueuedCompletionStatusMutex.Lock()
	ret, specificReturn := fake.getQueuedCompletionStatusReturnsOnCall[len(fake.getQueuedCompletionStatusArgsForCall)]
	fake.getQueuedCompletionStatusArgsForCall = append(fake.getQueuedCompletionStatusArgsForCall, struct {
		cphandle   syscall.Handle
		qty        *uint32
		key        *uint32
		overlapped **syscall.Overlapped
		timeout    uint32
	}{cphandle, qty, key, overlapped, timeout})
	fake.recordInvocation("GetQueuedCompletionStatus", []interface{}{cphandle, qty, key, overlapped, timeout})
	fake.getQueuedCompletionStatusMutex.Unlock()
	if fake.GetQueuedCompletionStatusStub != nil {
		return fake.GetQueuedCompletionStatusStub(cphandle, qty, key, overlapped, timeout)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getQueuedCompletionStatusReturns.result1
}

func (fake *FakeSyscall) GetQueuedCompletionStatusCallCount() int {
	fake.getQueuedCompletionStatusMutex.RLock()
	defer fake.getQueuedCompletionStatusMutex.RUnlock()
	return len(fake.getQueuedCompletionStatusArgsForCall)
}

func (fake *FakeSyscall) GetQueuedCompletionStatusArgsForCall(i int) (syscall.Handle, *uint32, *uint32, **syscall.Overlapped, uint32) {
	fake.getQueuedCompletionStatusMutex.RLock()
	defer fake.getQueuedCompletionStatusMutex.RUnlock()
	return fake.getQueuedCompletionStatusArgsForCall[i].cphandle, fake.getQueuedCompletionStatusArgsForCall[i].qty, fake.getQueuedCompletionStatusArgsForCall[i].key, fake.getQueuedCompletionStatusArgsForCall[i].overlapped, fake.getQueuedCompletionStatusArgsForCall[i].timeout
}

func (fake *FakeSyscall) GetQueuedCompletionStatusReturns(result1 error) {
	fake.GetQueuedCompletionStatusStub = nil
	fake.getQueuedCompletionStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetQueuedCompletionStatusReturnsOnCall(i int, result1 error) {
	fake.GetQueuedCompletionStatusStub = nil
	if fake.getQueuedCompletionStatusReturnsOnCall == nil {
		fake.getQueuedCompletionStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getQueuedCompletionStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PostQueuedCompletionStatus(cphandle syscall.Handle, qty uint32, key uint32, overlapped *syscall.Overlapped) (err error) {
	fake.postQueuedCompletionStatusMutex.Lock()
	ret, specificReturn := fake.postQueuedCompletionStatusReturnsOnCall[len(fake.postQueuedCompletionStatusArgsForCall)]
	fake.postQueuedCompletionStatusArgsForCall = append(fake.postQueuedCompletionStatusArgsForCall, struct {
		cphandle   syscall.Handle
		qty        uint32
		key        uint32
		overlapped *syscall.Overlapped
	}{cphandle, qty, key, overlapped})
	fake.recordInvocation("PostQueuedCompletionStatus", []interface{}{cphandle, qty, key, overlapped})
	fake.postQueuedCompletionStatusMutex.Unlock()
	if fake.PostQueuedCompletionStatusStub != nil {
		return fake.PostQueuedCompletionStatusStub(cphandle, qty, key, overlapped)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postQueuedCompletionStatusReturns.result1
}

func (fake *FakeSyscall) PostQueuedCompletionStatusCallCount() int {
	fake.postQueuedCompletionStatusMutex.RLock()
	defer fake.postQueuedCompletionStatusMutex.RUnlock()
	return len(fake.postQueuedCompletionStatusArgsForCall)
}

func (fake *FakeSyscall) PostQueuedCompletionStatusArgsForCall(i int) (syscall.Handle, uint32, uint32, *syscall.Overlapped) {
	fake.postQueuedCompletionStatusMutex.RLock()
	defer fake.postQueuedCompletionStatusMutex.RUnlock()
	return fake.postQueuedCompletionStatusArgsForCall[i].cphandle, fake.postQueuedCompletionStatusArgsForCall[i].qty, fake.postQueuedCompletionStatusArgsForCall[i].key, fake.postQueuedCompletionStatusArgsForCall[i].overlapped
}

func (fake *FakeSyscall) PostQueuedCompletionStatusReturns(result1 error) {
	fake.PostQueuedCompletionStatusStub = nil
	fake.postQueuedCompletionStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) PostQueuedCompletionStatusReturnsOnCall(i int, result1 error) {
	fake.PostQueuedCompletionStatusStub = nil
	if fake.postQueuedCompletionStatusReturnsOnCall == nil {
		fake.postQueuedCompletionStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postQueuedCompletionStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CancelIo(s syscall.Handle) (err error) {
	fake.cancelIoMutex.Lock()
	ret, specificReturn := fake.cancelIoReturnsOnCall[len(fake.cancelIoArgsForCall)]
	fake.cancelIoArgsForCall = append(fake.cancelIoArgsForCall, struct {
		s syscall.Handle
	}{s})
	fake.recordInvocation("CancelIo", []interface{}{s})
	fake.cancelIoMutex.Unlock()
	if fake.CancelIoStub != nil {
		return fake.CancelIoStub(s)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cancelIoReturns.result1
}

func (fake *FakeSyscall) CancelIoCallCount() int {
	fake.cancelIoMutex.RLock()
	defer fake.cancelIoMutex.RUnlock()
	return len(fake.cancelIoArgsForCall)
}

func (fake *FakeSyscall) CancelIoArgsForCall(i int) syscall.Handle {
	fake.cancelIoMutex.RLock()
	defer fake.cancelIoMutex.RUnlock()
	return fake.cancelIoArgsForCall[i].s
}

func (fake *FakeSyscall) CancelIoReturns(result1 error) {
	fake.CancelIoStub = nil
	fake.cancelIoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CancelIoReturnsOnCall(i int, result1 error) {
	fake.CancelIoStub = nil
	if fake.cancelIoReturnsOnCall == nil {
		fake.cancelIoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelIoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CancelIoEx(s syscall.Handle, o *syscall.Overlapped) (err error) {
	fake.cancelIoExMutex.Lock()
	ret, specificReturn := fake.cancelIoExReturnsOnCall[len(fake.cancelIoExArgsForCall)]
	fake.cancelIoExArgsForCall = append(fake.cancelIoExArgsForCall, struct {
		s syscall.Handle
		o *syscall.Overlapped
	}{s, o})
	fake.recordInvocation("CancelIoEx", []interface{}{s, o})
	fake.cancelIoExMutex.Unlock()
	if fake.CancelIoExStub != nil {
		return fake.CancelIoExStub(s, o)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cancelIoExReturns.result1
}

func (fake *FakeSyscall) CancelIoExCallCount() int {
	fake.cancelIoExMutex.RLock()
	defer fake.cancelIoExMutex.RUnlock()
	return len(fake.cancelIoExArgsForCall)
}

func (fake *FakeSyscall) CancelIoExArgsForCall(i int) (syscall.Handle, *syscall.Overlapped) {
	fake.cancelIoExMutex.RLock()
	defer fake.cancelIoExMutex.RUnlock()
	return fake.cancelIoExArgsForCall[i].s, fake.cancelIoExArgsForCall[i].o
}

func (fake *FakeSyscall) CancelIoExReturns(result1 error) {
	fake.CancelIoExStub = nil
	fake.cancelIoExReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CancelIoExReturnsOnCall(i int, result1 error) {
	fake.CancelIoExStub = nil
	if fake.cancelIoExReturnsOnCall == nil {
		fake.cancelIoExReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelIoExReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CreateProcess(appName *uint16, commandLine *uint16, procSecurity *syscall.SecurityAttributes, threadSecurity *syscall.SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *syscall.StartupInfo, outProcInfo *syscall.ProcessInformation) (err error) {
	fake.createProcessMutex.Lock()
	ret, specificReturn := fake.createProcessReturnsOnCall[len(fake.createProcessArgsForCall)]
	fake.createProcessArgsForCall = append(fake.createProcessArgsForCall, struct {
		appName        *uint16
		commandLine    *uint16
		procSecurity   *syscall.SecurityAttributes
		threadSecurity *syscall.SecurityAttributes
		inheritHandles bool
		creationFlags  uint32
		env            *uint16
		currentDir     *uint16
		startupInfo    *syscall.StartupInfo
		outProcInfo    *syscall.ProcessInformation
	}{appName, commandLine, procSecurity, threadSecurity, inheritHandles, creationFlags, env, currentDir, startupInfo, outProcInfo})
	fake.recordInvocation("CreateProcess", []interface{}{appName, commandLine, procSecurity, threadSecurity, inheritHandles, creationFlags, env, currentDir, startupInfo, outProcInfo})
	fake.createProcessMutex.Unlock()
	if fake.CreateProcessStub != nil {
		return fake.CreateProcessStub(appName, commandLine, procSecurity, threadSecurity, inheritHandles, creationFlags, env, currentDir, startupInfo, outProcInfo)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createProcessReturns.result1
}

func (fake *FakeSyscall) CreateProcessCallCount() int {
	fake.createProcessMutex.RLock()
	defer fake.createProcessMutex.RUnlock()
	return len(fake.createProcessArgsForCall)
}

func (fake *FakeSyscall) CreateProcessArgsForCall(i int) (*uint16, *uint16, *syscall.SecurityAttributes, *syscall.SecurityAttributes, bool, uint32, *uint16, *uint16, *syscall.StartupInfo, *syscall.ProcessInformation) {
	fake.createProcessMutex.RLock()
	defer fake.createProcessMutex.RUnlock()
	return fake.createProcessArgsForCall[i].appName, fake.createProcessArgsForCall[i].commandLine, fake.createProcessArgsForCall[i].procSecurity, fake.createProcessArgsForCall[i].threadSecurity, fake.createProcessArgsForCall[i].inheritHandles, fake.createProcessArgsForCall[i].creationFlags, fake.createProcessArgsForCall[i].env, fake.createProcessArgsForCall[i].currentDir, fake.createProcessArgsForCall[i].startupInfo, fake.createProcessArgsForCall[i].outProcInfo
}

func (fake *FakeSyscall) CreateProcessReturns(result1 error) {
	fake.CreateProcessStub = nil
	fake.createProcessReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CreateProcessReturnsOnCall(i int, result1 error) {
	fake.CreateProcessStub = nil
	if fake.createProcessReturnsOnCall == nil {
		fake.createProcessReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createProcessReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) OpenProcess(da uint32, inheritHandle bool, pid uint32) (handle syscall.Handle, err error) {
	fake.openProcessMutex.Lock()
	ret, specificReturn := fake.openProcessReturnsOnCall[len(fake.openProcessArgsForCall)]
	fake.openProcessArgsForCall = append(fake.openProcessArgsForCall, struct {
		da            uint32
		inheritHandle bool
		pid           uint32
	}{da, inheritHandle, pid})
	fake.recordInvocation("OpenProcess", []interface{}{da, inheritHandle, pid})
	fake.openProcessMutex.Unlock()
	if fake.OpenProcessStub != nil {
		return fake.OpenProcessStub(da, inheritHandle, pid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.openProcessReturns.result1, fake.openProcessReturns.result2
}

func (fake *FakeSyscall) OpenProcessCallCount() int {
	fake.openProcessMutex.RLock()
	defer fake.openProcessMutex.RUnlock()
	return len(fake.openProcessArgsForCall)
}

func (fake *FakeSyscall) OpenProcessArgsForCall(i int) (uint32, bool, uint32) {
	fake.openProcessMutex.RLock()
	defer fake.openProcessMutex.RUnlock()
	return fake.openProcessArgsForCall[i].da, fake.openProcessArgsForCall[i].inheritHandle, fake.openProcessArgsForCall[i].pid
}

func (fake *FakeSyscall) OpenProcessReturns(result1 syscall.Handle, result2 error) {
	fake.OpenProcessStub = nil
	fake.openProcessReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) OpenProcessReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.OpenProcessStub = nil
	if fake.openProcessReturnsOnCall == nil {
		fake.openProcessReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.openProcessReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) TerminateProcess(handle syscall.Handle, exitcode uint32) (err error) {
	fake.terminateProcessMutex.Lock()
	ret, specificReturn := fake.terminateProcessReturnsOnCall[len(fake.terminateProcessArgsForCall)]
	fake.terminateProcessArgsForCall = append(fake.terminateProcessArgsForCall, struct {
		handle   syscall.Handle
		exitcode uint32
	}{handle, exitcode})
	fake.recordInvocation("TerminateProcess", []interface{}{handle, exitcode})
	fake.terminateProcessMutex.Unlock()
	if fake.TerminateProcessStub != nil {
		return fake.TerminateProcessStub(handle, exitcode)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.terminateProcessReturns.result1
}

func (fake *FakeSyscall) TerminateProcessCallCount() int {
	fake.terminateProcessMutex.RLock()
	defer fake.terminateProcessMutex.RUnlock()
	return len(fake.terminateProcessArgsForCall)
}

func (fake *FakeSyscall) TerminateProcessArgsForCall(i int) (syscall.Handle, uint32) {
	fake.terminateProcessMutex.RLock()
	defer fake.terminateProcessMutex.RUnlock()
	return fake.terminateProcessArgsForCall[i].handle, fake.terminateProcessArgsForCall[i].exitcode
}

func (fake *FakeSyscall) TerminateProcessReturns(result1 error) {
	fake.TerminateProcessStub = nil
	fake.terminateProcessReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) TerminateProcessReturnsOnCall(i int, result1 error) {
	fake.TerminateProcessStub = nil
	if fake.terminateProcessReturnsOnCall == nil {
		fake.terminateProcessReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.terminateProcessReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetExitCodeProcess(handle syscall.Handle, exitcode *uint32) (err error) {
	fake.getExitCodeProcessMutex.Lock()
	ret, specificReturn := fake.getExitCodeProcessReturnsOnCall[len(fake.getExitCodeProcessArgsForCall)]
	fake.getExitCodeProcessArgsForCall = append(fake.getExitCodeProcessArgsForCall, struct {
		handle   syscall.Handle
		exitcode *uint32
	}{handle, exitcode})
	fake.recordInvocation("GetExitCodeProcess", []interface{}{handle, exitcode})
	fake.getExitCodeProcessMutex.Unlock()
	if fake.GetExitCodeProcessStub != nil {
		return fake.GetExitCodeProcessStub(handle, exitcode)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getExitCodeProcessReturns.result1
}

func (fake *FakeSyscall) GetExitCodeProcessCallCount() int {
	fake.getExitCodeProcessMutex.RLock()
	defer fake.getExitCodeProcessMutex.RUnlock()
	return len(fake.getExitCodeProcessArgsForCall)
}

func (fake *FakeSyscall) GetExitCodeProcessArgsForCall(i int) (syscall.Handle, *uint32) {
	fake.getExitCodeProcessMutex.RLock()
	defer fake.getExitCodeProcessMutex.RUnlock()
	return fake.getExitCodeProcessArgsForCall[i].handle, fake.getExitCodeProcessArgsForCall[i].exitcode
}

func (fake *FakeSyscall) GetExitCodeProcessReturns(result1 error) {
	fake.GetExitCodeProcessStub = nil
	fake.getExitCodeProcessReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetExitCodeProcessReturnsOnCall(i int, result1 error) {
	fake.GetExitCodeProcessStub = nil
	if fake.getExitCodeProcessReturnsOnCall == nil {
		fake.getExitCodeProcessReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getExitCodeProcessReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetStartupInfo(startupInfo *syscall.StartupInfo) (err error) {
	fake.getStartupInfoMutex.Lock()
	ret, specificReturn := fake.getStartupInfoReturnsOnCall[len(fake.getStartupInfoArgsForCall)]
	fake.getStartupInfoArgsForCall = append(fake.getStartupInfoArgsForCall, struct {
		startupInfo *syscall.StartupInfo
	}{startupInfo})
	fake.recordInvocation("GetStartupInfo", []interface{}{startupInfo})
	fake.getStartupInfoMutex.Unlock()
	if fake.GetStartupInfoStub != nil {
		return fake.GetStartupInfoStub(startupInfo)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getStartupInfoReturns.result1
}

func (fake *FakeSyscall) GetStartupInfoCallCount() int {
	fake.getStartupInfoMutex.RLock()
	defer fake.getStartupInfoMutex.RUnlock()
	return len(fake.getStartupInfoArgsForCall)
}

func (fake *FakeSyscall) GetStartupInfoArgsForCall(i int) *syscall.StartupInfo {
	fake.getStartupInfoMutex.RLock()
	defer fake.getStartupInfoMutex.RUnlock()
	return fake.getStartupInfoArgsForCall[i].startupInfo
}

func (fake *FakeSyscall) GetStartupInfoReturns(result1 error) {
	fake.GetStartupInfoStub = nil
	fake.getStartupInfoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetStartupInfoReturnsOnCall(i int, result1 error) {
	fake.GetStartupInfoStub = nil
	if fake.getStartupInfoReturnsOnCall == nil {
		fake.getStartupInfoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getStartupInfoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetCurrentProcess() (pseudoHandle syscall.Handle, err error) {
	fake.getCurrentProcessMutex.Lock()
	ret, specificReturn := fake.getCurrentProcessReturnsOnCall[len(fake.getCurrentProcessArgsForCall)]
	fake.getCurrentProcessArgsForCall = append(fake.getCurrentProcessArgsForCall, struct{}{})
	fake.recordInvocation("GetCurrentProcess", []interface{}{})
	fake.getCurrentProcessMutex.Unlock()
	if fake.GetCurrentProcessStub != nil {
		return fake.GetCurrentProcessStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getCurrentProcessReturns.result1, fake.getCurrentProcessReturns.result2
}

func (fake *FakeSyscall) GetCurrentProcessCallCount() int {
	fake.getCurrentProcessMutex.RLock()
	defer fake.getCurrentProcessMutex.RUnlock()
	return len(fake.getCurrentProcessArgsForCall)
}

func (fake *FakeSyscall) GetCurrentProcessReturns(result1 syscall.Handle, result2 error) {
	fake.GetCurrentProcessStub = nil
	fake.getCurrentProcessReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetCurrentProcessReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.GetCurrentProcessStub = nil
	if fake.getCurrentProcessReturnsOnCall == nil {
		fake.getCurrentProcessReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.getCurrentProcessReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetProcessTimes(handle syscall.Handle, creationTime *syscall.Filetime, exitTime *syscall.Filetime, kernelTime *syscall.Filetime, userTime *syscall.Filetime) (err error) {
	fake.getProcessTimesMutex.Lock()
	ret, specificReturn := fake.getProcessTimesReturnsOnCall[len(fake.getProcessTimesArgsForCall)]
	fake.getProcessTimesArgsForCall = append(fake.getProcessTimesArgsForCall, struct {
		handle       syscall.Handle
		creationTime *syscall.Filetime
		exitTime     *syscall.Filetime
		kernelTime   *syscall.Filetime
		userTime     *syscall.Filetime
	}{handle, creationTime, exitTime, kernelTime, userTime})
	fake.recordInvocation("GetProcessTimes", []interface{}{handle, creationTime, exitTime, kernelTime, userTime})
	fake.getProcessTimesMutex.Unlock()
	if fake.GetProcessTimesStub != nil {
		return fake.GetProcessTimesStub(handle, creationTime, exitTime, kernelTime, userTime)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getProcessTimesReturns.result1
}

func (fake *FakeSyscall) GetProcessTimesCallCount() int {
	fake.getProcessTimesMutex.RLock()
	defer fake.getProcessTimesMutex.RUnlock()
	return len(fake.getProcessTimesArgsForCall)
}

func (fake *FakeSyscall) GetProcessTimesArgsForCall(i int) (syscall.Handle, *syscall.Filetime, *syscall.Filetime, *syscall.Filetime, *syscall.Filetime) {
	fake.getProcessTimesMutex.RLock()
	defer fake.getProcessTimesMutex.RUnlock()
	return fake.getProcessTimesArgsForCall[i].handle, fake.getProcessTimesArgsForCall[i].creationTime, fake.getProcessTimesArgsForCall[i].exitTime, fake.getProcessTimesArgsForCall[i].kernelTime, fake.getProcessTimesArgsForCall[i].userTime
}

func (fake *FakeSyscall) GetProcessTimesReturns(result1 error) {
	fake.GetProcessTimesStub = nil
	fake.getProcessTimesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetProcessTimesReturnsOnCall(i int, result1 error) {
	fake.GetProcessTimesStub = nil
	if fake.getProcessTimesReturnsOnCall == nil {
		fake.getProcessTimesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getProcessTimesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) DuplicateHandle(hSourceProcessHandle syscall.Handle, hSourceHandle syscall.Handle, hTargetProcessHandle syscall.Handle, lpTargetHandle *syscall.Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error) {
	fake.duplicateHandleMutex.Lock()
	ret, specificReturn := fake.duplicateHandleReturnsOnCall[len(fake.duplicateHandleArgsForCall)]
	fake.duplicateHandleArgsForCall = append(fake.duplicateHandleArgsForCall, struct {
		hSourceProcessHandle syscall.Handle
		hSourceHandle        syscall.Handle
		hTargetProcessHandle syscall.Handle
		lpTargetHandle       *syscall.Handle
		dwDesiredAccess      uint32
		bInheritHandle       bool
		dwOptions            uint32
	}{hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions})
	fake.recordInvocation("DuplicateHandle", []interface{}{hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions})
	fake.duplicateHandleMutex.Unlock()
	if fake.DuplicateHandleStub != nil {
		return fake.DuplicateHandleStub(hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.duplicateHandleReturns.result1
}

func (fake *FakeSyscall) DuplicateHandleCallCount() int {
	fake.duplicateHandleMutex.RLock()
	defer fake.duplicateHandleMutex.RUnlock()
	return len(fake.duplicateHandleArgsForCall)
}

func (fake *FakeSyscall) DuplicateHandleArgsForCall(i int) (syscall.Handle, syscall.Handle, syscall.Handle, *syscall.Handle, uint32, bool, uint32) {
	fake.duplicateHandleMutex.RLock()
	defer fake.duplicateHandleMutex.RUnlock()
	return fake.duplicateHandleArgsForCall[i].hSourceProcessHandle, fake.duplicateHandleArgsForCall[i].hSourceHandle, fake.duplicateHandleArgsForCall[i].hTargetProcessHandle, fake.duplicateHandleArgsForCall[i].lpTargetHandle, fake.duplicateHandleArgsForCall[i].dwDesiredAccess, fake.duplicateHandleArgsForCall[i].bInheritHandle, fake.duplicateHandleArgsForCall[i].dwOptions
}

func (fake *FakeSyscall) DuplicateHandleReturns(result1 error) {
	fake.DuplicateHandleStub = nil
	fake.duplicateHandleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) DuplicateHandleReturnsOnCall(i int, result1 error) {
	fake.DuplicateHandleStub = nil
	if fake.duplicateHandleReturnsOnCall == nil {
		fake.duplicateHandleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.duplicateHandleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WaitForSingleObject(handle syscall.Handle, waitMilliseconds uint32) (event uint32, err error) {
	fake.waitForSingleObjectMutex.Lock()
	ret, specificReturn := fake.waitForSingleObjectReturnsOnCall[len(fake.waitForSingleObjectArgsForCall)]
	fake.waitForSingleObjectArgsForCall = append(fake.waitForSingleObjectArgsForCall, struct {
		handle           syscall.Handle
		waitMilliseconds uint32
	}{handle, waitMilliseconds})
	fake.recordInvocation("WaitForSingleObject", []interface{}{handle, waitMilliseconds})
	fake.waitForSingleObjectMutex.Unlock()
	if fake.WaitForSingleObjectStub != nil {
		return fake.WaitForSingleObjectStub(handle, waitMilliseconds)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.waitForSingleObjectReturns.result1, fake.waitForSingleObjectReturns.result2
}

func (fake *FakeSyscall) WaitForSingleObjectCallCount() int {
	fake.waitForSingleObjectMutex.RLock()
	defer fake.waitForSingleObjectMutex.RUnlock()
	return len(fake.waitForSingleObjectArgsForCall)
}

func (fake *FakeSyscall) WaitForSingleObjectArgsForCall(i int) (syscall.Handle, uint32) {
	fake.waitForSingleObjectMutex.RLock()
	defer fake.waitForSingleObjectMutex.RUnlock()
	return fake.waitForSingleObjectArgsForCall[i].handle, fake.waitForSingleObjectArgsForCall[i].waitMilliseconds
}

func (fake *FakeSyscall) WaitForSingleObjectReturns(result1 uint32, result2 error) {
	fake.WaitForSingleObjectStub = nil
	fake.waitForSingleObjectReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) WaitForSingleObjectReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.WaitForSingleObjectStub = nil
	if fake.waitForSingleObjectReturnsOnCall == nil {
		fake.waitForSingleObjectReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.waitForSingleObjectReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetTempPath(buflen uint32, buf *uint16) (n uint32, err error) {
	fake.getTempPathMutex.Lock()
	ret, specificReturn := fake.getTempPathReturnsOnCall[len(fake.getTempPathArgsForCall)]
	fake.getTempPathArgsForCall = append(fake.getTempPathArgsForCall, struct {
		buflen uint32
		buf    *uint16
	}{buflen, buf})
	fake.recordInvocation("GetTempPath", []interface{}{buflen, buf})
	fake.getTempPathMutex.Unlock()
	if fake.GetTempPathStub != nil {
		return fake.GetTempPathStub(buflen, buf)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getTempPathReturns.result1, fake.getTempPathReturns.result2
}

func (fake *FakeSyscall) GetTempPathCallCount() int {
	fake.getTempPathMutex.RLock()
	defer fake.getTempPathMutex.RUnlock()
	return len(fake.getTempPathArgsForCall)
}

func (fake *FakeSyscall) GetTempPathArgsForCall(i int) (uint32, *uint16) {
	fake.getTempPathMutex.RLock()
	defer fake.getTempPathMutex.RUnlock()
	return fake.getTempPathArgsForCall[i].buflen, fake.getTempPathArgsForCall[i].buf
}

func (fake *FakeSyscall) GetTempPathReturns(result1 uint32, result2 error) {
	fake.GetTempPathStub = nil
	fake.getTempPathReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetTempPathReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.GetTempPathStub = nil
	if fake.getTempPathReturnsOnCall == nil {
		fake.getTempPathReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.getTempPathReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CreatePipe(readhandle *syscall.Handle, writehandle *syscall.Handle, sa *syscall.SecurityAttributes, size uint32) (err error) {
	fake.createPipeMutex.Lock()
	ret, specificReturn := fake.createPipeReturnsOnCall[len(fake.createPipeArgsForCall)]
	fake.createPipeArgsForCall = append(fake.createPipeArgsForCall, struct {
		readhandle  *syscall.Handle
		writehandle *syscall.Handle
		sa          *syscall.SecurityAttributes
		size        uint32
	}{readhandle, writehandle, sa, size})
	fake.recordInvocation("CreatePipe", []interface{}{readhandle, writehandle, sa, size})
	fake.createPipeMutex.Unlock()
	if fake.CreatePipeStub != nil {
		return fake.CreatePipeStub(readhandle, writehandle, sa, size)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createPipeReturns.result1
}

func (fake *FakeSyscall) CreatePipeCallCount() int {
	fake.createPipeMutex.RLock()
	defer fake.createPipeMutex.RUnlock()
	return len(fake.createPipeArgsForCall)
}

func (fake *FakeSyscall) CreatePipeArgsForCall(i int) (*syscall.Handle, *syscall.Handle, *syscall.SecurityAttributes, uint32) {
	fake.createPipeMutex.RLock()
	defer fake.createPipeMutex.RUnlock()
	return fake.createPipeArgsForCall[i].readhandle, fake.createPipeArgsForCall[i].writehandle, fake.createPipeArgsForCall[i].sa, fake.createPipeArgsForCall[i].size
}

func (fake *FakeSyscall) CreatePipeReturns(result1 error) {
	fake.CreatePipeStub = nil
	fake.createPipeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CreatePipeReturnsOnCall(i int, result1 error) {
	fake.CreatePipeStub = nil
	if fake.createPipeReturnsOnCall == nil {
		fake.createPipeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createPipeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetFileType(filehandle syscall.Handle) (n uint32, err error) {
	fake.getFileTypeMutex.Lock()
	ret, specificReturn := fake.getFileTypeReturnsOnCall[len(fake.getFileTypeArgsForCall)]
	fake.getFileTypeArgsForCall = append(fake.getFileTypeArgsForCall, struct {
		filehandle syscall.Handle
	}{filehandle})
	fake.recordInvocation("GetFileType", []interface{}{filehandle})
	fake.getFileTypeMutex.Unlock()
	if fake.GetFileTypeStub != nil {
		return fake.GetFileTypeStub(filehandle)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getFileTypeReturns.result1, fake.getFileTypeReturns.result2
}

func (fake *FakeSyscall) GetFileTypeCallCount() int {
	fake.getFileTypeMutex.RLock()
	defer fake.getFileTypeMutex.RUnlock()
	return len(fake.getFileTypeArgsForCall)
}

func (fake *FakeSyscall) GetFileTypeArgsForCall(i int) syscall.Handle {
	fake.getFileTypeMutex.RLock()
	defer fake.getFileTypeMutex.RUnlock()
	return fake.getFileTypeArgsForCall[i].filehandle
}

func (fake *FakeSyscall) GetFileTypeReturns(result1 uint32, result2 error) {
	fake.GetFileTypeStub = nil
	fake.getFileTypeReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetFileTypeReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.GetFileTypeStub = nil
	if fake.getFileTypeReturnsOnCall == nil {
		fake.getFileTypeReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.getFileTypeReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CryptAcquireContext(provhandle *syscall.Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) {
	fake.cryptAcquireContextMutex.Lock()
	ret, specificReturn := fake.cryptAcquireContextReturnsOnCall[len(fake.cryptAcquireContextArgsForCall)]
	fake.cryptAcquireContextArgsForCall = append(fake.cryptAcquireContextArgsForCall, struct {
		provhandle *syscall.Handle
		container  *uint16
		provider   *uint16
		provtype   uint32
		flags      uint32
	}{provhandle, container, provider, provtype, flags})
	fake.recordInvocation("CryptAcquireContext", []interface{}{provhandle, container, provider, provtype, flags})
	fake.cryptAcquireContextMutex.Unlock()
	if fake.CryptAcquireContextStub != nil {
		return fake.CryptAcquireContextStub(provhandle, container, provider, provtype, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cryptAcquireContextReturns.result1
}

func (fake *FakeSyscall) CryptAcquireContextCallCount() int {
	fake.cryptAcquireContextMutex.RLock()
	defer fake.cryptAcquireContextMutex.RUnlock()
	return len(fake.cryptAcquireContextArgsForCall)
}

func (fake *FakeSyscall) CryptAcquireContextArgsForCall(i int) (*syscall.Handle, *uint16, *uint16, uint32, uint32) {
	fake.cryptAcquireContextMutex.RLock()
	defer fake.cryptAcquireContextMutex.RUnlock()
	return fake.cryptAcquireContextArgsForCall[i].provhandle, fake.cryptAcquireContextArgsForCall[i].container, fake.cryptAcquireContextArgsForCall[i].provider, fake.cryptAcquireContextArgsForCall[i].provtype, fake.cryptAcquireContextArgsForCall[i].flags
}

func (fake *FakeSyscall) CryptAcquireContextReturns(result1 error) {
	fake.CryptAcquireContextStub = nil
	fake.cryptAcquireContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CryptAcquireContextReturnsOnCall(i int, result1 error) {
	fake.CryptAcquireContextStub = nil
	if fake.cryptAcquireContextReturnsOnCall == nil {
		fake.cryptAcquireContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cryptAcquireContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CryptReleaseContext(provhandle syscall.Handle, flags uint32) (err error) {
	fake.cryptReleaseContextMutex.Lock()
	ret, specificReturn := fake.cryptReleaseContextReturnsOnCall[len(fake.cryptReleaseContextArgsForCall)]
	fake.cryptReleaseContextArgsForCall = append(fake.cryptReleaseContextArgsForCall, struct {
		provhandle syscall.Handle
		flags      uint32
	}{provhandle, flags})
	fake.recordInvocation("CryptReleaseContext", []interface{}{provhandle, flags})
	fake.cryptReleaseContextMutex.Unlock()
	if fake.CryptReleaseContextStub != nil {
		return fake.CryptReleaseContextStub(provhandle, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cryptReleaseContextReturns.result1
}

func (fake *FakeSyscall) CryptReleaseContextCallCount() int {
	fake.cryptReleaseContextMutex.RLock()
	defer fake.cryptReleaseContextMutex.RUnlock()
	return len(fake.cryptReleaseContextArgsForCall)
}

func (fake *FakeSyscall) CryptReleaseContextArgsForCall(i int) (syscall.Handle, uint32) {
	fake.cryptReleaseContextMutex.RLock()
	defer fake.cryptReleaseContextMutex.RUnlock()
	return fake.cryptReleaseContextArgsForCall[i].provhandle, fake.cryptReleaseContextArgsForCall[i].flags
}

func (fake *FakeSyscall) CryptReleaseContextReturns(result1 error) {
	fake.CryptReleaseContextStub = nil
	fake.cryptReleaseContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CryptReleaseContextReturnsOnCall(i int, result1 error) {
	fake.CryptReleaseContextStub = nil
	if fake.cryptReleaseContextReturnsOnCall == nil {
		fake.cryptReleaseContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cryptReleaseContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CryptGenRandom(provhandle syscall.Handle, buflen uint32, buf *byte) (err error) {
	fake.cryptGenRandomMutex.Lock()
	ret, specificReturn := fake.cryptGenRandomReturnsOnCall[len(fake.cryptGenRandomArgsForCall)]
	fake.cryptGenRandomArgsForCall = append(fake.cryptGenRandomArgsForCall, struct {
		provhandle syscall.Handle
		buflen     uint32
		buf        *byte
	}{provhandle, buflen, buf})
	fake.recordInvocation("CryptGenRandom", []interface{}{provhandle, buflen, buf})
	fake.cryptGenRandomMutex.Unlock()
	if fake.CryptGenRandomStub != nil {
		return fake.CryptGenRandomStub(provhandle, buflen, buf)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cryptGenRandomReturns.result1
}

func (fake *FakeSyscall) CryptGenRandomCallCount() int {
	fake.cryptGenRandomMutex.RLock()
	defer fake.cryptGenRandomMutex.RUnlock()
	return len(fake.cryptGenRandomArgsForCall)
}

func (fake *FakeSyscall) CryptGenRandomArgsForCall(i int) (syscall.Handle, uint32, *byte) {
	fake.cryptGenRandomMutex.RLock()
	defer fake.cryptGenRandomMutex.RUnlock()
	return fake.cryptGenRandomArgsForCall[i].provhandle, fake.cryptGenRandomArgsForCall[i].buflen, fake.cryptGenRandomArgsForCall[i].buf
}

func (fake *FakeSyscall) CryptGenRandomReturns(result1 error) {
	fake.CryptGenRandomStub = nil
	fake.cryptGenRandomReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CryptGenRandomReturnsOnCall(i int, result1 error) {
	fake.CryptGenRandomStub = nil
	if fake.cryptGenRandomReturnsOnCall == nil {
		fake.cryptGenRandomReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cryptGenRandomReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetEnvironmentStrings() (envs *uint16, err error) {
	fake.getEnvironmentStringsMutex.Lock()
	ret, specificReturn := fake.getEnvironmentStringsReturnsOnCall[len(fake.getEnvironmentStringsArgsForCall)]
	fake.getEnvironmentStringsArgsForCall = append(fake.getEnvironmentStringsArgsForCall, struct{}{})
	fake.recordInvocation("GetEnvironmentStrings", []interface{}{})
	fake.getEnvironmentStringsMutex.Unlock()
	if fake.GetEnvironmentStringsStub != nil {
		return fake.GetEnvironmentStringsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getEnvironmentStringsReturns.result1, fake.getEnvironmentStringsReturns.result2
}

func (fake *FakeSyscall) GetEnvironmentStringsCallCount() int {
	fake.getEnvironmentStringsMutex.RLock()
	defer fake.getEnvironmentStringsMutex.RUnlock()
	return len(fake.getEnvironmentStringsArgsForCall)
}

func (fake *FakeSyscall) GetEnvironmentStringsReturns(result1 *uint16, result2 error) {
	fake.GetEnvironmentStringsStub = nil
	fake.getEnvironmentStringsReturns = struct {
		result1 *uint16
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetEnvironmentStringsReturnsOnCall(i int, result1 *uint16, result2 error) {
	fake.GetEnvironmentStringsStub = nil
	if fake.getEnvironmentStringsReturnsOnCall == nil {
		fake.getEnvironmentStringsReturnsOnCall = make(map[int]struct {
			result1 *uint16
			result2 error
		})
	}
	fake.getEnvironmentStringsReturnsOnCall[i] = struct {
		result1 *uint16
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) FreeEnvironmentStrings(envs *uint16) (err error) {
	fake.freeEnvironmentStringsMutex.Lock()
	ret, specificReturn := fake.freeEnvironmentStringsReturnsOnCall[len(fake.freeEnvironmentStringsArgsForCall)]
	fake.freeEnvironmentStringsArgsForCall = append(fake.freeEnvironmentStringsArgsForCall, struct {
		envs *uint16
	}{envs})
	fake.recordInvocation("FreeEnvironmentStrings", []interface{}{envs})
	fake.freeEnvironmentStringsMutex.Unlock()
	if fake.FreeEnvironmentStringsStub != nil {
		return fake.FreeEnvironmentStringsStub(envs)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.freeEnvironmentStringsReturns.result1
}

func (fake *FakeSyscall) FreeEnvironmentStringsCallCount() int {
	fake.freeEnvironmentStringsMutex.RLock()
	defer fake.freeEnvironmentStringsMutex.RUnlock()
	return len(fake.freeEnvironmentStringsArgsForCall)
}

func (fake *FakeSyscall) FreeEnvironmentStringsArgsForCall(i int) *uint16 {
	fake.freeEnvironmentStringsMutex.RLock()
	defer fake.freeEnvironmentStringsMutex.RUnlock()
	return fake.freeEnvironmentStringsArgsForCall[i].envs
}

func (fake *FakeSyscall) FreeEnvironmentStringsReturns(result1 error) {
	fake.FreeEnvironmentStringsStub = nil
	fake.freeEnvironmentStringsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FreeEnvironmentStringsReturnsOnCall(i int, result1 error) {
	fake.FreeEnvironmentStringsStub = nil
	if fake.freeEnvironmentStringsReturnsOnCall == nil {
		fake.freeEnvironmentStringsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.freeEnvironmentStringsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) {
	fake.getEnvironmentVariableMutex.Lock()
	ret, specificReturn := fake.getEnvironmentVariableReturnsOnCall[len(fake.getEnvironmentVariableArgsForCall)]
	fake.getEnvironmentVariableArgsForCall = append(fake.getEnvironmentVariableArgsForCall, struct {
		name   *uint16
		buffer *uint16
		size   uint32
	}{name, buffer, size})
	fake.recordInvocation("GetEnvironmentVariable", []interface{}{name, buffer, size})
	fake.getEnvironmentVariableMutex.Unlock()
	if fake.GetEnvironmentVariableStub != nil {
		return fake.GetEnvironmentVariableStub(name, buffer, size)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getEnvironmentVariableReturns.result1, fake.getEnvironmentVariableReturns.result2
}

func (fake *FakeSyscall) GetEnvironmentVariableCallCount() int {
	fake.getEnvironmentVariableMutex.RLock()
	defer fake.getEnvironmentVariableMutex.RUnlock()
	return len(fake.getEnvironmentVariableArgsForCall)
}

func (fake *FakeSyscall) GetEnvironmentVariableArgsForCall(i int) (*uint16, *uint16, uint32) {
	fake.getEnvironmentVariableMutex.RLock()
	defer fake.getEnvironmentVariableMutex.RUnlock()
	return fake.getEnvironmentVariableArgsForCall[i].name, fake.getEnvironmentVariableArgsForCall[i].buffer, fake.getEnvironmentVariableArgsForCall[i].size
}

func (fake *FakeSyscall) GetEnvironmentVariableReturns(result1 uint32, result2 error) {
	fake.GetEnvironmentVariableStub = nil
	fake.getEnvironmentVariableReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetEnvironmentVariableReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.GetEnvironmentVariableStub = nil
	if fake.getEnvironmentVariableReturnsOnCall == nil {
		fake.getEnvironmentVariableReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.getEnvironmentVariableReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetEnvironmentVariable(name *uint16, value *uint16) (err error) {
	fake.setEnvironmentVariableMutex.Lock()
	ret, specificReturn := fake.setEnvironmentVariableReturnsOnCall[len(fake.setEnvironmentVariableArgsForCall)]
	fake.setEnvironmentVariableArgsForCall = append(fake.setEnvironmentVariableArgsForCall, struct {
		name  *uint16
		value *uint16
	}{name, value})
	fake.recordInvocation("SetEnvironmentVariable", []interface{}{name, value})
	fake.setEnvironmentVariableMutex.Unlock()
	if fake.SetEnvironmentVariableStub != nil {
		return fake.SetEnvironmentVariableStub(name, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setEnvironmentVariableReturns.result1
}

func (fake *FakeSyscall) SetEnvironmentVariableCallCount() int {
	fake.setEnvironmentVariableMutex.RLock()
	defer fake.setEnvironmentVariableMutex.RUnlock()
	return len(fake.setEnvironmentVariableArgsForCall)
}

func (fake *FakeSyscall) SetEnvironmentVariableArgsForCall(i int) (*uint16, *uint16) {
	fake.setEnvironmentVariableMutex.RLock()
	defer fake.setEnvironmentVariableMutex.RUnlock()
	return fake.setEnvironmentVariableArgsForCall[i].name, fake.setEnvironmentVariableArgsForCall[i].value
}

func (fake *FakeSyscall) SetEnvironmentVariableReturns(result1 error) {
	fake.SetEnvironmentVariableStub = nil
	fake.setEnvironmentVariableReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetEnvironmentVariableReturnsOnCall(i int, result1 error) {
	fake.SetEnvironmentVariableStub = nil
	if fake.setEnvironmentVariableReturnsOnCall == nil {
		fake.setEnvironmentVariableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setEnvironmentVariableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetFileTime(handle syscall.Handle, ctime *syscall.Filetime, atime *syscall.Filetime, wtime *syscall.Filetime) (err error) {
	fake.setFileTimeMutex.Lock()
	ret, specificReturn := fake.setFileTimeReturnsOnCall[len(fake.setFileTimeArgsForCall)]
	fake.setFileTimeArgsForCall = append(fake.setFileTimeArgsForCall, struct {
		handle syscall.Handle
		ctime  *syscall.Filetime
		atime  *syscall.Filetime
		wtime  *syscall.Filetime
	}{handle, ctime, atime, wtime})
	fake.recordInvocation("SetFileTime", []interface{}{handle, ctime, atime, wtime})
	fake.setFileTimeMutex.Unlock()
	if fake.SetFileTimeStub != nil {
		return fake.SetFileTimeStub(handle, ctime, atime, wtime)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setFileTimeReturns.result1
}

func (fake *FakeSyscall) SetFileTimeCallCount() int {
	fake.setFileTimeMutex.RLock()
	defer fake.setFileTimeMutex.RUnlock()
	return len(fake.setFileTimeArgsForCall)
}

func (fake *FakeSyscall) SetFileTimeArgsForCall(i int) (syscall.Handle, *syscall.Filetime, *syscall.Filetime, *syscall.Filetime) {
	fake.setFileTimeMutex.RLock()
	defer fake.setFileTimeMutex.RUnlock()
	return fake.setFileTimeArgsForCall[i].handle, fake.setFileTimeArgsForCall[i].ctime, fake.setFileTimeArgsForCall[i].atime, fake.setFileTimeArgsForCall[i].wtime
}

func (fake *FakeSyscall) SetFileTimeReturns(result1 error) {
	fake.SetFileTimeStub = nil
	fake.setFileTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetFileTimeReturnsOnCall(i int, result1 error) {
	fake.SetFileTimeStub = nil
	if fake.setFileTimeReturnsOnCall == nil {
		fake.setFileTimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setFileTimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetFileAttributes(name *uint16) (attrs uint32, err error) {
	fake.getFileAttributesMutex.Lock()
	ret, specificReturn := fake.getFileAttributesReturnsOnCall[len(fake.getFileAttributesArgsForCall)]
	fake.getFileAttributesArgsForCall = append(fake.getFileAttributesArgsForCall, struct {
		name *uint16
	}{name})
	fake.recordInvocation("GetFileAttributes", []interface{}{name})
	fake.getFileAttributesMutex.Unlock()
	if fake.GetFileAttributesStub != nil {
		return fake.GetFileAttributesStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getFileAttributesReturns.result1, fake.getFileAttributesReturns.result2
}

func (fake *FakeSyscall) GetFileAttributesCallCount() int {
	fake.getFileAttributesMutex.RLock()
	defer fake.getFileAttributesMutex.RUnlock()
	return len(fake.getFileAttributesArgsForCall)
}

func (fake *FakeSyscall) GetFileAttributesArgsForCall(i int) *uint16 {
	fake.getFileAttributesMutex.RLock()
	defer fake.getFileAttributesMutex.RUnlock()
	return fake.getFileAttributesArgsForCall[i].name
}

func (fake *FakeSyscall) GetFileAttributesReturns(result1 uint32, result2 error) {
	fake.GetFileAttributesStub = nil
	fake.getFileAttributesReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetFileAttributesReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.GetFileAttributesStub = nil
	if fake.getFileAttributesReturnsOnCall == nil {
		fake.getFileAttributesReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.getFileAttributesReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetFileAttributes(name *uint16, attrs uint32) (err error) {
	fake.setFileAttributesMutex.Lock()
	ret, specificReturn := fake.setFileAttributesReturnsOnCall[len(fake.setFileAttributesArgsForCall)]
	fake.setFileAttributesArgsForCall = append(fake.setFileAttributesArgsForCall, struct {
		name  *uint16
		attrs uint32
	}{name, attrs})
	fake.recordInvocation("SetFileAttributes", []interface{}{name, attrs})
	fake.setFileAttributesMutex.Unlock()
	if fake.SetFileAttributesStub != nil {
		return fake.SetFileAttributesStub(name, attrs)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setFileAttributesReturns.result1
}

func (fake *FakeSyscall) SetFileAttributesCallCount() int {
	fake.setFileAttributesMutex.RLock()
	defer fake.setFileAttributesMutex.RUnlock()
	return len(fake.setFileAttributesArgsForCall)
}

func (fake *FakeSyscall) SetFileAttributesArgsForCall(i int) (*uint16, uint32) {
	fake.setFileAttributesMutex.RLock()
	defer fake.setFileAttributesMutex.RUnlock()
	return fake.setFileAttributesArgsForCall[i].name, fake.setFileAttributesArgsForCall[i].attrs
}

func (fake *FakeSyscall) SetFileAttributesReturns(result1 error) {
	fake.SetFileAttributesStub = nil
	fake.setFileAttributesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetFileAttributesReturnsOnCall(i int, result1 error) {
	fake.SetFileAttributesStub = nil
	if fake.setFileAttributesReturnsOnCall == nil {
		fake.setFileAttributesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setFileAttributesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetFileAttributesEx(name *uint16, level uint32, info *byte) (err error) {
	fake.getFileAttributesExMutex.Lock()
	ret, specificReturn := fake.getFileAttributesExReturnsOnCall[len(fake.getFileAttributesExArgsForCall)]
	fake.getFileAttributesExArgsForCall = append(fake.getFileAttributesExArgsForCall, struct {
		name  *uint16
		level uint32
		info  *byte
	}{name, level, info})
	fake.recordInvocation("GetFileAttributesEx", []interface{}{name, level, info})
	fake.getFileAttributesExMutex.Unlock()
	if fake.GetFileAttributesExStub != nil {
		return fake.GetFileAttributesExStub(name, level, info)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getFileAttributesExReturns.result1
}

func (fake *FakeSyscall) GetFileAttributesExCallCount() int {
	fake.getFileAttributesExMutex.RLock()
	defer fake.getFileAttributesExMutex.RUnlock()
	return len(fake.getFileAttributesExArgsForCall)
}

func (fake *FakeSyscall) GetFileAttributesExArgsForCall(i int) (*uint16, uint32, *byte) {
	fake.getFileAttributesExMutex.RLock()
	defer fake.getFileAttributesExMutex.RUnlock()
	return fake.getFileAttributesExArgsForCall[i].name, fake.getFileAttributesExArgsForCall[i].level, fake.getFileAttributesExArgsForCall[i].info
}

func (fake *FakeSyscall) GetFileAttributesExReturns(result1 error) {
	fake.GetFileAttributesExStub = nil
	fake.getFileAttributesExReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetFileAttributesExReturnsOnCall(i int, result1 error) {
	fake.GetFileAttributesExStub = nil
	if fake.getFileAttributesExReturnsOnCall == nil {
		fake.getFileAttributesExReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getFileAttributesExReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetCommandLine() (cmd *uint16) {
	fake.getCommandLineMutex.Lock()
	ret, specificReturn := fake.getCommandLineReturnsOnCall[len(fake.getCommandLineArgsForCall)]
	fake.getCommandLineArgsForCall = append(fake.getCommandLineArgsForCall, struct{}{})
	fake.recordInvocation("GetCommandLine", []interface{}{})
	fake.getCommandLineMutex.Unlock()
	if fake.GetCommandLineStub != nil {
		return fake.GetCommandLineStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getCommandLineReturns.result1
}

func (fake *FakeSyscall) GetCommandLineCallCount() int {
	fake.getCommandLineMutex.RLock()
	defer fake.getCommandLineMutex.RUnlock()
	return len(fake.getCommandLineArgsForCall)
}

func (fake *FakeSyscall) GetCommandLineReturns(result1 *uint16) {
	fake.GetCommandLineStub = nil
	fake.getCommandLineReturns = struct {
		result1 *uint16
	}{result1}
}

func (fake *FakeSyscall) GetCommandLineReturnsOnCall(i int, result1 *uint16) {
	fake.GetCommandLineStub = nil
	if fake.getCommandLineReturnsOnCall == nil {
		fake.getCommandLineReturnsOnCall = make(map[int]struct {
			result1 *uint16
		})
	}
	fake.getCommandLineReturnsOnCall[i] = struct {
		result1 *uint16
	}{result1}
}

func (fake *FakeSyscall) CommandLineToArgv(cmd *uint16, argc *int32) (argv *[8192]*[8192]uint16, err error) {
	fake.commandLineToArgvMutex.Lock()
	ret, specificReturn := fake.commandLineToArgvReturnsOnCall[len(fake.commandLineToArgvArgsForCall)]
	fake.commandLineToArgvArgsForCall = append(fake.commandLineToArgvArgsForCall, struct {
		cmd  *uint16
		argc *int32
	}{cmd, argc})
	fake.recordInvocation("CommandLineToArgv", []interface{}{cmd, argc})
	fake.commandLineToArgvMutex.Unlock()
	if fake.CommandLineToArgvStub != nil {
		return fake.CommandLineToArgvStub(cmd, argc)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.commandLineToArgvReturns.result1, fake.commandLineToArgvReturns.result2
}

func (fake *FakeSyscall) CommandLineToArgvCallCount() int {
	fake.commandLineToArgvMutex.RLock()
	defer fake.commandLineToArgvMutex.RUnlock()
	return len(fake.commandLineToArgvArgsForCall)
}

func (fake *FakeSyscall) CommandLineToArgvArgsForCall(i int) (*uint16, *int32) {
	fake.commandLineToArgvMutex.RLock()
	defer fake.commandLineToArgvMutex.RUnlock()
	return fake.commandLineToArgvArgsForCall[i].cmd, fake.commandLineToArgvArgsForCall[i].argc
}

func (fake *FakeSyscall) CommandLineToArgvReturns(result1 *[8192]*[8192]uint16, result2 error) {
	fake.CommandLineToArgvStub = nil
	fake.commandLineToArgvReturns = struct {
		result1 *[8192]*[8192]uint16
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CommandLineToArgvReturnsOnCall(i int, result1 *[8192]*[8192]uint16, result2 error) {
	fake.CommandLineToArgvStub = nil
	if fake.commandLineToArgvReturnsOnCall == nil {
		fake.commandLineToArgvReturnsOnCall = make(map[int]struct {
			result1 *[8192]*[8192]uint16
			result2 error
		})
	}
	fake.commandLineToArgvReturnsOnCall[i] = struct {
		result1 *[8192]*[8192]uint16
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) LocalFree(hmem syscall.Handle) (handle syscall.Handle, err error) {
	fake.localFreeMutex.Lock()
	ret, specificReturn := fake.localFreeReturnsOnCall[len(fake.localFreeArgsForCall)]
	fake.localFreeArgsForCall = append(fake.localFreeArgsForCall, struct {
		hmem syscall.Handle
	}{hmem})
	fake.recordInvocation("LocalFree", []interface{}{hmem})
	fake.localFreeMutex.Unlock()
	if fake.LocalFreeStub != nil {
		return fake.LocalFreeStub(hmem)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.localFreeReturns.result1, fake.localFreeReturns.result2
}

func (fake *FakeSyscall) LocalFreeCallCount() int {
	fake.localFreeMutex.RLock()
	defer fake.localFreeMutex.RUnlock()
	return len(fake.localFreeArgsForCall)
}

func (fake *FakeSyscall) LocalFreeArgsForCall(i int) syscall.Handle {
	fake.localFreeMutex.RLock()
	defer fake.localFreeMutex.RUnlock()
	return fake.localFreeArgsForCall[i].hmem
}

func (fake *FakeSyscall) LocalFreeReturns(result1 syscall.Handle, result2 error) {
	fake.LocalFreeStub = nil
	fake.localFreeReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) LocalFreeReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.LocalFreeStub = nil
	if fake.localFreeReturnsOnCall == nil {
		fake.localFreeReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.localFreeReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) SetHandleInformation(handle syscall.Handle, mask uint32, flags uint32) (err error) {
	fake.setHandleInformationMutex.Lock()
	ret, specificReturn := fake.setHandleInformationReturnsOnCall[len(fake.setHandleInformationArgsForCall)]
	fake.setHandleInformationArgsForCall = append(fake.setHandleInformationArgsForCall, struct {
		handle syscall.Handle
		mask   uint32
		flags  uint32
	}{handle, mask, flags})
	fake.recordInvocation("SetHandleInformation", []interface{}{handle, mask, flags})
	fake.setHandleInformationMutex.Unlock()
	if fake.SetHandleInformationStub != nil {
		return fake.SetHandleInformationStub(handle, mask, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setHandleInformationReturns.result1
}

func (fake *FakeSyscall) SetHandleInformationCallCount() int {
	fake.setHandleInformationMutex.RLock()
	defer fake.setHandleInformationMutex.RUnlock()
	return len(fake.setHandleInformationArgsForCall)
}

func (fake *FakeSyscall) SetHandleInformationArgsForCall(i int) (syscall.Handle, uint32, uint32) {
	fake.setHandleInformationMutex.RLock()
	defer fake.setHandleInformationMutex.RUnlock()
	return fake.setHandleInformationArgsForCall[i].handle, fake.setHandleInformationArgsForCall[i].mask, fake.setHandleInformationArgsForCall[i].flags
}

func (fake *FakeSyscall) SetHandleInformationReturns(result1 error) {
	fake.SetHandleInformationStub = nil
	fake.setHandleInformationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetHandleInformationReturnsOnCall(i int, result1 error) {
	fake.SetHandleInformationStub = nil
	if fake.setHandleInformationReturnsOnCall == nil {
		fake.setHandleInformationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setHandleInformationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FlushFileBuffers(handle syscall.Handle) (err error) {
	fake.flushFileBuffersMutex.Lock()
	ret, specificReturn := fake.flushFileBuffersReturnsOnCall[len(fake.flushFileBuffersArgsForCall)]
	fake.flushFileBuffersArgsForCall = append(fake.flushFileBuffersArgsForCall, struct {
		handle syscall.Handle
	}{handle})
	fake.recordInvocation("FlushFileBuffers", []interface{}{handle})
	fake.flushFileBuffersMutex.Unlock()
	if fake.FlushFileBuffersStub != nil {
		return fake.FlushFileBuffersStub(handle)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.flushFileBuffersReturns.result1
}

func (fake *FakeSyscall) FlushFileBuffersCallCount() int {
	fake.flushFileBuffersMutex.RLock()
	defer fake.flushFileBuffersMutex.RUnlock()
	return len(fake.flushFileBuffersArgsForCall)
}

func (fake *FakeSyscall) FlushFileBuffersArgsForCall(i int) syscall.Handle {
	fake.flushFileBuffersMutex.RLock()
	defer fake.flushFileBuffersMutex.RUnlock()
	return fake.flushFileBuffersArgsForCall[i].handle
}

func (fake *FakeSyscall) FlushFileBuffersReturns(result1 error) {
	fake.FlushFileBuffersStub = nil
	fake.flushFileBuffersReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FlushFileBuffersReturnsOnCall(i int, result1 error) {
	fake.FlushFileBuffersStub = nil
	if fake.flushFileBuffersReturnsOnCall == nil {
		fake.flushFileBuffersReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.flushFileBuffersReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetFullPathName(path *uint16, buflen uint32, buf *uint16, fname **uint16) (n uint32, err error) {
	fake.getFullPathNameMutex.Lock()
	ret, specificReturn := fake.getFullPathNameReturnsOnCall[len(fake.getFullPathNameArgsForCall)]
	fake.getFullPathNameArgsForCall = append(fake.getFullPathNameArgsForCall, struct {
		path   *uint16
		buflen uint32
		buf    *uint16
		fname  **uint16
	}{path, buflen, buf, fname})
	fake.recordInvocation("GetFullPathName", []interface{}{path, buflen, buf, fname})
	fake.getFullPathNameMutex.Unlock()
	if fake.GetFullPathNameStub != nil {
		return fake.GetFullPathNameStub(path, buflen, buf, fname)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getFullPathNameReturns.result1, fake.getFullPathNameReturns.result2
}

func (fake *FakeSyscall) GetFullPathNameCallCount() int {
	fake.getFullPathNameMutex.RLock()
	defer fake.getFullPathNameMutex.RUnlock()
	return len(fake.getFullPathNameArgsForCall)
}

func (fake *FakeSyscall) GetFullPathNameArgsForCall(i int) (*uint16, uint32, *uint16, **uint16) {
	fake.getFullPathNameMutex.RLock()
	defer fake.getFullPathNameMutex.RUnlock()
	return fake.getFullPathNameArgsForCall[i].path, fake.getFullPathNameArgsForCall[i].buflen, fake.getFullPathNameArgsForCall[i].buf, fake.getFullPathNameArgsForCall[i].fname
}

func (fake *FakeSyscall) GetFullPathNameReturns(result1 uint32, result2 error) {
	fake.GetFullPathNameStub = nil
	fake.getFullPathNameReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetFullPathNameReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.GetFullPathNameStub = nil
	if fake.getFullPathNameReturnsOnCall == nil {
		fake.getFullPathNameReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.getFullPathNameReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetLongPathName(path *uint16, buf *uint16, buflen uint32) (n uint32, err error) {
	fake.getLongPathNameMutex.Lock()
	ret, specificReturn := fake.getLongPathNameReturnsOnCall[len(fake.getLongPathNameArgsForCall)]
	fake.getLongPathNameArgsForCall = append(fake.getLongPathNameArgsForCall, struct {
		path   *uint16
		buf    *uint16
		buflen uint32
	}{path, buf, buflen})
	fake.recordInvocation("GetLongPathName", []interface{}{path, buf, buflen})
	fake.getLongPathNameMutex.Unlock()
	if fake.GetLongPathNameStub != nil {
		return fake.GetLongPathNameStub(path, buf, buflen)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getLongPathNameReturns.result1, fake.getLongPathNameReturns.result2
}

func (fake *FakeSyscall) GetLongPathNameCallCount() int {
	fake.getLongPathNameMutex.RLock()
	defer fake.getLongPathNameMutex.RUnlock()
	return len(fake.getLongPathNameArgsForCall)
}

func (fake *FakeSyscall) GetLongPathNameArgsForCall(i int) (*uint16, *uint16, uint32) {
	fake.getLongPathNameMutex.RLock()
	defer fake.getLongPathNameMutex.RUnlock()
	return fake.getLongPathNameArgsForCall[i].path, fake.getLongPathNameArgsForCall[i].buf, fake.getLongPathNameArgsForCall[i].buflen
}

func (fake *FakeSyscall) GetLongPathNameReturns(result1 uint32, result2 error) {
	fake.GetLongPathNameStub = nil
	fake.getLongPathNameReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetLongPathNameReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.GetLongPathNameStub = nil
	if fake.getLongPathNameReturnsOnCall == nil {
		fake.getLongPathNameReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.getLongPathNameReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetShortPathName(longpath *uint16, shortpath *uint16, buflen uint32) (n uint32, err error) {
	fake.getShortPathNameMutex.Lock()
	ret, specificReturn := fake.getShortPathNameReturnsOnCall[len(fake.getShortPathNameArgsForCall)]
	fake.getShortPathNameArgsForCall = append(fake.getShortPathNameArgsForCall, struct {
		longpath  *uint16
		shortpath *uint16
		buflen    uint32
	}{longpath, shortpath, buflen})
	fake.recordInvocation("GetShortPathName", []interface{}{longpath, shortpath, buflen})
	fake.getShortPathNameMutex.Unlock()
	if fake.GetShortPathNameStub != nil {
		return fake.GetShortPathNameStub(longpath, shortpath, buflen)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getShortPathNameReturns.result1, fake.getShortPathNameReturns.result2
}

func (fake *FakeSyscall) GetShortPathNameCallCount() int {
	fake.getShortPathNameMutex.RLock()
	defer fake.getShortPathNameMutex.RUnlock()
	return len(fake.getShortPathNameArgsForCall)
}

func (fake *FakeSyscall) GetShortPathNameArgsForCall(i int) (*uint16, *uint16, uint32) {
	fake.getShortPathNameMutex.RLock()
	defer fake.getShortPathNameMutex.RUnlock()
	return fake.getShortPathNameArgsForCall[i].longpath, fake.getShortPathNameArgsForCall[i].shortpath, fake.getShortPathNameArgsForCall[i].buflen
}

func (fake *FakeSyscall) GetShortPathNameReturns(result1 uint32, result2 error) {
	fake.GetShortPathNameStub = nil
	fake.getShortPathNameReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetShortPathNameReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.GetShortPathNameStub = nil
	if fake.getShortPathNameReturnsOnCall == nil {
		fake.getShortPathNameReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.getShortPathNameReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CreateFileMapping(fhandle syscall.Handle, sa *syscall.SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle syscall.Handle, err error) {
	fake.createFileMappingMutex.Lock()
	ret, specificReturn := fake.createFileMappingReturnsOnCall[len(fake.createFileMappingArgsForCall)]
	fake.createFileMappingArgsForCall = append(fake.createFileMappingArgsForCall, struct {
		fhandle     syscall.Handle
		sa          *syscall.SecurityAttributes
		prot        uint32
		maxSizeHigh uint32
		maxSizeLow  uint32
		name        *uint16
	}{fhandle, sa, prot, maxSizeHigh, maxSizeLow, name})
	fake.recordInvocation("CreateFileMapping", []interface{}{fhandle, sa, prot, maxSizeHigh, maxSizeLow, name})
	fake.createFileMappingMutex.Unlock()
	if fake.CreateFileMappingStub != nil {
		return fake.CreateFileMappingStub(fhandle, sa, prot, maxSizeHigh, maxSizeLow, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createFileMappingReturns.result1, fake.createFileMappingReturns.result2
}

func (fake *FakeSyscall) CreateFileMappingCallCount() int {
	fake.createFileMappingMutex.RLock()
	defer fake.createFileMappingMutex.RUnlock()
	return len(fake.createFileMappingArgsForCall)
}

func (fake *FakeSyscall) CreateFileMappingArgsForCall(i int) (syscall.Handle, *syscall.SecurityAttributes, uint32, uint32, uint32, *uint16) {
	fake.createFileMappingMutex.RLock()
	defer fake.createFileMappingMutex.RUnlock()
	return fake.createFileMappingArgsForCall[i].fhandle, fake.createFileMappingArgsForCall[i].sa, fake.createFileMappingArgsForCall[i].prot, fake.createFileMappingArgsForCall[i].maxSizeHigh, fake.createFileMappingArgsForCall[i].maxSizeLow, fake.createFileMappingArgsForCall[i].name
}

func (fake *FakeSyscall) CreateFileMappingReturns(result1 syscall.Handle, result2 error) {
	fake.CreateFileMappingStub = nil
	fake.createFileMappingReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CreateFileMappingReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.CreateFileMappingStub = nil
	if fake.createFileMappingReturnsOnCall == nil {
		fake.createFileMappingReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.createFileMappingReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) MapViewOfFile(handle syscall.Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, err error) {
	fake.mapViewOfFileMutex.Lock()
	ret, specificReturn := fake.mapViewOfFileReturnsOnCall[len(fake.mapViewOfFileArgsForCall)]
	fake.mapViewOfFileArgsForCall = append(fake.mapViewOfFileArgsForCall, struct {
		handle     syscall.Handle
		access     uint32
		offsetHigh uint32
		offsetLow  uint32
		length     uintptr
	}{handle, access, offsetHigh, offsetLow, length})
	fake.recordInvocation("MapViewOfFile", []interface{}{handle, access, offsetHigh, offsetLow, length})
	fake.mapViewOfFileMutex.Unlock()
	if fake.MapViewOfFileStub != nil {
		return fake.MapViewOfFileStub(handle, access, offsetHigh, offsetLow, length)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.mapViewOfFileReturns.result1, fake.mapViewOfFileReturns.result2
}

func (fake *FakeSyscall) MapViewOfFileCallCount() int {
	fake.mapViewOfFileMutex.RLock()
	defer fake.mapViewOfFileMutex.RUnlock()
	return len(fake.mapViewOfFileArgsForCall)
}

func (fake *FakeSyscall) MapViewOfFileArgsForCall(i int) (syscall.Handle, uint32, uint32, uint32, uintptr) {
	fake.mapViewOfFileMutex.RLock()
	defer fake.mapViewOfFileMutex.RUnlock()
	return fake.mapViewOfFileArgsForCall[i].handle, fake.mapViewOfFileArgsForCall[i].access, fake.mapViewOfFileArgsForCall[i].offsetHigh, fake.mapViewOfFileArgsForCall[i].offsetLow, fake.mapViewOfFileArgsForCall[i].length
}

func (fake *FakeSyscall) MapViewOfFileReturns(result1 uintptr, result2 error) {
	fake.MapViewOfFileStub = nil
	fake.mapViewOfFileReturns = struct {
		result1 uintptr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) MapViewOfFileReturnsOnCall(i int, result1 uintptr, result2 error) {
	fake.MapViewOfFileStub = nil
	if fake.mapViewOfFileReturnsOnCall == nil {
		fake.mapViewOfFileReturnsOnCall = make(map[int]struct {
			result1 uintptr
			result2 error
		})
	}
	fake.mapViewOfFileReturnsOnCall[i] = struct {
		result1 uintptr
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) UnmapViewOfFile(addr uintptr) (err error) {
	fake.unmapViewOfFileMutex.Lock()
	ret, specificReturn := fake.unmapViewOfFileReturnsOnCall[len(fake.unmapViewOfFileArgsForCall)]
	fake.unmapViewOfFileArgsForCall = append(fake.unmapViewOfFileArgsForCall, struct {
		addr uintptr
	}{addr})
	fake.recordInvocation("UnmapViewOfFile", []interface{}{addr})
	fake.unmapViewOfFileMutex.Unlock()
	if fake.UnmapViewOfFileStub != nil {
		return fake.UnmapViewOfFileStub(addr)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unmapViewOfFileReturns.result1
}

func (fake *FakeSyscall) UnmapViewOfFileCallCount() int {
	fake.unmapViewOfFileMutex.RLock()
	defer fake.unmapViewOfFileMutex.RUnlock()
	return len(fake.unmapViewOfFileArgsForCall)
}

func (fake *FakeSyscall) UnmapViewOfFileArgsForCall(i int) uintptr {
	fake.unmapViewOfFileMutex.RLock()
	defer fake.unmapViewOfFileMutex.RUnlock()
	return fake.unmapViewOfFileArgsForCall[i].addr
}

func (fake *FakeSyscall) UnmapViewOfFileReturns(result1 error) {
	fake.UnmapViewOfFileStub = nil
	fake.unmapViewOfFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) UnmapViewOfFileReturnsOnCall(i int, result1 error) {
	fake.UnmapViewOfFileStub = nil
	if fake.unmapViewOfFileReturnsOnCall == nil {
		fake.unmapViewOfFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unmapViewOfFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FlushViewOfFile(addr uintptr, length uintptr) (err error) {
	fake.flushViewOfFileMutex.Lock()
	ret, specificReturn := fake.flushViewOfFileReturnsOnCall[len(fake.flushViewOfFileArgsForCall)]
	fake.flushViewOfFileArgsForCall = append(fake.flushViewOfFileArgsForCall, struct {
		addr   uintptr
		length uintptr
	}{addr, length})
	fake.recordInvocation("FlushViewOfFile", []interface{}{addr, length})
	fake.flushViewOfFileMutex.Unlock()
	if fake.FlushViewOfFileStub != nil {
		return fake.FlushViewOfFileStub(addr, length)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.flushViewOfFileReturns.result1
}

func (fake *FakeSyscall) FlushViewOfFileCallCount() int {
	fake.flushViewOfFileMutex.RLock()
	defer fake.flushViewOfFileMutex.RUnlock()
	return len(fake.flushViewOfFileArgsForCall)
}

func (fake *FakeSyscall) FlushViewOfFileArgsForCall(i int) (uintptr, uintptr) {
	fake.flushViewOfFileMutex.RLock()
	defer fake.flushViewOfFileMutex.RUnlock()
	return fake.flushViewOfFileArgsForCall[i].addr, fake.flushViewOfFileArgsForCall[i].length
}

func (fake *FakeSyscall) FlushViewOfFileReturns(result1 error) {
	fake.FlushViewOfFileStub = nil
	fake.flushViewOfFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FlushViewOfFileReturnsOnCall(i int, result1 error) {
	fake.FlushViewOfFileStub = nil
	if fake.flushViewOfFileReturnsOnCall == nil {
		fake.flushViewOfFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.flushViewOfFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) VirtualLock(addr uintptr, length uintptr) (err error) {
	fake.virtualLockMutex.Lock()
	ret, specificReturn := fake.virtualLockReturnsOnCall[len(fake.virtualLockArgsForCall)]
	fake.virtualLockArgsForCall = append(fake.virtualLockArgsForCall, struct {
		addr   uintptr
		length uintptr
	}{addr, length})
	fake.recordInvocation("VirtualLock", []interface{}{addr, length})
	fake.virtualLockMutex.Unlock()
	if fake.VirtualLockStub != nil {
		return fake.VirtualLockStub(addr, length)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.virtualLockReturns.result1
}

func (fake *FakeSyscall) VirtualLockCallCount() int {
	fake.virtualLockMutex.RLock()
	defer fake.virtualLockMutex.RUnlock()
	return len(fake.virtualLockArgsForCall)
}

func (fake *FakeSyscall) VirtualLockArgsForCall(i int) (uintptr, uintptr) {
	fake.virtualLockMutex.RLock()
	defer fake.virtualLockMutex.RUnlock()
	return fake.virtualLockArgsForCall[i].addr, fake.virtualLockArgsForCall[i].length
}

func (fake *FakeSyscall) VirtualLockReturns(result1 error) {
	fake.VirtualLockStub = nil
	fake.virtualLockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) VirtualLockReturnsOnCall(i int, result1 error) {
	fake.VirtualLockStub = nil
	if fake.virtualLockReturnsOnCall == nil {
		fake.virtualLockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.virtualLockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) VirtualUnlock(addr uintptr, length uintptr) (err error) {
	fake.virtualUnlockMutex.Lock()
	ret, specificReturn := fake.virtualUnlockReturnsOnCall[len(fake.virtualUnlockArgsForCall)]
	fake.virtualUnlockArgsForCall = append(fake.virtualUnlockArgsForCall, struct {
		addr   uintptr
		length uintptr
	}{addr, length})
	fake.recordInvocation("VirtualUnlock", []interface{}{addr, length})
	fake.virtualUnlockMutex.Unlock()
	if fake.VirtualUnlockStub != nil {
		return fake.VirtualUnlockStub(addr, length)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.virtualUnlockReturns.result1
}

func (fake *FakeSyscall) VirtualUnlockCallCount() int {
	fake.virtualUnlockMutex.RLock()
	defer fake.virtualUnlockMutex.RUnlock()
	return len(fake.virtualUnlockArgsForCall)
}

func (fake *FakeSyscall) VirtualUnlockArgsForCall(i int) (uintptr, uintptr) {
	fake.virtualUnlockMutex.RLock()
	defer fake.virtualUnlockMutex.RUnlock()
	return fake.virtualUnlockArgsForCall[i].addr, fake.virtualUnlockArgsForCall[i].length
}

func (fake *FakeSyscall) VirtualUnlockReturns(result1 error) {
	fake.VirtualUnlockStub = nil
	fake.virtualUnlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) VirtualUnlockReturnsOnCall(i int, result1 error) {
	fake.VirtualUnlockStub = nil
	if fake.virtualUnlockReturnsOnCall == nil {
		fake.virtualUnlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.virtualUnlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) TransmitFile(s syscall.Handle, handle syscall.Handle, bytesToWrite uint32, bytsPerSend uint32, overlapped *syscall.Overlapped, transmitFileBuf *syscall.TransmitFileBuffers, flags uint32) (err error) {
	fake.transmitFileMutex.Lock()
	ret, specificReturn := fake.transmitFileReturnsOnCall[len(fake.transmitFileArgsForCall)]
	fake.transmitFileArgsForCall = append(fake.transmitFileArgsForCall, struct {
		s               syscall.Handle
		handle          syscall.Handle
		bytesToWrite    uint32
		bytsPerSend     uint32
		overlapped      *syscall.Overlapped
		transmitFileBuf *syscall.TransmitFileBuffers
		flags           uint32
	}{s, handle, bytesToWrite, bytsPerSend, overlapped, transmitFileBuf, flags})
	fake.recordInvocation("TransmitFile", []interface{}{s, handle, bytesToWrite, bytsPerSend, overlapped, transmitFileBuf, flags})
	fake.transmitFileMutex.Unlock()
	if fake.TransmitFileStub != nil {
		return fake.TransmitFileStub(s, handle, bytesToWrite, bytsPerSend, overlapped, transmitFileBuf, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.transmitFileReturns.result1
}

func (fake *FakeSyscall) TransmitFileCallCount() int {
	fake.transmitFileMutex.RLock()
	defer fake.transmitFileMutex.RUnlock()
	return len(fake.transmitFileArgsForCall)
}

func (fake *FakeSyscall) TransmitFileArgsForCall(i int) (syscall.Handle, syscall.Handle, uint32, uint32, *syscall.Overlapped, *syscall.TransmitFileBuffers, uint32) {
	fake.transmitFileMutex.RLock()
	defer fake.transmitFileMutex.RUnlock()
	return fake.transmitFileArgsForCall[i].s, fake.transmitFileArgsForCall[i].handle, fake.transmitFileArgsForCall[i].bytesToWrite, fake.transmitFileArgsForCall[i].bytsPerSend, fake.transmitFileArgsForCall[i].overlapped, fake.transmitFileArgsForCall[i].transmitFileBuf, fake.transmitFileArgsForCall[i].flags
}

func (fake *FakeSyscall) TransmitFileReturns(result1 error) {
	fake.TransmitFileStub = nil
	fake.transmitFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) TransmitFileReturnsOnCall(i int, result1 error) {
	fake.TransmitFileStub = nil
	if fake.transmitFileReturnsOnCall == nil {
		fake.transmitFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.transmitFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ReadDirectoryChanges(handle syscall.Handle, buf *byte, buflen uint32, watchSubTree bool, mask uint32, retlen *uint32, overlapped *syscall.Overlapped, completionRoutine uintptr) (err error) {
	fake.readDirectoryChangesMutex.Lock()
	ret, specificReturn := fake.readDirectoryChangesReturnsOnCall[len(fake.readDirectoryChangesArgsForCall)]
	fake.readDirectoryChangesArgsForCall = append(fake.readDirectoryChangesArgsForCall, struct {
		handle            syscall.Handle
		buf               *byte
		buflen            uint32
		watchSubTree      bool
		mask              uint32
		retlen            *uint32
		overlapped        *syscall.Overlapped
		completionRoutine uintptr
	}{handle, buf, buflen, watchSubTree, mask, retlen, overlapped, completionRoutine})
	fake.recordInvocation("ReadDirectoryChanges", []interface{}{handle, buf, buflen, watchSubTree, mask, retlen, overlapped, completionRoutine})
	fake.readDirectoryChangesMutex.Unlock()
	if fake.ReadDirectoryChangesStub != nil {
		return fake.ReadDirectoryChangesStub(handle, buf, buflen, watchSubTree, mask, retlen, overlapped, completionRoutine)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.readDirectoryChangesReturns.result1
}

func (fake *FakeSyscall) ReadDirectoryChangesCallCount() int {
	fake.readDirectoryChangesMutex.RLock()
	defer fake.readDirectoryChangesMutex.RUnlock()
	return len(fake.readDirectoryChangesArgsForCall)
}

func (fake *FakeSyscall) ReadDirectoryChangesArgsForCall(i int) (syscall.Handle, *byte, uint32, bool, uint32, *uint32, *syscall.Overlapped, uintptr) {
	fake.readDirectoryChangesMutex.RLock()
	defer fake.readDirectoryChangesMutex.RUnlock()
	return fake.readDirectoryChangesArgsForCall[i].handle, fake.readDirectoryChangesArgsForCall[i].buf, fake.readDirectoryChangesArgsForCall[i].buflen, fake.readDirectoryChangesArgsForCall[i].watchSubTree, fake.readDirectoryChangesArgsForCall[i].mask, fake.readDirectoryChangesArgsForCall[i].retlen, fake.readDirectoryChangesArgsForCall[i].overlapped, fake.readDirectoryChangesArgsForCall[i].completionRoutine
}

func (fake *FakeSyscall) ReadDirectoryChangesReturns(result1 error) {
	fake.ReadDirectoryChangesStub = nil
	fake.readDirectoryChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ReadDirectoryChangesReturnsOnCall(i int, result1 error) {
	fake.ReadDirectoryChangesStub = nil
	if fake.readDirectoryChangesReturnsOnCall == nil {
		fake.readDirectoryChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.readDirectoryChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CertOpenSystemStore(hprov syscall.Handle, name *uint16) (store syscall.Handle, err error) {
	fake.certOpenSystemStoreMutex.Lock()
	ret, specificReturn := fake.certOpenSystemStoreReturnsOnCall[len(fake.certOpenSystemStoreArgsForCall)]
	fake.certOpenSystemStoreArgsForCall = append(fake.certOpenSystemStoreArgsForCall, struct {
		hprov syscall.Handle
		name  *uint16
	}{hprov, name})
	fake.recordInvocation("CertOpenSystemStore", []interface{}{hprov, name})
	fake.certOpenSystemStoreMutex.Unlock()
	if fake.CertOpenSystemStoreStub != nil {
		return fake.CertOpenSystemStoreStub(hprov, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.certOpenSystemStoreReturns.result1, fake.certOpenSystemStoreReturns.result2
}

func (fake *FakeSyscall) CertOpenSystemStoreCallCount() int {
	fake.certOpenSystemStoreMutex.RLock()
	defer fake.certOpenSystemStoreMutex.RUnlock()
	return len(fake.certOpenSystemStoreArgsForCall)
}

func (fake *FakeSyscall) CertOpenSystemStoreArgsForCall(i int) (syscall.Handle, *uint16) {
	fake.certOpenSystemStoreMutex.RLock()
	defer fake.certOpenSystemStoreMutex.RUnlock()
	return fake.certOpenSystemStoreArgsForCall[i].hprov, fake.certOpenSystemStoreArgsForCall[i].name
}

func (fake *FakeSyscall) CertOpenSystemStoreReturns(result1 syscall.Handle, result2 error) {
	fake.CertOpenSystemStoreStub = nil
	fake.certOpenSystemStoreReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CertOpenSystemStoreReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.CertOpenSystemStoreStub = nil
	if fake.certOpenSystemStoreReturnsOnCall == nil {
		fake.certOpenSystemStoreReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.certOpenSystemStoreReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle syscall.Handle, err error) {
	fake.certOpenStoreMutex.Lock()
	ret, specificReturn := fake.certOpenStoreReturnsOnCall[len(fake.certOpenStoreArgsForCall)]
	fake.certOpenStoreArgsForCall = append(fake.certOpenStoreArgsForCall, struct {
		storeProvider          uintptr
		msgAndCertEncodingType uint32
		cryptProv              uintptr
		flags                  uint32
		para                   uintptr
	}{storeProvider, msgAndCertEncodingType, cryptProv, flags, para})
	fake.recordInvocation("CertOpenStore", []interface{}{storeProvider, msgAndCertEncodingType, cryptProv, flags, para})
	fake.certOpenStoreMutex.Unlock()
	if fake.CertOpenStoreStub != nil {
		return fake.CertOpenStoreStub(storeProvider, msgAndCertEncodingType, cryptProv, flags, para)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.certOpenStoreReturns.result1, fake.certOpenStoreReturns.result2
}

func (fake *FakeSyscall) CertOpenStoreCallCount() int {
	fake.certOpenStoreMutex.RLock()
	defer fake.certOpenStoreMutex.RUnlock()
	return len(fake.certOpenStoreArgsForCall)
}

func (fake *FakeSyscall) CertOpenStoreArgsForCall(i int) (uintptr, uint32, uintptr, uint32, uintptr) {
	fake.certOpenStoreMutex.RLock()
	defer fake.certOpenStoreMutex.RUnlock()
	return fake.certOpenStoreArgsForCall[i].storeProvider, fake.certOpenStoreArgsForCall[i].msgAndCertEncodingType, fake.certOpenStoreArgsForCall[i].cryptProv, fake.certOpenStoreArgsForCall[i].flags, fake.certOpenStoreArgsForCall[i].para
}

func (fake *FakeSyscall) CertOpenStoreReturns(result1 syscall.Handle, result2 error) {
	fake.CertOpenStoreStub = nil
	fake.certOpenStoreReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CertOpenStoreReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.CertOpenStoreStub = nil
	if fake.certOpenStoreReturnsOnCall == nil {
		fake.certOpenStoreReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.certOpenStoreReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CertEnumCertificatesInStore(store syscall.Handle, prevContext *syscall.CertContext) (context *syscall.CertContext, err error) {
	fake.certEnumCertificatesInStoreMutex.Lock()
	ret, specificReturn := fake.certEnumCertificatesInStoreReturnsOnCall[len(fake.certEnumCertificatesInStoreArgsForCall)]
	fake.certEnumCertificatesInStoreArgsForCall = append(fake.certEnumCertificatesInStoreArgsForCall, struct {
		store       syscall.Handle
		prevContext *syscall.CertContext
	}{store, prevContext})
	fake.recordInvocation("CertEnumCertificatesInStore", []interface{}{store, prevContext})
	fake.certEnumCertificatesInStoreMutex.Unlock()
	if fake.CertEnumCertificatesInStoreStub != nil {
		return fake.CertEnumCertificatesInStoreStub(store, prevContext)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.certEnumCertificatesInStoreReturns.result1, fake.certEnumCertificatesInStoreReturns.result2
}

func (fake *FakeSyscall) CertEnumCertificatesInStoreCallCount() int {
	fake.certEnumCertificatesInStoreMutex.RLock()
	defer fake.certEnumCertificatesInStoreMutex.RUnlock()
	return len(fake.certEnumCertificatesInStoreArgsForCall)
}

func (fake *FakeSyscall) CertEnumCertificatesInStoreArgsForCall(i int) (syscall.Handle, *syscall.CertContext) {
	fake.certEnumCertificatesInStoreMutex.RLock()
	defer fake.certEnumCertificatesInStoreMutex.RUnlock()
	return fake.certEnumCertificatesInStoreArgsForCall[i].store, fake.certEnumCertificatesInStoreArgsForCall[i].prevContext
}

func (fake *FakeSyscall) CertEnumCertificatesInStoreReturns(result1 *syscall.CertContext, result2 error) {
	fake.CertEnumCertificatesInStoreStub = nil
	fake.certEnumCertificatesInStoreReturns = struct {
		result1 *syscall.CertContext
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CertEnumCertificatesInStoreReturnsOnCall(i int, result1 *syscall.CertContext, result2 error) {
	fake.CertEnumCertificatesInStoreStub = nil
	if fake.certEnumCertificatesInStoreReturnsOnCall == nil {
		fake.certEnumCertificatesInStoreReturnsOnCall = make(map[int]struct {
			result1 *syscall.CertContext
			result2 error
		})
	}
	fake.certEnumCertificatesInStoreReturnsOnCall[i] = struct {
		result1 *syscall.CertContext
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CertAddCertificateContextToStore(store syscall.Handle, certContext *syscall.CertContext, addDisposition uint32, storeContext **syscall.CertContext) (err error) {
	fake.certAddCertificateContextToStoreMutex.Lock()
	ret, specificReturn := fake.certAddCertificateContextToStoreReturnsOnCall[len(fake.certAddCertificateContextToStoreArgsForCall)]
	fake.certAddCertificateContextToStoreArgsForCall = append(fake.certAddCertificateContextToStoreArgsForCall, struct {
		store          syscall.Handle
		certContext    *syscall.CertContext
		addDisposition uint32
		storeContext   **syscall.CertContext
	}{store, certContext, addDisposition, storeContext})
	fake.recordInvocation("CertAddCertificateContextToStore", []interface{}{store, certContext, addDisposition, storeContext})
	fake.certAddCertificateContextToStoreMutex.Unlock()
	if fake.CertAddCertificateContextToStoreStub != nil {
		return fake.CertAddCertificateContextToStoreStub(store, certContext, addDisposition, storeContext)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.certAddCertificateContextToStoreReturns.result1
}

func (fake *FakeSyscall) CertAddCertificateContextToStoreCallCount() int {
	fake.certAddCertificateContextToStoreMutex.RLock()
	defer fake.certAddCertificateContextToStoreMutex.RUnlock()
	return len(fake.certAddCertificateContextToStoreArgsForCall)
}

func (fake *FakeSyscall) CertAddCertificateContextToStoreArgsForCall(i int) (syscall.Handle, *syscall.CertContext, uint32, **syscall.CertContext) {
	fake.certAddCertificateContextToStoreMutex.RLock()
	defer fake.certAddCertificateContextToStoreMutex.RUnlock()
	return fake.certAddCertificateContextToStoreArgsForCall[i].store, fake.certAddCertificateContextToStoreArgsForCall[i].certContext, fake.certAddCertificateContextToStoreArgsForCall[i].addDisposition, fake.certAddCertificateContextToStoreArgsForCall[i].storeContext
}

func (fake *FakeSyscall) CertAddCertificateContextToStoreReturns(result1 error) {
	fake.CertAddCertificateContextToStoreStub = nil
	fake.certAddCertificateContextToStoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CertAddCertificateContextToStoreReturnsOnCall(i int, result1 error) {
	fake.CertAddCertificateContextToStoreStub = nil
	if fake.certAddCertificateContextToStoreReturnsOnCall == nil {
		fake.certAddCertificateContextToStoreReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.certAddCertificateContextToStoreReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CertCloseStore(store syscall.Handle, flags uint32) (err error) {
	fake.certCloseStoreMutex.Lock()
	ret, specificReturn := fake.certCloseStoreReturnsOnCall[len(fake.certCloseStoreArgsForCall)]
	fake.certCloseStoreArgsForCall = append(fake.certCloseStoreArgsForCall, struct {
		store syscall.Handle
		flags uint32
	}{store, flags})
	fake.recordInvocation("CertCloseStore", []interface{}{store, flags})
	fake.certCloseStoreMutex.Unlock()
	if fake.CertCloseStoreStub != nil {
		return fake.CertCloseStoreStub(store, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.certCloseStoreReturns.result1
}

func (fake *FakeSyscall) CertCloseStoreCallCount() int {
	fake.certCloseStoreMutex.RLock()
	defer fake.certCloseStoreMutex.RUnlock()
	return len(fake.certCloseStoreArgsForCall)
}

func (fake *FakeSyscall) CertCloseStoreArgsForCall(i int) (syscall.Handle, uint32) {
	fake.certCloseStoreMutex.RLock()
	defer fake.certCloseStoreMutex.RUnlock()
	return fake.certCloseStoreArgsForCall[i].store, fake.certCloseStoreArgsForCall[i].flags
}

func (fake *FakeSyscall) CertCloseStoreReturns(result1 error) {
	fake.CertCloseStoreStub = nil
	fake.certCloseStoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CertCloseStoreReturnsOnCall(i int, result1 error) {
	fake.CertCloseStoreStub = nil
	if fake.certCloseStoreReturnsOnCall == nil {
		fake.certCloseStoreReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.certCloseStoreReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CertGetCertificateChain(engine syscall.Handle, leaf *syscall.CertContext, time *syscall.Filetime, additionalStore syscall.Handle, para *syscall.CertChainPara, flags uint32, reserved uintptr, chainCtx **syscall.CertChainContext) (err error) {
	fake.certGetCertificateChainMutex.Lock()
	ret, specificReturn := fake.certGetCertificateChainReturnsOnCall[len(fake.certGetCertificateChainArgsForCall)]
	fake.certGetCertificateChainArgsForCall = append(fake.certGetCertificateChainArgsForCall, struct {
		engine          syscall.Handle
		leaf            *syscall.CertContext
		time            *syscall.Filetime
		additionalStore syscall.Handle
		para            *syscall.CertChainPara
		flags           uint32
		reserved        uintptr
		chainCtx        **syscall.CertChainContext
	}{engine, leaf, time, additionalStore, para, flags, reserved, chainCtx})
	fake.recordInvocation("CertGetCertificateChain", []interface{}{engine, leaf, time, additionalStore, para, flags, reserved, chainCtx})
	fake.certGetCertificateChainMutex.Unlock()
	if fake.CertGetCertificateChainStub != nil {
		return fake.CertGetCertificateChainStub(engine, leaf, time, additionalStore, para, flags, reserved, chainCtx)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.certGetCertificateChainReturns.result1
}

func (fake *FakeSyscall) CertGetCertificateChainCallCount() int {
	fake.certGetCertificateChainMutex.RLock()
	defer fake.certGetCertificateChainMutex.RUnlock()
	return len(fake.certGetCertificateChainArgsForCall)
}

func (fake *FakeSyscall) CertGetCertificateChainArgsForCall(i int) (syscall.Handle, *syscall.CertContext, *syscall.Filetime, syscall.Handle, *syscall.CertChainPara, uint32, uintptr, **syscall.CertChainContext) {
	fake.certGetCertificateChainMutex.RLock()
	defer fake.certGetCertificateChainMutex.RUnlock()
	return fake.certGetCertificateChainArgsForCall[i].engine, fake.certGetCertificateChainArgsForCall[i].leaf, fake.certGetCertificateChainArgsForCall[i].time, fake.certGetCertificateChainArgsForCall[i].additionalStore, fake.certGetCertificateChainArgsForCall[i].para, fake.certGetCertificateChainArgsForCall[i].flags, fake.certGetCertificateChainArgsForCall[i].reserved, fake.certGetCertificateChainArgsForCall[i].chainCtx
}

func (fake *FakeSyscall) CertGetCertificateChainReturns(result1 error) {
	fake.CertGetCertificateChainStub = nil
	fake.certGetCertificateChainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CertGetCertificateChainReturnsOnCall(i int, result1 error) {
	fake.CertGetCertificateChainStub = nil
	if fake.certGetCertificateChainReturnsOnCall == nil {
		fake.certGetCertificateChainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.certGetCertificateChainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CertFreeCertificateChain(ctx *syscall.CertChainContext) {
	fake.certFreeCertificateChainMutex.Lock()
	fake.certFreeCertificateChainArgsForCall = append(fake.certFreeCertificateChainArgsForCall, struct {
		ctx *syscall.CertChainContext
	}{ctx})
	fake.recordInvocation("CertFreeCertificateChain", []interface{}{ctx})
	fake.certFreeCertificateChainMutex.Unlock()
	if fake.CertFreeCertificateChainStub != nil {
		fake.CertFreeCertificateChainStub(ctx)
	}
}

func (fake *FakeSyscall) CertFreeCertificateChainCallCount() int {
	fake.certFreeCertificateChainMutex.RLock()
	defer fake.certFreeCertificateChainMutex.RUnlock()
	return len(fake.certFreeCertificateChainArgsForCall)
}

func (fake *FakeSyscall) CertFreeCertificateChainArgsForCall(i int) *syscall.CertChainContext {
	fake.certFreeCertificateChainMutex.RLock()
	defer fake.certFreeCertificateChainMutex.RUnlock()
	return fake.certFreeCertificateChainArgsForCall[i].ctx
}

func (fake *FakeSyscall) CertCreateCertificateContext(certEncodingType uint32, certEncoded *byte, encodedLen uint32) (context *syscall.CertContext, err error) {
	fake.certCreateCertificateContextMutex.Lock()
	ret, specificReturn := fake.certCreateCertificateContextReturnsOnCall[len(fake.certCreateCertificateContextArgsForCall)]
	fake.certCreateCertificateContextArgsForCall = append(fake.certCreateCertificateContextArgsForCall, struct {
		certEncodingType uint32
		certEncoded      *byte
		encodedLen       uint32
	}{certEncodingType, certEncoded, encodedLen})
	fake.recordInvocation("CertCreateCertificateContext", []interface{}{certEncodingType, certEncoded, encodedLen})
	fake.certCreateCertificateContextMutex.Unlock()
	if fake.CertCreateCertificateContextStub != nil {
		return fake.CertCreateCertificateContextStub(certEncodingType, certEncoded, encodedLen)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.certCreateCertificateContextReturns.result1, fake.certCreateCertificateContextReturns.result2
}

func (fake *FakeSyscall) CertCreateCertificateContextCallCount() int {
	fake.certCreateCertificateContextMutex.RLock()
	defer fake.certCreateCertificateContextMutex.RUnlock()
	return len(fake.certCreateCertificateContextArgsForCall)
}

func (fake *FakeSyscall) CertCreateCertificateContextArgsForCall(i int) (uint32, *byte, uint32) {
	fake.certCreateCertificateContextMutex.RLock()
	defer fake.certCreateCertificateContextMutex.RUnlock()
	return fake.certCreateCertificateContextArgsForCall[i].certEncodingType, fake.certCreateCertificateContextArgsForCall[i].certEncoded, fake.certCreateCertificateContextArgsForCall[i].encodedLen
}

func (fake *FakeSyscall) CertCreateCertificateContextReturns(result1 *syscall.CertContext, result2 error) {
	fake.CertCreateCertificateContextStub = nil
	fake.certCreateCertificateContextReturns = struct {
		result1 *syscall.CertContext
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CertCreateCertificateContextReturnsOnCall(i int, result1 *syscall.CertContext, result2 error) {
	fake.CertCreateCertificateContextStub = nil
	if fake.certCreateCertificateContextReturnsOnCall == nil {
		fake.certCreateCertificateContextReturnsOnCall = make(map[int]struct {
			result1 *syscall.CertContext
			result2 error
		})
	}
	fake.certCreateCertificateContextReturnsOnCall[i] = struct {
		result1 *syscall.CertContext
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CertFreeCertificateContext(ctx *syscall.CertContext) (err error) {
	fake.certFreeCertificateContextMutex.Lock()
	ret, specificReturn := fake.certFreeCertificateContextReturnsOnCall[len(fake.certFreeCertificateContextArgsForCall)]
	fake.certFreeCertificateContextArgsForCall = append(fake.certFreeCertificateContextArgsForCall, struct {
		ctx *syscall.CertContext
	}{ctx})
	fake.recordInvocation("CertFreeCertificateContext", []interface{}{ctx})
	fake.certFreeCertificateContextMutex.Unlock()
	if fake.CertFreeCertificateContextStub != nil {
		return fake.CertFreeCertificateContextStub(ctx)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.certFreeCertificateContextReturns.result1
}

func (fake *FakeSyscall) CertFreeCertificateContextCallCount() int {
	fake.certFreeCertificateContextMutex.RLock()
	defer fake.certFreeCertificateContextMutex.RUnlock()
	return len(fake.certFreeCertificateContextArgsForCall)
}

func (fake *FakeSyscall) CertFreeCertificateContextArgsForCall(i int) *syscall.CertContext {
	fake.certFreeCertificateContextMutex.RLock()
	defer fake.certFreeCertificateContextMutex.RUnlock()
	return fake.certFreeCertificateContextArgsForCall[i].ctx
}

func (fake *FakeSyscall) CertFreeCertificateContextReturns(result1 error) {
	fake.CertFreeCertificateContextStub = nil
	fake.certFreeCertificateContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CertFreeCertificateContextReturnsOnCall(i int, result1 error) {
	fake.CertFreeCertificateContextStub = nil
	if fake.certFreeCertificateContextReturnsOnCall == nil {
		fake.certFreeCertificateContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.certFreeCertificateContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CertVerifyCertificateChainPolicy(policyOID uintptr, chain *syscall.CertChainContext, para *syscall.CertChainPolicyPara, status *syscall.CertChainPolicyStatus) (err error) {
	fake.certVerifyCertificateChainPolicyMutex.Lock()
	ret, specificReturn := fake.certVerifyCertificateChainPolicyReturnsOnCall[len(fake.certVerifyCertificateChainPolicyArgsForCall)]
	fake.certVerifyCertificateChainPolicyArgsForCall = append(fake.certVerifyCertificateChainPolicyArgsForCall, struct {
		policyOID uintptr
		chain     *syscall.CertChainContext
		para      *syscall.CertChainPolicyPara
		status    *syscall.CertChainPolicyStatus
	}{policyOID, chain, para, status})
	fake.recordInvocation("CertVerifyCertificateChainPolicy", []interface{}{policyOID, chain, para, status})
	fake.certVerifyCertificateChainPolicyMutex.Unlock()
	if fake.CertVerifyCertificateChainPolicyStub != nil {
		return fake.CertVerifyCertificateChainPolicyStub(policyOID, chain, para, status)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.certVerifyCertificateChainPolicyReturns.result1
}

func (fake *FakeSyscall) CertVerifyCertificateChainPolicyCallCount() int {
	fake.certVerifyCertificateChainPolicyMutex.RLock()
	defer fake.certVerifyCertificateChainPolicyMutex.RUnlock()
	return len(fake.certVerifyCertificateChainPolicyArgsForCall)
}

func (fake *FakeSyscall) CertVerifyCertificateChainPolicyArgsForCall(i int) (uintptr, *syscall.CertChainContext, *syscall.CertChainPolicyPara, *syscall.CertChainPolicyStatus) {
	fake.certVerifyCertificateChainPolicyMutex.RLock()
	defer fake.certVerifyCertificateChainPolicyMutex.RUnlock()
	return fake.certVerifyCertificateChainPolicyArgsForCall[i].policyOID, fake.certVerifyCertificateChainPolicyArgsForCall[i].chain, fake.certVerifyCertificateChainPolicyArgsForCall[i].para, fake.certVerifyCertificateChainPolicyArgsForCall[i].status
}

func (fake *FakeSyscall) CertVerifyCertificateChainPolicyReturns(result1 error) {
	fake.CertVerifyCertificateChainPolicyStub = nil
	fake.certVerifyCertificateChainPolicyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CertVerifyCertificateChainPolicyReturnsOnCall(i int, result1 error) {
	fake.CertVerifyCertificateChainPolicyStub = nil
	if fake.certVerifyCertificateChainPolicyReturnsOnCall == nil {
		fake.certVerifyCertificateChainPolicyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.certVerifyCertificateChainPolicyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RegOpenKeyEx(key syscall.Handle, subkey *uint16, options uint32, desiredAccess uint32, result *syscall.Handle) (regerrno error) {
	fake.regOpenKeyExMutex.Lock()
	ret, specificReturn := fake.regOpenKeyExReturnsOnCall[len(fake.regOpenKeyExArgsForCall)]
	fake.regOpenKeyExArgsForCall = append(fake.regOpenKeyExArgsForCall, struct {
		key           syscall.Handle
		subkey        *uint16
		options       uint32
		desiredAccess uint32
		result        *syscall.Handle
	}{key, subkey, options, desiredAccess, result})
	fake.recordInvocation("RegOpenKeyEx", []interface{}{key, subkey, options, desiredAccess, result})
	fake.regOpenKeyExMutex.Unlock()
	if fake.RegOpenKeyExStub != nil {
		return fake.RegOpenKeyExStub(key, subkey, options, desiredAccess, result)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.regOpenKeyExReturns.result1
}

func (fake *FakeSyscall) RegOpenKeyExCallCount() int {
	fake.regOpenKeyExMutex.RLock()
	defer fake.regOpenKeyExMutex.RUnlock()
	return len(fake.regOpenKeyExArgsForCall)
}

func (fake *FakeSyscall) RegOpenKeyExArgsForCall(i int) (syscall.Handle, *uint16, uint32, uint32, *syscall.Handle) {
	fake.regOpenKeyExMutex.RLock()
	defer fake.regOpenKeyExMutex.RUnlock()
	return fake.regOpenKeyExArgsForCall[i].key, fake.regOpenKeyExArgsForCall[i].subkey, fake.regOpenKeyExArgsForCall[i].options, fake.regOpenKeyExArgsForCall[i].desiredAccess, fake.regOpenKeyExArgsForCall[i].result
}

func (fake *FakeSyscall) RegOpenKeyExReturns(result1 error) {
	fake.RegOpenKeyExStub = nil
	fake.regOpenKeyExReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RegOpenKeyExReturnsOnCall(i int, result1 error) {
	fake.RegOpenKeyExStub = nil
	if fake.regOpenKeyExReturnsOnCall == nil {
		fake.regOpenKeyExReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.regOpenKeyExReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RegCloseKey(key syscall.Handle) (regerrno error) {
	fake.regCloseKeyMutex.Lock()
	ret, specificReturn := fake.regCloseKeyReturnsOnCall[len(fake.regCloseKeyArgsForCall)]
	fake.regCloseKeyArgsForCall = append(fake.regCloseKeyArgsForCall, struct {
		key syscall.Handle
	}{key})
	fake.recordInvocation("RegCloseKey", []interface{}{key})
	fake.regCloseKeyMutex.Unlock()
	if fake.RegCloseKeyStub != nil {
		return fake.RegCloseKeyStub(key)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.regCloseKeyReturns.result1
}

func (fake *FakeSyscall) RegCloseKeyCallCount() int {
	fake.regCloseKeyMutex.RLock()
	defer fake.regCloseKeyMutex.RUnlock()
	return len(fake.regCloseKeyArgsForCall)
}

func (fake *FakeSyscall) RegCloseKeyArgsForCall(i int) syscall.Handle {
	fake.regCloseKeyMutex.RLock()
	defer fake.regCloseKeyMutex.RUnlock()
	return fake.regCloseKeyArgsForCall[i].key
}

func (fake *FakeSyscall) RegCloseKeyReturns(result1 error) {
	fake.RegCloseKeyStub = nil
	fake.regCloseKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RegCloseKeyReturnsOnCall(i int, result1 error) {
	fake.RegCloseKeyStub = nil
	if fake.regCloseKeyReturnsOnCall == nil {
		fake.regCloseKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.regCloseKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RegQueryInfoKey(key syscall.Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *syscall.Filetime) (regerrno error) {
	fake.regQueryInfoKeyMutex.Lock()
	ret, specificReturn := fake.regQueryInfoKeyReturnsOnCall[len(fake.regQueryInfoKeyArgsForCall)]
	fake.regQueryInfoKeyArgsForCall = append(fake.regQueryInfoKeyArgsForCall, struct {
		key             syscall.Handle
		class           *uint16
		classLen        *uint32
		reserved        *uint32
		subkeysLen      *uint32
		maxSubkeyLen    *uint32
		maxClassLen     *uint32
		valuesLen       *uint32
		maxValueNameLen *uint32
		maxValueLen     *uint32
		saLen           *uint32
		lastWriteTime   *syscall.Filetime
	}{key, class, classLen, reserved, subkeysLen, maxSubkeyLen, maxClassLen, valuesLen, maxValueNameLen, maxValueLen, saLen, lastWriteTime})
	fake.recordInvocation("RegQueryInfoKey", []interface{}{key, class, classLen, reserved, subkeysLen, maxSubkeyLen, maxClassLen, valuesLen, maxValueNameLen, maxValueLen, saLen, lastWriteTime})
	fake.regQueryInfoKeyMutex.Unlock()
	if fake.RegQueryInfoKeyStub != nil {
		return fake.RegQueryInfoKeyStub(key, class, classLen, reserved, subkeysLen, maxSubkeyLen, maxClassLen, valuesLen, maxValueNameLen, maxValueLen, saLen, lastWriteTime)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.regQueryInfoKeyReturns.result1
}

func (fake *FakeSyscall) RegQueryInfoKeyCallCount() int {
	fake.regQueryInfoKeyMutex.RLock()
	defer fake.regQueryInfoKeyMutex.RUnlock()
	return len(fake.regQueryInfoKeyArgsForCall)
}

func (fake *FakeSyscall) RegQueryInfoKeyArgsForCall(i int) (syscall.Handle, *uint16, *uint32, *uint32, *uint32, *uint32, *uint32, *uint32, *uint32, *uint32, *uint32, *syscall.Filetime) {
	fake.regQueryInfoKeyMutex.RLock()
	defer fake.regQueryInfoKeyMutex.RUnlock()
	return fake.regQueryInfoKeyArgsForCall[i].key, fake.regQueryInfoKeyArgsForCall[i].class, fake.regQueryInfoKeyArgsForCall[i].classLen, fake.regQueryInfoKeyArgsForCall[i].reserved, fake.regQueryInfoKeyArgsForCall[i].subkeysLen, fake.regQueryInfoKeyArgsForCall[i].maxSubkeyLen, fake.regQueryInfoKeyArgsForCall[i].maxClassLen, fake.regQueryInfoKeyArgsForCall[i].valuesLen, fake.regQueryInfoKeyArgsForCall[i].maxValueNameLen, fake.regQueryInfoKeyArgsForCall[i].maxValueLen, fake.regQueryInfoKeyArgsForCall[i].saLen, fake.regQueryInfoKeyArgsForCall[i].lastWriteTime
}

func (fake *FakeSyscall) RegQueryInfoKeyReturns(result1 error) {
	fake.RegQueryInfoKeyStub = nil
	fake.regQueryInfoKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RegQueryInfoKeyReturnsOnCall(i int, result1 error) {
	fake.RegQueryInfoKeyStub = nil
	if fake.regQueryInfoKeyReturnsOnCall == nil {
		fake.regQueryInfoKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.regQueryInfoKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RegEnumKeyEx(key syscall.Handle, index uint32, name *uint16, nameLen *uint32, reserved *uint32, class *uint16, classLen *uint32, lastWriteTime *syscall.Filetime) (regerrno error) {
	fake.regEnumKeyExMutex.Lock()
	ret, specificReturn := fake.regEnumKeyExReturnsOnCall[len(fake.regEnumKeyExArgsForCall)]
	fake.regEnumKeyExArgsForCall = append(fake.regEnumKeyExArgsForCall, struct {
		key           syscall.Handle
		index         uint32
		name          *uint16
		nameLen       *uint32
		reserved      *uint32
		class         *uint16
		classLen      *uint32
		lastWriteTime *syscall.Filetime
	}{key, index, name, nameLen, reserved, class, classLen, lastWriteTime})
	fake.recordInvocation("RegEnumKeyEx", []interface{}{key, index, name, nameLen, reserved, class, classLen, lastWriteTime})
	fake.regEnumKeyExMutex.Unlock()
	if fake.RegEnumKeyExStub != nil {
		return fake.RegEnumKeyExStub(key, index, name, nameLen, reserved, class, classLen, lastWriteTime)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.regEnumKeyExReturns.result1
}

func (fake *FakeSyscall) RegEnumKeyExCallCount() int {
	fake.regEnumKeyExMutex.RLock()
	defer fake.regEnumKeyExMutex.RUnlock()
	return len(fake.regEnumKeyExArgsForCall)
}

func (fake *FakeSyscall) RegEnumKeyExArgsForCall(i int) (syscall.Handle, uint32, *uint16, *uint32, *uint32, *uint16, *uint32, *syscall.Filetime) {
	fake.regEnumKeyExMutex.RLock()
	defer fake.regEnumKeyExMutex.RUnlock()
	return fake.regEnumKeyExArgsForCall[i].key, fake.regEnumKeyExArgsForCall[i].index, fake.regEnumKeyExArgsForCall[i].name, fake.regEnumKeyExArgsForCall[i].nameLen, fake.regEnumKeyExArgsForCall[i].reserved, fake.regEnumKeyExArgsForCall[i].class, fake.regEnumKeyExArgsForCall[i].classLen, fake.regEnumKeyExArgsForCall[i].lastWriteTime
}

func (fake *FakeSyscall) RegEnumKeyExReturns(result1 error) {
	fake.RegEnumKeyExStub = nil
	fake.regEnumKeyExReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RegEnumKeyExReturnsOnCall(i int, result1 error) {
	fake.RegEnumKeyExStub = nil
	if fake.regEnumKeyExReturnsOnCall == nil {
		fake.regEnumKeyExReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.regEnumKeyExReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RegQueryValueEx(key syscall.Handle, name *uint16, reserved *uint32, valtype *uint32, buf *byte, buflen *uint32) (regerrno error) {
	fake.regQueryValueExMutex.Lock()
	ret, specificReturn := fake.regQueryValueExReturnsOnCall[len(fake.regQueryValueExArgsForCall)]
	fake.regQueryValueExArgsForCall = append(fake.regQueryValueExArgsForCall, struct {
		key      syscall.Handle
		name     *uint16
		reserved *uint32
		valtype  *uint32
		buf      *byte
		buflen   *uint32
	}{key, name, reserved, valtype, buf, buflen})
	fake.recordInvocation("RegQueryValueEx", []interface{}{key, name, reserved, valtype, buf, buflen})
	fake.regQueryValueExMutex.Unlock()
	if fake.RegQueryValueExStub != nil {
		return fake.RegQueryValueExStub(key, name, reserved, valtype, buf, buflen)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.regQueryValueExReturns.result1
}

func (fake *FakeSyscall) RegQueryValueExCallCount() int {
	fake.regQueryValueExMutex.RLock()
	defer fake.regQueryValueExMutex.RUnlock()
	return len(fake.regQueryValueExArgsForCall)
}

func (fake *FakeSyscall) RegQueryValueExArgsForCall(i int) (syscall.Handle, *uint16, *uint32, *uint32, *byte, *uint32) {
	fake.regQueryValueExMutex.RLock()
	defer fake.regQueryValueExMutex.RUnlock()
	return fake.regQueryValueExArgsForCall[i].key, fake.regQueryValueExArgsForCall[i].name, fake.regQueryValueExArgsForCall[i].reserved, fake.regQueryValueExArgsForCall[i].valtype, fake.regQueryValueExArgsForCall[i].buf, fake.regQueryValueExArgsForCall[i].buflen
}

func (fake *FakeSyscall) RegQueryValueExReturns(result1 error) {
	fake.RegQueryValueExStub = nil
	fake.regQueryValueExReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) RegQueryValueExReturnsOnCall(i int, result1 error) {
	fake.RegQueryValueExStub = nil
	if fake.regQueryValueExReturnsOnCall == nil {
		fake.regQueryValueExReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.regQueryValueExReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetConsoleMode(console syscall.Handle, mode *uint32) (err error) {
	fake.getConsoleModeMutex.Lock()
	ret, specificReturn := fake.getConsoleModeReturnsOnCall[len(fake.getConsoleModeArgsForCall)]
	fake.getConsoleModeArgsForCall = append(fake.getConsoleModeArgsForCall, struct {
		console syscall.Handle
		mode    *uint32
	}{console, mode})
	fake.recordInvocation("GetConsoleMode", []interface{}{console, mode})
	fake.getConsoleModeMutex.Unlock()
	if fake.GetConsoleModeStub != nil {
		return fake.GetConsoleModeStub(console, mode)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getConsoleModeReturns.result1
}

func (fake *FakeSyscall) GetConsoleModeCallCount() int {
	fake.getConsoleModeMutex.RLock()
	defer fake.getConsoleModeMutex.RUnlock()
	return len(fake.getConsoleModeArgsForCall)
}

func (fake *FakeSyscall) GetConsoleModeArgsForCall(i int) (syscall.Handle, *uint32) {
	fake.getConsoleModeMutex.RLock()
	defer fake.getConsoleModeMutex.RUnlock()
	return fake.getConsoleModeArgsForCall[i].console, fake.getConsoleModeArgsForCall[i].mode
}

func (fake *FakeSyscall) GetConsoleModeReturns(result1 error) {
	fake.GetConsoleModeStub = nil
	fake.getConsoleModeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetConsoleModeReturnsOnCall(i int, result1 error) {
	fake.GetConsoleModeStub = nil
	if fake.getConsoleModeReturnsOnCall == nil {
		fake.getConsoleModeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getConsoleModeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WriteConsole(console syscall.Handle, buf *uint16, towrite uint32, written *uint32, reserved *byte) (err error) {
	fake.writeConsoleMutex.Lock()
	ret, specificReturn := fake.writeConsoleReturnsOnCall[len(fake.writeConsoleArgsForCall)]
	fake.writeConsoleArgsForCall = append(fake.writeConsoleArgsForCall, struct {
		console  syscall.Handle
		buf      *uint16
		towrite  uint32
		written  *uint32
		reserved *byte
	}{console, buf, towrite, written, reserved})
	fake.recordInvocation("WriteConsole", []interface{}{console, buf, towrite, written, reserved})
	fake.writeConsoleMutex.Unlock()
	if fake.WriteConsoleStub != nil {
		return fake.WriteConsoleStub(console, buf, towrite, written, reserved)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.writeConsoleReturns.result1
}

func (fake *FakeSyscall) WriteConsoleCallCount() int {
	fake.writeConsoleMutex.RLock()
	defer fake.writeConsoleMutex.RUnlock()
	return len(fake.writeConsoleArgsForCall)
}

func (fake *FakeSyscall) WriteConsoleArgsForCall(i int) (syscall.Handle, *uint16, uint32, *uint32, *byte) {
	fake.writeConsoleMutex.RLock()
	defer fake.writeConsoleMutex.RUnlock()
	return fake.writeConsoleArgsForCall[i].console, fake.writeConsoleArgsForCall[i].buf, fake.writeConsoleArgsForCall[i].towrite, fake.writeConsoleArgsForCall[i].written, fake.writeConsoleArgsForCall[i].reserved
}

func (fake *FakeSyscall) WriteConsoleReturns(result1 error) {
	fake.WriteConsoleStub = nil
	fake.writeConsoleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WriteConsoleReturnsOnCall(i int, result1 error) {
	fake.WriteConsoleStub = nil
	if fake.writeConsoleReturnsOnCall == nil {
		fake.writeConsoleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeConsoleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ReadConsole(console syscall.Handle, buf *uint16, toread uint32, read *uint32, inputControl *byte) (err error) {
	fake.readConsoleMutex.Lock()
	ret, specificReturn := fake.readConsoleReturnsOnCall[len(fake.readConsoleArgsForCall)]
	fake.readConsoleArgsForCall = append(fake.readConsoleArgsForCall, struct {
		console      syscall.Handle
		buf          *uint16
		toread       uint32
		read         *uint32
		inputControl *byte
	}{console, buf, toread, read, inputControl})
	fake.recordInvocation("ReadConsole", []interface{}{console, buf, toread, read, inputControl})
	fake.readConsoleMutex.Unlock()
	if fake.ReadConsoleStub != nil {
		return fake.ReadConsoleStub(console, buf, toread, read, inputControl)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.readConsoleReturns.result1
}

func (fake *FakeSyscall) ReadConsoleCallCount() int {
	fake.readConsoleMutex.RLock()
	defer fake.readConsoleMutex.RUnlock()
	return len(fake.readConsoleArgsForCall)
}

func (fake *FakeSyscall) ReadConsoleArgsForCall(i int) (syscall.Handle, *uint16, uint32, *uint32, *byte) {
	fake.readConsoleMutex.RLock()
	defer fake.readConsoleMutex.RUnlock()
	return fake.readConsoleArgsForCall[i].console, fake.readConsoleArgsForCall[i].buf, fake.readConsoleArgsForCall[i].toread, fake.readConsoleArgsForCall[i].read, fake.readConsoleArgsForCall[i].inputControl
}

func (fake *FakeSyscall) ReadConsoleReturns(result1 error) {
	fake.ReadConsoleStub = nil
	fake.readConsoleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ReadConsoleReturnsOnCall(i int, result1 error) {
	fake.ReadConsoleStub = nil
	if fake.readConsoleReturnsOnCall == nil {
		fake.readConsoleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.readConsoleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle syscall.Handle, err error) {
	fake.createToolhelp32SnapshotMutex.Lock()
	ret, specificReturn := fake.createToolhelp32SnapshotReturnsOnCall[len(fake.createToolhelp32SnapshotArgsForCall)]
	fake.createToolhelp32SnapshotArgsForCall = append(fake.createToolhelp32SnapshotArgsForCall, struct {
		flags     uint32
		processId uint32
	}{flags, processId})
	fake.recordInvocation("CreateToolhelp32Snapshot", []interface{}{flags, processId})
	fake.createToolhelp32SnapshotMutex.Unlock()
	if fake.CreateToolhelp32SnapshotStub != nil {
		return fake.CreateToolhelp32SnapshotStub(flags, processId)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createToolhelp32SnapshotReturns.result1, fake.createToolhelp32SnapshotReturns.result2
}

func (fake *FakeSyscall) CreateToolhelp32SnapshotCallCount() int {
	fake.createToolhelp32SnapshotMutex.RLock()
	defer fake.createToolhelp32SnapshotMutex.RUnlock()
	return len(fake.createToolhelp32SnapshotArgsForCall)
}

func (fake *FakeSyscall) CreateToolhelp32SnapshotArgsForCall(i int) (uint32, uint32) {
	fake.createToolhelp32SnapshotMutex.RLock()
	defer fake.createToolhelp32SnapshotMutex.RUnlock()
	return fake.createToolhelp32SnapshotArgsForCall[i].flags, fake.createToolhelp32SnapshotArgsForCall[i].processId
}

func (fake *FakeSyscall) CreateToolhelp32SnapshotReturns(result1 syscall.Handle, result2 error) {
	fake.CreateToolhelp32SnapshotStub = nil
	fake.createToolhelp32SnapshotReturns = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) CreateToolhelp32SnapshotReturnsOnCall(i int, result1 syscall.Handle, result2 error) {
	fake.CreateToolhelp32SnapshotStub = nil
	if fake.createToolhelp32SnapshotReturnsOnCall == nil {
		fake.createToolhelp32SnapshotReturnsOnCall = make(map[int]struct {
			result1 syscall.Handle
			result2 error
		})
	}
	fake.createToolhelp32SnapshotReturnsOnCall[i] = struct {
		result1 syscall.Handle
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Process32First(snapshot syscall.Handle, procEntry *syscall.ProcessEntry32) (err error) {
	fake.process32FirstMutex.Lock()
	ret, specificReturn := fake.process32FirstReturnsOnCall[len(fake.process32FirstArgsForCall)]
	fake.process32FirstArgsForCall = append(fake.process32FirstArgsForCall, struct {
		snapshot  syscall.Handle
		procEntry *syscall.ProcessEntry32
	}{snapshot, procEntry})
	fake.recordInvocation("Process32First", []interface{}{snapshot, procEntry})
	fake.process32FirstMutex.Unlock()
	if fake.Process32FirstStub != nil {
		return fake.Process32FirstStub(snapshot, procEntry)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.process32FirstReturns.result1
}

func (fake *FakeSyscall) Process32FirstCallCount() int {
	fake.process32FirstMutex.RLock()
	defer fake.process32FirstMutex.RUnlock()
	return len(fake.process32FirstArgsForCall)
}

func (fake *FakeSyscall) Process32FirstArgsForCall(i int) (syscall.Handle, *syscall.ProcessEntry32) {
	fake.process32FirstMutex.RLock()
	defer fake.process32FirstMutex.RUnlock()
	return fake.process32FirstArgsForCall[i].snapshot, fake.process32FirstArgsForCall[i].procEntry
}

func (fake *FakeSyscall) Process32FirstReturns(result1 error) {
	fake.Process32FirstStub = nil
	fake.process32FirstReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Process32FirstReturnsOnCall(i int, result1 error) {
	fake.Process32FirstStub = nil
	if fake.process32FirstReturnsOnCall == nil {
		fake.process32FirstReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.process32FirstReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Process32Next(snapshot syscall.Handle, procEntry *syscall.ProcessEntry32) (err error) {
	fake.process32NextMutex.Lock()
	ret, specificReturn := fake.process32NextReturnsOnCall[len(fake.process32NextArgsForCall)]
	fake.process32NextArgsForCall = append(fake.process32NextArgsForCall, struct {
		snapshot  syscall.Handle
		procEntry *syscall.ProcessEntry32
	}{snapshot, procEntry})
	fake.recordInvocation("Process32Next", []interface{}{snapshot, procEntry})
	fake.process32NextMutex.Unlock()
	if fake.Process32NextStub != nil {
		return fake.Process32NextStub(snapshot, procEntry)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.process32NextReturns.result1
}

func (fake *FakeSyscall) Process32NextCallCount() int {
	fake.process32NextMutex.RLock()
	defer fake.process32NextMutex.RUnlock()
	return len(fake.process32NextArgsForCall)
}

func (fake *FakeSyscall) Process32NextArgsForCall(i int) (syscall.Handle, *syscall.ProcessEntry32) {
	fake.process32NextMutex.RLock()
	defer fake.process32NextMutex.RUnlock()
	return fake.process32NextArgsForCall[i].snapshot, fake.process32NextArgsForCall[i].procEntry
}

func (fake *FakeSyscall) Process32NextReturns(result1 error) {
	fake.Process32NextStub = nil
	fake.process32NextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Process32NextReturnsOnCall(i int, result1 error) {
	fake.Process32NextStub = nil
	if fake.process32NextReturnsOnCall == nil {
		fake.process32NextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.process32NextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) DeviceIoControl(handle syscall.Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *syscall.Overlapped) (err error) {
	fake.deviceIoControlMutex.Lock()
	ret, specificReturn := fake.deviceIoControlReturnsOnCall[len(fake.deviceIoControlArgsForCall)]
	fake.deviceIoControlArgsForCall = append(fake.deviceIoControlArgsForCall, struct {
		handle        syscall.Handle
		ioControlCode uint32
		inBuffer      *byte
		inBufferSize  uint32
		outBuffer     *byte
		outBufferSize uint32
		bytesReturned *uint32
		overlapped    *syscall.Overlapped
	}{handle, ioControlCode, inBuffer, inBufferSize, outBuffer, outBufferSize, bytesReturned, overlapped})
	fake.recordInvocation("DeviceIoControl", []interface{}{handle, ioControlCode, inBuffer, inBufferSize, outBuffer, outBufferSize, bytesReturned, overlapped})
	fake.deviceIoControlMutex.Unlock()
	if fake.DeviceIoControlStub != nil {
		return fake.DeviceIoControlStub(handle, ioControlCode, inBuffer, inBufferSize, outBuffer, outBufferSize, bytesReturned, overlapped)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deviceIoControlReturns.result1
}

func (fake *FakeSyscall) DeviceIoControlCallCount() int {
	fake.deviceIoControlMutex.RLock()
	defer fake.deviceIoControlMutex.RUnlock()
	return len(fake.deviceIoControlArgsForCall)
}

func (fake *FakeSyscall) DeviceIoControlArgsForCall(i int) (syscall.Handle, uint32, *byte, uint32, *byte, uint32, *uint32, *syscall.Overlapped) {
	fake.deviceIoControlMutex.RLock()
	defer fake.deviceIoControlMutex.RUnlock()
	return fake.deviceIoControlArgsForCall[i].handle, fake.deviceIoControlArgsForCall[i].ioControlCode, fake.deviceIoControlArgsForCall[i].inBuffer, fake.deviceIoControlArgsForCall[i].inBufferSize, fake.deviceIoControlArgsForCall[i].outBuffer, fake.deviceIoControlArgsForCall[i].outBufferSize, fake.deviceIoControlArgsForCall[i].bytesReturned, fake.deviceIoControlArgsForCall[i].overlapped
}

func (fake *FakeSyscall) DeviceIoControlReturns(result1 error) {
	fake.DeviceIoControlStub = nil
	fake.deviceIoControlReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) DeviceIoControlReturnsOnCall(i int, result1 error) {
	fake.DeviceIoControlStub = nil
	if fake.deviceIoControlReturnsOnCall == nil {
		fake.deviceIoControlReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deviceIoControlReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) {
	fake.createSymbolicLinkMutex.Lock()
	ret, specificReturn := fake.createSymbolicLinkReturnsOnCall[len(fake.createSymbolicLinkArgsForCall)]
	fake.createSymbolicLinkArgsForCall = append(fake.createSymbolicLinkArgsForCall, struct {
		symlinkfilename *uint16
		targetfilename  *uint16
		flags           uint32
	}{symlinkfilename, targetfilename, flags})
	fake.recordInvocation("CreateSymbolicLink", []interface{}{symlinkfilename, targetfilename, flags})
	fake.createSymbolicLinkMutex.Unlock()
	if fake.CreateSymbolicLinkStub != nil {
		return fake.CreateSymbolicLinkStub(symlinkfilename, targetfilename, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createSymbolicLinkReturns.result1
}

func (fake *FakeSyscall) CreateSymbolicLinkCallCount() int {
	fake.createSymbolicLinkMutex.RLock()
	defer fake.createSymbolicLinkMutex.RUnlock()
	return len(fake.createSymbolicLinkArgsForCall)
}

func (fake *FakeSyscall) CreateSymbolicLinkArgsForCall(i int) (*uint16, *uint16, uint32) {
	fake.createSymbolicLinkMutex.RLock()
	defer fake.createSymbolicLinkMutex.RUnlock()
	return fake.createSymbolicLinkArgsForCall[i].symlinkfilename, fake.createSymbolicLinkArgsForCall[i].targetfilename, fake.createSymbolicLinkArgsForCall[i].flags
}

func (fake *FakeSyscall) CreateSymbolicLinkReturns(result1 error) {
	fake.CreateSymbolicLinkStub = nil
	fake.createSymbolicLinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CreateSymbolicLinkReturnsOnCall(i int, result1 error) {
	fake.CreateSymbolicLinkStub = nil
	if fake.createSymbolicLinkReturnsOnCall == nil {
		fake.createSymbolicLinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createSymbolicLinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CreateHardLink(filename *uint16, existingfilename *uint16, reserved uintptr) (err error) {
	fake.createHardLinkMutex.Lock()
	ret, specificReturn := fake.createHardLinkReturnsOnCall[len(fake.createHardLinkArgsForCall)]
	fake.createHardLinkArgsForCall = append(fake.createHardLinkArgsForCall, struct {
		filename         *uint16
		existingfilename *uint16
		reserved         uintptr
	}{filename, existingfilename, reserved})
	fake.recordInvocation("CreateHardLink", []interface{}{filename, existingfilename, reserved})
	fake.createHardLinkMutex.Unlock()
	if fake.CreateHardLinkStub != nil {
		return fake.CreateHardLinkStub(filename, existingfilename, reserved)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createHardLinkReturns.result1
}

func (fake *FakeSyscall) CreateHardLinkCallCount() int {
	fake.createHardLinkMutex.RLock()
	defer fake.createHardLinkMutex.RUnlock()
	return len(fake.createHardLinkArgsForCall)
}

func (fake *FakeSyscall) CreateHardLinkArgsForCall(i int) (*uint16, *uint16, uintptr) {
	fake.createHardLinkMutex.RLock()
	defer fake.createHardLinkMutex.RUnlock()
	return fake.createHardLinkArgsForCall[i].filename, fake.createHardLinkArgsForCall[i].existingfilename, fake.createHardLinkArgsForCall[i].reserved
}

func (fake *FakeSyscall) CreateHardLinkReturns(result1 error) {
	fake.CreateHardLinkStub = nil
	fake.createHardLinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CreateHardLinkReturnsOnCall(i int, result1 error) {
	fake.CreateHardLinkStub = nil
	if fake.createHardLinkReturnsOnCall == nil {
		fake.createHardLinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createHardLinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSAStartup(verreq uint32, data *syscall.WSAData) (sockerr error) {
	fake.wSAStartupMutex.Lock()
	ret, specificReturn := fake.wSAStartupReturnsOnCall[len(fake.wSAStartupArgsForCall)]
	fake.wSAStartupArgsForCall = append(fake.wSAStartupArgsForCall, struct {
		verreq uint32
		data   *syscall.WSAData
	}{verreq, data})
	fake.recordInvocation("WSAStartup", []interface{}{verreq, data})
	fake.wSAStartupMutex.Unlock()
	if fake.WSAStartupStub != nil {
		return fake.WSAStartupStub(verreq, data)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.wSAStartupReturns.result1
}

func (fake *FakeSyscall) WSAStartupCallCount() int {
	fake.wSAStartupMutex.RLock()
	defer fake.wSAStartupMutex.RUnlock()
	return len(fake.wSAStartupArgsForCall)
}

func (fake *FakeSyscall) WSAStartupArgsForCall(i int) (uint32, *syscall.WSAData) {
	fake.wSAStartupMutex.RLock()
	defer fake.wSAStartupMutex.RUnlock()
	return fake.wSAStartupArgsForCall[i].verreq, fake.wSAStartupArgsForCall[i].data
}

func (fake *FakeSyscall) WSAStartupReturns(result1 error) {
	fake.WSAStartupStub = nil
	fake.wSAStartupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSAStartupReturnsOnCall(i int, result1 error) {
	fake.WSAStartupStub = nil
	if fake.wSAStartupReturnsOnCall == nil {
		fake.wSAStartupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.wSAStartupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSACleanup() (err error) {
	fake.wSACleanupMutex.Lock()
	ret, specificReturn := fake.wSACleanupReturnsOnCall[len(fake.wSACleanupArgsForCall)]
	fake.wSACleanupArgsForCall = append(fake.wSACleanupArgsForCall, struct{}{})
	fake.recordInvocation("WSACleanup", []interface{}{})
	fake.wSACleanupMutex.Unlock()
	if fake.WSACleanupStub != nil {
		return fake.WSACleanupStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.wSACleanupReturns.result1
}

func (fake *FakeSyscall) WSACleanupCallCount() int {
	fake.wSACleanupMutex.RLock()
	defer fake.wSACleanupMutex.RUnlock()
	return len(fake.wSACleanupArgsForCall)
}

func (fake *FakeSyscall) WSACleanupReturns(result1 error) {
	fake.WSACleanupStub = nil
	fake.wSACleanupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSACleanupReturnsOnCall(i int, result1 error) {
	fake.WSACleanupStub = nil
	if fake.wSACleanupReturnsOnCall == nil {
		fake.wSACleanupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.wSACleanupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSAIoctl(s syscall.Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *syscall.Overlapped, completionRoutine uintptr) (err error) {
	fake.wSAIoctlMutex.Lock()
	ret, specificReturn := fake.wSAIoctlReturnsOnCall[len(fake.wSAIoctlArgsForCall)]
	fake.wSAIoctlArgsForCall = append(fake.wSAIoctlArgsForCall, struct {
		s                 syscall.Handle
		iocc              uint32
		inbuf             *byte
		cbif              uint32
		outbuf            *byte
		cbob              uint32
		cbbr              *uint32
		overlapped        *syscall.Overlapped
		completionRoutine uintptr
	}{s, iocc, inbuf, cbif, outbuf, cbob, cbbr, overlapped, completionRoutine})
	fake.recordInvocation("WSAIoctl", []interface{}{s, iocc, inbuf, cbif, outbuf, cbob, cbbr, overlapped, completionRoutine})
	fake.wSAIoctlMutex.Unlock()
	if fake.WSAIoctlStub != nil {
		return fake.WSAIoctlStub(s, iocc, inbuf, cbif, outbuf, cbob, cbbr, overlapped, completionRoutine)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.wSAIoctlReturns.result1
}

func (fake *FakeSyscall) WSAIoctlCallCount() int {
	fake.wSAIoctlMutex.RLock()
	defer fake.wSAIoctlMutex.RUnlock()
	return len(fake.wSAIoctlArgsForCall)
}

func (fake *FakeSyscall) WSAIoctlArgsForCall(i int) (syscall.Handle, uint32, *byte, uint32, *byte, uint32, *uint32, *syscall.Overlapped, uintptr) {
	fake.wSAIoctlMutex.RLock()
	defer fake.wSAIoctlMutex.RUnlock()
	return fake.wSAIoctlArgsForCall[i].s, fake.wSAIoctlArgsForCall[i].iocc, fake.wSAIoctlArgsForCall[i].inbuf, fake.wSAIoctlArgsForCall[i].cbif, fake.wSAIoctlArgsForCall[i].outbuf, fake.wSAIoctlArgsForCall[i].cbob, fake.wSAIoctlArgsForCall[i].cbbr, fake.wSAIoctlArgsForCall[i].overlapped, fake.wSAIoctlArgsForCall[i].completionRoutine
}

func (fake *FakeSyscall) WSAIoctlReturns(result1 error) {
	fake.WSAIoctlStub = nil
	fake.wSAIoctlReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSAIoctlReturnsOnCall(i int, result1 error) {
	fake.WSAIoctlStub = nil
	if fake.wSAIoctlReturnsOnCall == nil {
		fake.wSAIoctlReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.wSAIoctlReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Setsockopt(s syscall.Handle, level int32, optname int32, optval *byte, optlen int32) (err error) {
	fake.setsockoptMutex.Lock()
	ret, specificReturn := fake.setsockoptReturnsOnCall[len(fake.setsockoptArgsForCall)]
	fake.setsockoptArgsForCall = append(fake.setsockoptArgsForCall, struct {
		s       syscall.Handle
		level   int32
		optname int32
		optval  *byte
		optlen  int32
	}{s, level, optname, optval, optlen})
	fake.recordInvocation("Setsockopt", []interface{}{s, level, optname, optval, optlen})
	fake.setsockoptMutex.Unlock()
	if fake.SetsockoptStub != nil {
		return fake.SetsockoptStub(s, level, optname, optval, optlen)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setsockoptReturns.result1
}

func (fake *FakeSyscall) SetsockoptCallCount() int {
	fake.setsockoptMutex.RLock()
	defer fake.setsockoptMutex.RUnlock()
	return len(fake.setsockoptArgsForCall)
}

func (fake *FakeSyscall) SetsockoptArgsForCall(i int) (syscall.Handle, int32, int32, *byte, int32) {
	fake.setsockoptMutex.RLock()
	defer fake.setsockoptMutex.RUnlock()
	return fake.setsockoptArgsForCall[i].s, fake.setsockoptArgsForCall[i].level, fake.setsockoptArgsForCall[i].optname, fake.setsockoptArgsForCall[i].optval, fake.setsockoptArgsForCall[i].optlen
}

func (fake *FakeSyscall) SetsockoptReturns(result1 error) {
	fake.SetsockoptStub = nil
	fake.setsockoptReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetsockoptReturnsOnCall(i int, result1 error) {
	fake.SetsockoptStub = nil
	if fake.setsockoptReturnsOnCall == nil {
		fake.setsockoptReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setsockoptReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Getsockopt(s syscall.Handle, level int32, optname int32, optval *byte, optlen *int32) (err error) {
	fake.getsockoptMutex.Lock()
	ret, specificReturn := fake.getsockoptReturnsOnCall[len(fake.getsockoptArgsForCall)]
	fake.getsockoptArgsForCall = append(fake.getsockoptArgsForCall, struct {
		s       syscall.Handle
		level   int32
		optname int32
		optval  *byte
		optlen  *int32
	}{s, level, optname, optval, optlen})
	fake.recordInvocation("Getsockopt", []interface{}{s, level, optname, optval, optlen})
	fake.getsockoptMutex.Unlock()
	if fake.GetsockoptStub != nil {
		return fake.GetsockoptStub(s, level, optname, optval, optlen)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getsockoptReturns.result1
}

func (fake *FakeSyscall) GetsockoptCallCount() int {
	fake.getsockoptMutex.RLock()
	defer fake.getsockoptMutex.RUnlock()
	return len(fake.getsockoptArgsForCall)
}

func (fake *FakeSyscall) GetsockoptArgsForCall(i int) (syscall.Handle, int32, int32, *byte, *int32) {
	fake.getsockoptMutex.RLock()
	defer fake.getsockoptMutex.RUnlock()
	return fake.getsockoptArgsForCall[i].s, fake.getsockoptArgsForCall[i].level, fake.getsockoptArgsForCall[i].optname, fake.getsockoptArgsForCall[i].optval, fake.getsockoptArgsForCall[i].optlen
}

func (fake *FakeSyscall) GetsockoptReturns(result1 error) {
	fake.GetsockoptStub = nil
	fake.getsockoptReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetsockoptReturnsOnCall(i int, result1 error) {
	fake.GetsockoptStub = nil
	if fake.getsockoptReturnsOnCall == nil {
		fake.getsockoptReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getsockoptReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) Closesocket(s syscall.Handle) (err error) {
	fake.closesocketMutex.Lock()
	ret, specificReturn := fake.closesocketReturnsOnCall[len(fake.closesocketArgsForCall)]
	fake.closesocketArgsForCall = append(fake.closesocketArgsForCall, struct {
		s syscall.Handle
	}{s})
	fake.recordInvocation("Closesocket", []interface{}{s})
	fake.closesocketMutex.Unlock()
	if fake.ClosesocketStub != nil {
		return fake.ClosesocketStub(s)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.closesocketReturns.result1
}

func (fake *FakeSyscall) ClosesocketCallCount() int {
	fake.closesocketMutex.RLock()
	defer fake.closesocketMutex.RUnlock()
	return len(fake.closesocketArgsForCall)
}

func (fake *FakeSyscall) ClosesocketArgsForCall(i int) syscall.Handle {
	fake.closesocketMutex.RLock()
	defer fake.closesocketMutex.RUnlock()
	return fake.closesocketArgsForCall[i].s
}

func (fake *FakeSyscall) ClosesocketReturns(result1 error) {
	fake.ClosesocketStub = nil
	fake.closesocketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ClosesocketReturnsOnCall(i int, result1 error) {
	fake.ClosesocketStub = nil
	if fake.closesocketReturnsOnCall == nil {
		fake.closesocketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closesocketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) AcceptEx(ls syscall.Handle, as syscall.Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *syscall.Overlapped) (err error) {
	fake.acceptExMutex.Lock()
	ret, specificReturn := fake.acceptExReturnsOnCall[len(fake.acceptExArgsForCall)]
	fake.acceptExArgsForCall = append(fake.acceptExArgsForCall, struct {
		ls         syscall.Handle
		as         syscall.Handle
		buf        *byte
		rxdatalen  uint32
		laddrlen   uint32
		raddrlen   uint32
		recvd      *uint32
		overlapped *syscall.Overlapped
	}{ls, as, buf, rxdatalen, laddrlen, raddrlen, recvd, overlapped})
	fake.recordInvocation("AcceptEx", []interface{}{ls, as, buf, rxdatalen, laddrlen, raddrlen, recvd, overlapped})
	fake.acceptExMutex.Unlock()
	if fake.AcceptExStub != nil {
		return fake.AcceptExStub(ls, as, buf, rxdatalen, laddrlen, raddrlen, recvd, overlapped)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.acceptExReturns.result1
}

func (fake *FakeSyscall) AcceptExCallCount() int {
	fake.acceptExMutex.RLock()
	defer fake.acceptExMutex.RUnlock()
	return len(fake.acceptExArgsForCall)
}

func (fake *FakeSyscall) AcceptExArgsForCall(i int) (syscall.Handle, syscall.Handle, *byte, uint32, uint32, uint32, *uint32, *syscall.Overlapped) {
	fake.acceptExMutex.RLock()
	defer fake.acceptExMutex.RUnlock()
	return fake.acceptExArgsForCall[i].ls, fake.acceptExArgsForCall[i].as, fake.acceptExArgsForCall[i].buf, fake.acceptExArgsForCall[i].rxdatalen, fake.acceptExArgsForCall[i].laddrlen, fake.acceptExArgsForCall[i].raddrlen, fake.acceptExArgsForCall[i].recvd, fake.acceptExArgsForCall[i].overlapped
}

func (fake *FakeSyscall) AcceptExReturns(result1 error) {
	fake.AcceptExStub = nil
	fake.acceptExReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) AcceptExReturnsOnCall(i int, result1 error) {
	fake.AcceptExStub = nil
	if fake.acceptExReturnsOnCall == nil {
		fake.acceptExReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.acceptExReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **syscall.RawSockaddrAny, lrsalen *int32, rrsa **syscall.RawSockaddrAny, rrsalen *int32) {
	fake.getAcceptExSockaddrsMutex.Lock()
	fake.getAcceptExSockaddrsArgsForCall = append(fake.getAcceptExSockaddrsArgsForCall, struct {
		buf       *byte
		rxdatalen uint32
		laddrlen  uint32
		raddrlen  uint32
		lrsa      **syscall.RawSockaddrAny
		lrsalen   *int32
		rrsa      **syscall.RawSockaddrAny
		rrsalen   *int32
	}{buf, rxdatalen, laddrlen, raddrlen, lrsa, lrsalen, rrsa, rrsalen})
	fake.recordInvocation("GetAcceptExSockaddrs", []interface{}{buf, rxdatalen, laddrlen, raddrlen, lrsa, lrsalen, rrsa, rrsalen})
	fake.getAcceptExSockaddrsMutex.Unlock()
	if fake.GetAcceptExSockaddrsStub != nil {
		fake.GetAcceptExSockaddrsStub(buf, rxdatalen, laddrlen, raddrlen, lrsa, lrsalen, rrsa, rrsalen)
	}
}

func (fake *FakeSyscall) GetAcceptExSockaddrsCallCount() int {
	fake.getAcceptExSockaddrsMutex.RLock()
	defer fake.getAcceptExSockaddrsMutex.RUnlock()
	return len(fake.getAcceptExSockaddrsArgsForCall)
}

func (fake *FakeSyscall) GetAcceptExSockaddrsArgsForCall(i int) (*byte, uint32, uint32, uint32, **syscall.RawSockaddrAny, *int32, **syscall.RawSockaddrAny, *int32) {
	fake.getAcceptExSockaddrsMutex.RLock()
	defer fake.getAcceptExSockaddrsMutex.RUnlock()
	return fake.getAcceptExSockaddrsArgsForCall[i].buf, fake.getAcceptExSockaddrsArgsForCall[i].rxdatalen, fake.getAcceptExSockaddrsArgsForCall[i].laddrlen, fake.getAcceptExSockaddrsArgsForCall[i].raddrlen, fake.getAcceptExSockaddrsArgsForCall[i].lrsa, fake.getAcceptExSockaddrsArgsForCall[i].lrsalen, fake.getAcceptExSockaddrsArgsForCall[i].rrsa, fake.getAcceptExSockaddrsArgsForCall[i].rrsalen
}

func (fake *FakeSyscall) WSARecv(s syscall.Handle, bufs *syscall.WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *syscall.Overlapped, croutine *byte) (err error) {
	fake.wSARecvMutex.Lock()
	ret, specificReturn := fake.wSARecvReturnsOnCall[len(fake.wSARecvArgsForCall)]
	fake.wSARecvArgsForCall = append(fake.wSARecvArgsForCall, struct {
		s          syscall.Handle
		bufs       *syscall.WSABuf
		bufcnt     uint32
		recvd      *uint32
		flags      *uint32
		overlapped *syscall.Overlapped
		croutine   *byte
	}{s, bufs, bufcnt, recvd, flags, overlapped, croutine})
	fake.recordInvocation("WSARecv", []interface{}{s, bufs, bufcnt, recvd, flags, overlapped, croutine})
	fake.wSARecvMutex.Unlock()
	if fake.WSARecvStub != nil {
		return fake.WSARecvStub(s, bufs, bufcnt, recvd, flags, overlapped, croutine)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.wSARecvReturns.result1
}

func (fake *FakeSyscall) WSARecvCallCount() int {
	fake.wSARecvMutex.RLock()
	defer fake.wSARecvMutex.RUnlock()
	return len(fake.wSARecvArgsForCall)
}

func (fake *FakeSyscall) WSARecvArgsForCall(i int) (syscall.Handle, *syscall.WSABuf, uint32, *uint32, *uint32, *syscall.Overlapped, *byte) {
	fake.wSARecvMutex.RLock()
	defer fake.wSARecvMutex.RUnlock()
	return fake.wSARecvArgsForCall[i].s, fake.wSARecvArgsForCall[i].bufs, fake.wSARecvArgsForCall[i].bufcnt, fake.wSARecvArgsForCall[i].recvd, fake.wSARecvArgsForCall[i].flags, fake.wSARecvArgsForCall[i].overlapped, fake.wSARecvArgsForCall[i].croutine
}

func (fake *FakeSyscall) WSARecvReturns(result1 error) {
	fake.WSARecvStub = nil
	fake.wSARecvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSARecvReturnsOnCall(i int, result1 error) {
	fake.WSARecvStub = nil
	if fake.wSARecvReturnsOnCall == nil {
		fake.wSARecvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.wSARecvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSASend(s syscall.Handle, bufs *syscall.WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *syscall.Overlapped, croutine *byte) (err error) {
	fake.wSASendMutex.Lock()
	ret, specificReturn := fake.wSASendReturnsOnCall[len(fake.wSASendArgsForCall)]
	fake.wSASendArgsForCall = append(fake.wSASendArgsForCall, struct {
		s          syscall.Handle
		bufs       *syscall.WSABuf
		bufcnt     uint32
		sent       *uint32
		flags      uint32
		overlapped *syscall.Overlapped
		croutine   *byte
	}{s, bufs, bufcnt, sent, flags, overlapped, croutine})
	fake.recordInvocation("WSASend", []interface{}{s, bufs, bufcnt, sent, flags, overlapped, croutine})
	fake.wSASendMutex.Unlock()
	if fake.WSASendStub != nil {
		return fake.WSASendStub(s, bufs, bufcnt, sent, flags, overlapped, croutine)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.wSASendReturns.result1
}

func (fake *FakeSyscall) WSASendCallCount() int {
	fake.wSASendMutex.RLock()
	defer fake.wSASendMutex.RUnlock()
	return len(fake.wSASendArgsForCall)
}

func (fake *FakeSyscall) WSASendArgsForCall(i int) (syscall.Handle, *syscall.WSABuf, uint32, *uint32, uint32, *syscall.Overlapped, *byte) {
	fake.wSASendMutex.RLock()
	defer fake.wSASendMutex.RUnlock()
	return fake.wSASendArgsForCall[i].s, fake.wSASendArgsForCall[i].bufs, fake.wSASendArgsForCall[i].bufcnt, fake.wSASendArgsForCall[i].sent, fake.wSASendArgsForCall[i].flags, fake.wSASendArgsForCall[i].overlapped, fake.wSASendArgsForCall[i].croutine
}

func (fake *FakeSyscall) WSASendReturns(result1 error) {
	fake.WSASendStub = nil
	fake.wSASendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSASendReturnsOnCall(i int, result1 error) {
	fake.WSASendStub = nil
	if fake.wSASendReturnsOnCall == nil {
		fake.wSASendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.wSASendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSARecvFrom(s syscall.Handle, bufs *syscall.WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, from *syscall.RawSockaddrAny, fromlen *int32, overlapped *syscall.Overlapped, croutine *byte) (err error) {
	fake.wSARecvFromMutex.Lock()
	ret, specificReturn := fake.wSARecvFromReturnsOnCall[len(fake.wSARecvFromArgsForCall)]
	fake.wSARecvFromArgsForCall = append(fake.wSARecvFromArgsForCall, struct {
		s          syscall.Handle
		bufs       *syscall.WSABuf
		bufcnt     uint32
		recvd      *uint32
		flags      *uint32
		from       *syscall.RawSockaddrAny
		fromlen    *int32
		overlapped *syscall.Overlapped
		croutine   *byte
	}{s, bufs, bufcnt, recvd, flags, from, fromlen, overlapped, croutine})
	fake.recordInvocation("WSARecvFrom", []interface{}{s, bufs, bufcnt, recvd, flags, from, fromlen, overlapped, croutine})
	fake.wSARecvFromMutex.Unlock()
	if fake.WSARecvFromStub != nil {
		return fake.WSARecvFromStub(s, bufs, bufcnt, recvd, flags, from, fromlen, overlapped, croutine)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.wSARecvFromReturns.result1
}

func (fake *FakeSyscall) WSARecvFromCallCount() int {
	fake.wSARecvFromMutex.RLock()
	defer fake.wSARecvFromMutex.RUnlock()
	return len(fake.wSARecvFromArgsForCall)
}

func (fake *FakeSyscall) WSARecvFromArgsForCall(i int) (syscall.Handle, *syscall.WSABuf, uint32, *uint32, *uint32, *syscall.RawSockaddrAny, *int32, *syscall.Overlapped, *byte) {
	fake.wSARecvFromMutex.RLock()
	defer fake.wSARecvFromMutex.RUnlock()
	return fake.wSARecvFromArgsForCall[i].s, fake.wSARecvFromArgsForCall[i].bufs, fake.wSARecvFromArgsForCall[i].bufcnt, fake.wSARecvFromArgsForCall[i].recvd, fake.wSARecvFromArgsForCall[i].flags, fake.wSARecvFromArgsForCall[i].from, fake.wSARecvFromArgsForCall[i].fromlen, fake.wSARecvFromArgsForCall[i].overlapped, fake.wSARecvFromArgsForCall[i].croutine
}

func (fake *FakeSyscall) WSARecvFromReturns(result1 error) {
	fake.WSARecvFromStub = nil
	fake.wSARecvFromReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSARecvFromReturnsOnCall(i int, result1 error) {
	fake.WSARecvFromStub = nil
	if fake.wSARecvFromReturnsOnCall == nil {
		fake.wSARecvFromReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.wSARecvFromReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSASendTo(s syscall.Handle, bufs *syscall.WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *syscall.RawSockaddrAny, tolen int32, overlapped *syscall.Overlapped, croutine *byte) (err error) {
	fake.wSASendToMutex.Lock()
	ret, specificReturn := fake.wSASendToReturnsOnCall[len(fake.wSASendToArgsForCall)]
	fake.wSASendToArgsForCall = append(fake.wSASendToArgsForCall, struct {
		s          syscall.Handle
		bufs       *syscall.WSABuf
		bufcnt     uint32
		sent       *uint32
		flags      uint32
		to         *syscall.RawSockaddrAny
		tolen      int32
		overlapped *syscall.Overlapped
		croutine   *byte
	}{s, bufs, bufcnt, sent, flags, to, tolen, overlapped, croutine})
	fake.recordInvocation("WSASendTo", []interface{}{s, bufs, bufcnt, sent, flags, to, tolen, overlapped, croutine})
	fake.wSASendToMutex.Unlock()
	if fake.WSASendToStub != nil {
		return fake.WSASendToStub(s, bufs, bufcnt, sent, flags, to, tolen, overlapped, croutine)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.wSASendToReturns.result1
}

func (fake *FakeSyscall) WSASendToCallCount() int {
	fake.wSASendToMutex.RLock()
	defer fake.wSASendToMutex.RUnlock()
	return len(fake.wSASendToArgsForCall)
}

func (fake *FakeSyscall) WSASendToArgsForCall(i int) (syscall.Handle, *syscall.WSABuf, uint32, *uint32, uint32, *syscall.RawSockaddrAny, int32, *syscall.Overlapped, *byte) {
	fake.wSASendToMutex.RLock()
	defer fake.wSASendToMutex.RUnlock()
	return fake.wSASendToArgsForCall[i].s, fake.wSASendToArgsForCall[i].bufs, fake.wSASendToArgsForCall[i].bufcnt, fake.wSASendToArgsForCall[i].sent, fake.wSASendToArgsForCall[i].flags, fake.wSASendToArgsForCall[i].to, fake.wSASendToArgsForCall[i].tolen, fake.wSASendToArgsForCall[i].overlapped, fake.wSASendToArgsForCall[i].croutine
}

func (fake *FakeSyscall) WSASendToReturns(result1 error) {
	fake.WSASendToStub = nil
	fake.wSASendToReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSASendToReturnsOnCall(i int, result1 error) {
	fake.WSASendToStub = nil
	if fake.wSASendToReturnsOnCall == nil {
		fake.wSASendToReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.wSASendToReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetHostByName(name string) (h *syscall.Hostent, err error) {
	fake.getHostByNameMutex.Lock()
	ret, specificReturn := fake.getHostByNameReturnsOnCall[len(fake.getHostByNameArgsForCall)]
	fake.getHostByNameArgsForCall = append(fake.getHostByNameArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("GetHostByName", []interface{}{name})
	fake.getHostByNameMutex.Unlock()
	if fake.GetHostByNameStub != nil {
		return fake.GetHostByNameStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getHostByNameReturns.result1, fake.getHostByNameReturns.result2
}

func (fake *FakeSyscall) GetHostByNameCallCount() int {
	fake.getHostByNameMutex.RLock()
	defer fake.getHostByNameMutex.RUnlock()
	return len(fake.getHostByNameArgsForCall)
}

func (fake *FakeSyscall) GetHostByNameArgsForCall(i int) string {
	fake.getHostByNameMutex.RLock()
	defer fake.getHostByNameMutex.RUnlock()
	return fake.getHostByNameArgsForCall[i].name
}

func (fake *FakeSyscall) GetHostByNameReturns(result1 *syscall.Hostent, result2 error) {
	fake.GetHostByNameStub = nil
	fake.getHostByNameReturns = struct {
		result1 *syscall.Hostent
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetHostByNameReturnsOnCall(i int, result1 *syscall.Hostent, result2 error) {
	fake.GetHostByNameStub = nil
	if fake.getHostByNameReturnsOnCall == nil {
		fake.getHostByNameReturnsOnCall = make(map[int]struct {
			result1 *syscall.Hostent
			result2 error
		})
	}
	fake.getHostByNameReturnsOnCall[i] = struct {
		result1 *syscall.Hostent
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetServByName(name string, proto string) (s *syscall.Servent, err error) {
	fake.getServByNameMutex.Lock()
	ret, specificReturn := fake.getServByNameReturnsOnCall[len(fake.getServByNameArgsForCall)]
	fake.getServByNameArgsForCall = append(fake.getServByNameArgsForCall, struct {
		name  string
		proto string
	}{name, proto})
	fake.recordInvocation("GetServByName", []interface{}{name, proto})
	fake.getServByNameMutex.Unlock()
	if fake.GetServByNameStub != nil {
		return fake.GetServByNameStub(name, proto)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getServByNameReturns.result1, fake.getServByNameReturns.result2
}

func (fake *FakeSyscall) GetServByNameCallCount() int {
	fake.getServByNameMutex.RLock()
	defer fake.getServByNameMutex.RUnlock()
	return len(fake.getServByNameArgsForCall)
}

func (fake *FakeSyscall) GetServByNameArgsForCall(i int) (string, string) {
	fake.getServByNameMutex.RLock()
	defer fake.getServByNameMutex.RUnlock()
	return fake.getServByNameArgsForCall[i].name, fake.getServByNameArgsForCall[i].proto
}

func (fake *FakeSyscall) GetServByNameReturns(result1 *syscall.Servent, result2 error) {
	fake.GetServByNameStub = nil
	fake.getServByNameReturns = struct {
		result1 *syscall.Servent
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetServByNameReturnsOnCall(i int, result1 *syscall.Servent, result2 error) {
	fake.GetServByNameStub = nil
	if fake.getServByNameReturnsOnCall == nil {
		fake.getServByNameReturnsOnCall = make(map[int]struct {
			result1 *syscall.Servent
			result2 error
		})
	}
	fake.getServByNameReturnsOnCall[i] = struct {
		result1 *syscall.Servent
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) Ntohs(netshort uint16) (u uint16) {
	fake.ntohsMutex.Lock()
	ret, specificReturn := fake.ntohsReturnsOnCall[len(fake.ntohsArgsForCall)]
	fake.ntohsArgsForCall = append(fake.ntohsArgsForCall, struct {
		netshort uint16
	}{netshort})
	fake.recordInvocation("Ntohs", []interface{}{netshort})
	fake.ntohsMutex.Unlock()
	if fake.NtohsStub != nil {
		return fake.NtohsStub(netshort)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ntohsReturns.result1
}

func (fake *FakeSyscall) NtohsCallCount() int {
	fake.ntohsMutex.RLock()
	defer fake.ntohsMutex.RUnlock()
	return len(fake.ntohsArgsForCall)
}

func (fake *FakeSyscall) NtohsArgsForCall(i int) uint16 {
	fake.ntohsMutex.RLock()
	defer fake.ntohsMutex.RUnlock()
	return fake.ntohsArgsForCall[i].netshort
}

func (fake *FakeSyscall) NtohsReturns(result1 uint16) {
	fake.NtohsStub = nil
	fake.ntohsReturns = struct {
		result1 uint16
	}{result1}
}

func (fake *FakeSyscall) NtohsReturnsOnCall(i int, result1 uint16) {
	fake.NtohsStub = nil
	if fake.ntohsReturnsOnCall == nil {
		fake.ntohsReturnsOnCall = make(map[int]struct {
			result1 uint16
		})
	}
	fake.ntohsReturnsOnCall[i] = struct {
		result1 uint16
	}{result1}
}

func (fake *FakeSyscall) GetProtoByName(name string) (p *syscall.Protoent, err error) {
	fake.getProtoByNameMutex.Lock()
	ret, specificReturn := fake.getProtoByNameReturnsOnCall[len(fake.getProtoByNameArgsForCall)]
	fake.getProtoByNameArgsForCall = append(fake.getProtoByNameArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("GetProtoByName", []interface{}{name})
	fake.getProtoByNameMutex.Unlock()
	if fake.GetProtoByNameStub != nil {
		return fake.GetProtoByNameStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getProtoByNameReturns.result1, fake.getProtoByNameReturns.result2
}

func (fake *FakeSyscall) GetProtoByNameCallCount() int {
	fake.getProtoByNameMutex.RLock()
	defer fake.getProtoByNameMutex.RUnlock()
	return len(fake.getProtoByNameArgsForCall)
}

func (fake *FakeSyscall) GetProtoByNameArgsForCall(i int) string {
	fake.getProtoByNameMutex.RLock()
	defer fake.getProtoByNameMutex.RUnlock()
	return fake.getProtoByNameArgsForCall[i].name
}

func (fake *FakeSyscall) GetProtoByNameReturns(result1 *syscall.Protoent, result2 error) {
	fake.GetProtoByNameStub = nil
	fake.getProtoByNameReturns = struct {
		result1 *syscall.Protoent
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) GetProtoByNameReturnsOnCall(i int, result1 *syscall.Protoent, result2 error) {
	fake.GetProtoByNameStub = nil
	if fake.getProtoByNameReturnsOnCall == nil {
		fake.getProtoByNameReturnsOnCall = make(map[int]struct {
			result1 *syscall.Protoent
			result2 error
		})
	}
	fake.getProtoByNameReturnsOnCall[i] = struct {
		result1 *syscall.Protoent
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) DnsQuery(name string, qtype uint16, options uint32, extra *byte, qrs **syscall.DNSRecord, pr *byte) (status error) {
	fake.dnsQueryMutex.Lock()
	ret, specificReturn := fake.dnsQueryReturnsOnCall[len(fake.dnsQueryArgsForCall)]
	fake.dnsQueryArgsForCall = append(fake.dnsQueryArgsForCall, struct {
		name    string
		qtype   uint16
		options uint32
		extra   *byte
		qrs     **syscall.DNSRecord
		pr      *byte
	}{name, qtype, options, extra, qrs, pr})
	fake.recordInvocation("DnsQuery", []interface{}{name, qtype, options, extra, qrs, pr})
	fake.dnsQueryMutex.Unlock()
	if fake.DnsQueryStub != nil {
		return fake.DnsQueryStub(name, qtype, options, extra, qrs, pr)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.dnsQueryReturns.result1
}

func (fake *FakeSyscall) DnsQueryCallCount() int {
	fake.dnsQueryMutex.RLock()
	defer fake.dnsQueryMutex.RUnlock()
	return len(fake.dnsQueryArgsForCall)
}

func (fake *FakeSyscall) DnsQueryArgsForCall(i int) (string, uint16, uint32, *byte, **syscall.DNSRecord, *byte) {
	fake.dnsQueryMutex.RLock()
	defer fake.dnsQueryMutex.RUnlock()
	return fake.dnsQueryArgsForCall[i].name, fake.dnsQueryArgsForCall[i].qtype, fake.dnsQueryArgsForCall[i].options, fake.dnsQueryArgsForCall[i].extra, fake.dnsQueryArgsForCall[i].qrs, fake.dnsQueryArgsForCall[i].pr
}

func (fake *FakeSyscall) DnsQueryReturns(result1 error) {
	fake.DnsQueryStub = nil
	fake.dnsQueryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) DnsQueryReturnsOnCall(i int, result1 error) {
	fake.DnsQueryStub = nil
	if fake.dnsQueryReturnsOnCall == nil {
		fake.dnsQueryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dnsQueryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) DnsRecordListFree(rl *syscall.DNSRecord, freetype uint32) {
	fake.dnsRecordListFreeMutex.Lock()
	fake.dnsRecordListFreeArgsForCall = append(fake.dnsRecordListFreeArgsForCall, struct {
		rl       *syscall.DNSRecord
		freetype uint32
	}{rl, freetype})
	fake.recordInvocation("DnsRecordListFree", []interface{}{rl, freetype})
	fake.dnsRecordListFreeMutex.Unlock()
	if fake.DnsRecordListFreeStub != nil {
		fake.DnsRecordListFreeStub(rl, freetype)
	}
}

func (fake *FakeSyscall) DnsRecordListFreeCallCount() int {
	fake.dnsRecordListFreeMutex.RLock()
	defer fake.dnsRecordListFreeMutex.RUnlock()
	return len(fake.dnsRecordListFreeArgsForCall)
}

func (fake *FakeSyscall) DnsRecordListFreeArgsForCall(i int) (*syscall.DNSRecord, uint32) {
	fake.dnsRecordListFreeMutex.RLock()
	defer fake.dnsRecordListFreeMutex.RUnlock()
	return fake.dnsRecordListFreeArgsForCall[i].rl, fake.dnsRecordListFreeArgsForCall[i].freetype
}

func (fake *FakeSyscall) DnsNameCompare(name1 *uint16, name2 *uint16) (same bool) {
	fake.dnsNameCompareMutex.Lock()
	ret, specificReturn := fake.dnsNameCompareReturnsOnCall[len(fake.dnsNameCompareArgsForCall)]
	fake.dnsNameCompareArgsForCall = append(fake.dnsNameCompareArgsForCall, struct {
		name1 *uint16
		name2 *uint16
	}{name1, name2})
	fake.recordInvocation("DnsNameCompare", []interface{}{name1, name2})
	fake.dnsNameCompareMutex.Unlock()
	if fake.DnsNameCompareStub != nil {
		return fake.DnsNameCompareStub(name1, name2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.dnsNameCompareReturns.result1
}

func (fake *FakeSyscall) DnsNameCompareCallCount() int {
	fake.dnsNameCompareMutex.RLock()
	defer fake.dnsNameCompareMutex.RUnlock()
	return len(fake.dnsNameCompareArgsForCall)
}

func (fake *FakeSyscall) DnsNameCompareArgsForCall(i int) (*uint16, *uint16) {
	fake.dnsNameCompareMutex.RLock()
	defer fake.dnsNameCompareMutex.RUnlock()
	return fake.dnsNameCompareArgsForCall[i].name1, fake.dnsNameCompareArgsForCall[i].name2
}

func (fake *FakeSyscall) DnsNameCompareReturns(result1 bool) {
	fake.DnsNameCompareStub = nil
	fake.dnsNameCompareReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSyscall) DnsNameCompareReturnsOnCall(i int, result1 bool) {
	fake.DnsNameCompareStub = nil
	if fake.dnsNameCompareReturnsOnCall == nil {
		fake.dnsNameCompareReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.dnsNameCompareReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSyscall) GetAddrInfoW(nodename *uint16, servicename *uint16, hints *syscall.AddrinfoW, result **syscall.AddrinfoW) (sockerr error) {
	fake.getAddrInfoWMutex.Lock()
	ret, specificReturn := fake.getAddrInfoWReturnsOnCall[len(fake.getAddrInfoWArgsForCall)]
	fake.getAddrInfoWArgsForCall = append(fake.getAddrInfoWArgsForCall, struct {
		nodename    *uint16
		servicename *uint16
		hints       *syscall.AddrinfoW
		result      **syscall.AddrinfoW
	}{nodename, servicename, hints, result})
	fake.recordInvocation("GetAddrInfoW", []interface{}{nodename, servicename, hints, result})
	fake.getAddrInfoWMutex.Unlock()
	if fake.GetAddrInfoWStub != nil {
		return fake.GetAddrInfoWStub(nodename, servicename, hints, result)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getAddrInfoWReturns.result1
}

func (fake *FakeSyscall) GetAddrInfoWCallCount() int {
	fake.getAddrInfoWMutex.RLock()
	defer fake.getAddrInfoWMutex.RUnlock()
	return len(fake.getAddrInfoWArgsForCall)
}

func (fake *FakeSyscall) GetAddrInfoWArgsForCall(i int) (*uint16, *uint16, *syscall.AddrinfoW, **syscall.AddrinfoW) {
	fake.getAddrInfoWMutex.RLock()
	defer fake.getAddrInfoWMutex.RUnlock()
	return fake.getAddrInfoWArgsForCall[i].nodename, fake.getAddrInfoWArgsForCall[i].servicename, fake.getAddrInfoWArgsForCall[i].hints, fake.getAddrInfoWArgsForCall[i].result
}

func (fake *FakeSyscall) GetAddrInfoWReturns(result1 error) {
	fake.GetAddrInfoWStub = nil
	fake.getAddrInfoWReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetAddrInfoWReturnsOnCall(i int, result1 error) {
	fake.GetAddrInfoWStub = nil
	if fake.getAddrInfoWReturnsOnCall == nil {
		fake.getAddrInfoWReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getAddrInfoWReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) FreeAddrInfoW(addrinfo *syscall.AddrinfoW) {
	fake.freeAddrInfoWMutex.Lock()
	fake.freeAddrInfoWArgsForCall = append(fake.freeAddrInfoWArgsForCall, struct {
		addrinfo *syscall.AddrinfoW
	}{addrinfo})
	fake.recordInvocation("FreeAddrInfoW", []interface{}{addrinfo})
	fake.freeAddrInfoWMutex.Unlock()
	if fake.FreeAddrInfoWStub != nil {
		fake.FreeAddrInfoWStub(addrinfo)
	}
}

func (fake *FakeSyscall) FreeAddrInfoWCallCount() int {
	fake.freeAddrInfoWMutex.RLock()
	defer fake.freeAddrInfoWMutex.RUnlock()
	return len(fake.freeAddrInfoWArgsForCall)
}

func (fake *FakeSyscall) FreeAddrInfoWArgsForCall(i int) *syscall.AddrinfoW {
	fake.freeAddrInfoWMutex.RLock()
	defer fake.freeAddrInfoWMutex.RUnlock()
	return fake.freeAddrInfoWArgsForCall[i].addrinfo
}

func (fake *FakeSyscall) GetIfEntry(pIfRow *syscall.MibIfRow) (errcode error) {
	fake.getIfEntryMutex.Lock()
	ret, specificReturn := fake.getIfEntryReturnsOnCall[len(fake.getIfEntryArgsForCall)]
	fake.getIfEntryArgsForCall = append(fake.getIfEntryArgsForCall, struct {
		pIfRow *syscall.MibIfRow
	}{pIfRow})
	fake.recordInvocation("GetIfEntry", []interface{}{pIfRow})
	fake.getIfEntryMutex.Unlock()
	if fake.GetIfEntryStub != nil {
		return fake.GetIfEntryStub(pIfRow)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getIfEntryReturns.result1
}

func (fake *FakeSyscall) GetIfEntryCallCount() int {
	fake.getIfEntryMutex.RLock()
	defer fake.getIfEntryMutex.RUnlock()
	return len(fake.getIfEntryArgsForCall)
}

func (fake *FakeSyscall) GetIfEntryArgsForCall(i int) *syscall.MibIfRow {
	fake.getIfEntryMutex.RLock()
	defer fake.getIfEntryMutex.RUnlock()
	return fake.getIfEntryArgsForCall[i].pIfRow
}

func (fake *FakeSyscall) GetIfEntryReturns(result1 error) {
	fake.GetIfEntryStub = nil
	fake.getIfEntryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetIfEntryReturnsOnCall(i int, result1 error) {
	fake.GetIfEntryStub = nil
	if fake.getIfEntryReturnsOnCall == nil {
		fake.getIfEntryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getIfEntryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetAdaptersInfo(ai *syscall.IpAdapterInfo, ol *uint32) (errcode error) {
	fake.getAdaptersInfoMutex.Lock()
	ret, specificReturn := fake.getAdaptersInfoReturnsOnCall[len(fake.getAdaptersInfoArgsForCall)]
	fake.getAdaptersInfoArgsForCall = append(fake.getAdaptersInfoArgsForCall, struct {
		ai *syscall.IpAdapterInfo
		ol *uint32
	}{ai, ol})
	fake.recordInvocation("GetAdaptersInfo", []interface{}{ai, ol})
	fake.getAdaptersInfoMutex.Unlock()
	if fake.GetAdaptersInfoStub != nil {
		return fake.GetAdaptersInfoStub(ai, ol)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getAdaptersInfoReturns.result1
}

func (fake *FakeSyscall) GetAdaptersInfoCallCount() int {
	fake.getAdaptersInfoMutex.RLock()
	defer fake.getAdaptersInfoMutex.RUnlock()
	return len(fake.getAdaptersInfoArgsForCall)
}

func (fake *FakeSyscall) GetAdaptersInfoArgsForCall(i int) (*syscall.IpAdapterInfo, *uint32) {
	fake.getAdaptersInfoMutex.RLock()
	defer fake.getAdaptersInfoMutex.RUnlock()
	return fake.getAdaptersInfoArgsForCall[i].ai, fake.getAdaptersInfoArgsForCall[i].ol
}

func (fake *FakeSyscall) GetAdaptersInfoReturns(result1 error) {
	fake.GetAdaptersInfoStub = nil
	fake.getAdaptersInfoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetAdaptersInfoReturnsOnCall(i int, result1 error) {
	fake.GetAdaptersInfoStub = nil
	if fake.getAdaptersInfoReturnsOnCall == nil {
		fake.getAdaptersInfoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getAdaptersInfoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetFileCompletionNotificationModes(handle syscall.Handle, flags uint8) (err error) {
	fake.setFileCompletionNotificationModesMutex.Lock()
	ret, specificReturn := fake.setFileCompletionNotificationModesReturnsOnCall[len(fake.setFileCompletionNotificationModesArgsForCall)]
	fake.setFileCompletionNotificationModesArgsForCall = append(fake.setFileCompletionNotificationModesArgsForCall, struct {
		handle syscall.Handle
		flags  uint8
	}{handle, flags})
	fake.recordInvocation("SetFileCompletionNotificationModes", []interface{}{handle, flags})
	fake.setFileCompletionNotificationModesMutex.Unlock()
	if fake.SetFileCompletionNotificationModesStub != nil {
		return fake.SetFileCompletionNotificationModesStub(handle, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setFileCompletionNotificationModesReturns.result1
}

func (fake *FakeSyscall) SetFileCompletionNotificationModesCallCount() int {
	fake.setFileCompletionNotificationModesMutex.RLock()
	defer fake.setFileCompletionNotificationModesMutex.RUnlock()
	return len(fake.setFileCompletionNotificationModesArgsForCall)
}

func (fake *FakeSyscall) SetFileCompletionNotificationModesArgsForCall(i int) (syscall.Handle, uint8) {
	fake.setFileCompletionNotificationModesMutex.RLock()
	defer fake.setFileCompletionNotificationModesMutex.RUnlock()
	return fake.setFileCompletionNotificationModesArgsForCall[i].handle, fake.setFileCompletionNotificationModesArgsForCall[i].flags
}

func (fake *FakeSyscall) SetFileCompletionNotificationModesReturns(result1 error) {
	fake.SetFileCompletionNotificationModesStub = nil
	fake.setFileCompletionNotificationModesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) SetFileCompletionNotificationModesReturnsOnCall(i int, result1 error) {
	fake.SetFileCompletionNotificationModesStub = nil
	if fake.setFileCompletionNotificationModesReturnsOnCall == nil {
		fake.setFileCompletionNotificationModesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setFileCompletionNotificationModesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) WSAEnumProtocols(protocols *int32, protocolBuffer *syscall.WSAProtocolInfo, bufferLength *uint32) (n int32, err error) {
	fake.wSAEnumProtocolsMutex.Lock()
	ret, specificReturn := fake.wSAEnumProtocolsReturnsOnCall[len(fake.wSAEnumProtocolsArgsForCall)]
	fake.wSAEnumProtocolsArgsForCall = append(fake.wSAEnumProtocolsArgsForCall, struct {
		protocols      *int32
		protocolBuffer *syscall.WSAProtocolInfo
		bufferLength   *uint32
	}{protocols, protocolBuffer, bufferLength})
	fake.recordInvocation("WSAEnumProtocols", []interface{}{protocols, protocolBuffer, bufferLength})
	fake.wSAEnumProtocolsMutex.Unlock()
	if fake.WSAEnumProtocolsStub != nil {
		return fake.WSAEnumProtocolsStub(protocols, protocolBuffer, bufferLength)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.wSAEnumProtocolsReturns.result1, fake.wSAEnumProtocolsReturns.result2
}

func (fake *FakeSyscall) WSAEnumProtocolsCallCount() int {
	fake.wSAEnumProtocolsMutex.RLock()
	defer fake.wSAEnumProtocolsMutex.RUnlock()
	return len(fake.wSAEnumProtocolsArgsForCall)
}

func (fake *FakeSyscall) WSAEnumProtocolsArgsForCall(i int) (*int32, *syscall.WSAProtocolInfo, *uint32) {
	fake.wSAEnumProtocolsMutex.RLock()
	defer fake.wSAEnumProtocolsMutex.RUnlock()
	return fake.wSAEnumProtocolsArgsForCall[i].protocols, fake.wSAEnumProtocolsArgsForCall[i].protocolBuffer, fake.wSAEnumProtocolsArgsForCall[i].bufferLength
}

func (fake *FakeSyscall) WSAEnumProtocolsReturns(result1 int32, result2 error) {
	fake.WSAEnumProtocolsStub = nil
	fake.wSAEnumProtocolsReturns = struct {
		result1 int32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) WSAEnumProtocolsReturnsOnCall(i int, result1 int32, result2 error) {
	fake.WSAEnumProtocolsStub = nil
	if fake.wSAEnumProtocolsReturnsOnCall == nil {
		fake.wSAEnumProtocolsReturnsOnCall = make(map[int]struct {
			result1 int32
			result2 error
		})
	}
	fake.wSAEnumProtocolsReturnsOnCall[i] = struct {
		result1 int32
		result2 error
	}{result1, result2}
}

func (fake *FakeSyscall) TranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) {
	fake.translateNameMutex.Lock()
	ret, specificReturn := fake.translateNameReturnsOnCall[len(fake.translateNameArgsForCall)]
	fake.translateNameArgsForCall = append(fake.translateNameArgsForCall, struct {
		accName           *uint16
		accNameFormat     uint32
		desiredNameFormat uint32
		translatedName    *uint16
		nSize             *uint32
	}{accName, accNameFormat, desiredNameFormat, translatedName, nSize})
	fake.recordInvocation("TranslateName", []interface{}{accName, accNameFormat, desiredNameFormat, translatedName, nSize})
	fake.translateNameMutex.Unlock()
	if fake.TranslateNameStub != nil {
		return fake.TranslateNameStub(accName, accNameFormat, desiredNameFormat, translatedName, nSize)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.translateNameReturns.result1
}

func (fake *FakeSyscall) TranslateNameCallCount() int {
	fake.translateNameMutex.RLock()
	defer fake.translateNameMutex.RUnlock()
	return len(fake.translateNameArgsForCall)
}

func (fake *FakeSyscall) TranslateNameArgsForCall(i int) (*uint16, uint32, uint32, *uint16, *uint32) {
	fake.translateNameMutex.RLock()
	defer fake.translateNameMutex.RUnlock()
	return fake.translateNameArgsForCall[i].accName, fake.translateNameArgsForCall[i].accNameFormat, fake.translateNameArgsForCall[i].desiredNameFormat, fake.translateNameArgsForCall[i].translatedName, fake.translateNameArgsForCall[i].nSize
}

func (fake *FakeSyscall) TranslateNameReturns(result1 error) {
	fake.TranslateNameStub = nil
	fake.translateNameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) TranslateNameReturnsOnCall(i int, result1 error) {
	fake.TranslateNameStub = nil
	if fake.translateNameReturnsOnCall == nil {
		fake.translateNameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.translateNameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetUserNameEx(nameFormat uint32, nameBuffre *uint16, nSize *uint32) (err error) {
	fake.getUserNameExMutex.Lock()
	ret, specificReturn := fake.getUserNameExReturnsOnCall[len(fake.getUserNameExArgsForCall)]
	fake.getUserNameExArgsForCall = append(fake.getUserNameExArgsForCall, struct {
		nameFormat uint32
		nameBuffre *uint16
		nSize      *uint32
	}{nameFormat, nameBuffre, nSize})
	fake.recordInvocation("GetUserNameEx", []interface{}{nameFormat, nameBuffre, nSize})
	fake.getUserNameExMutex.Unlock()
	if fake.GetUserNameExStub != nil {
		return fake.GetUserNameExStub(nameFormat, nameBuffre, nSize)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getUserNameExReturns.result1
}

func (fake *FakeSyscall) GetUserNameExCallCount() int {
	fake.getUserNameExMutex.RLock()
	defer fake.getUserNameExMutex.RUnlock()
	return len(fake.getUserNameExArgsForCall)
}

func (fake *FakeSyscall) GetUserNameExArgsForCall(i int) (uint32, *uint16, *uint32) {
	fake.getUserNameExMutex.RLock()
	defer fake.getUserNameExMutex.RUnlock()
	return fake.getUserNameExArgsForCall[i].nameFormat, fake.getUserNameExArgsForCall[i].nameBuffre, fake.getUserNameExArgsForCall[i].nSize
}

func (fake *FakeSyscall) GetUserNameExReturns(result1 error) {
	fake.GetUserNameExStub = nil
	fake.getUserNameExReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetUserNameExReturnsOnCall(i int, result1 error) {
	fake.GetUserNameExStub = nil
	if fake.getUserNameExReturnsOnCall == nil {
		fake.getUserNameExReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getUserNameExReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) NetUserGetInfo(serverName *uint16, userName *uint16, level uint32, buf **byte) (neterr error) {
	fake.netUserGetInfoMutex.Lock()
	ret, specificReturn := fake.netUserGetInfoReturnsOnCall[len(fake.netUserGetInfoArgsForCall)]
	fake.netUserGetInfoArgsForCall = append(fake.netUserGetInfoArgsForCall, struct {
		serverName *uint16
		userName   *uint16
		level      uint32
		buf        **byte
	}{serverName, userName, level, buf})
	fake.recordInvocation("NetUserGetInfo", []interface{}{serverName, userName, level, buf})
	fake.netUserGetInfoMutex.Unlock()
	if fake.NetUserGetInfoStub != nil {
		return fake.NetUserGetInfoStub(serverName, userName, level, buf)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.netUserGetInfoReturns.result1
}

func (fake *FakeSyscall) NetUserGetInfoCallCount() int {
	fake.netUserGetInfoMutex.RLock()
	defer fake.netUserGetInfoMutex.RUnlock()
	return len(fake.netUserGetInfoArgsForCall)
}

func (fake *FakeSyscall) NetUserGetInfoArgsForCall(i int) (*uint16, *uint16, uint32, **byte) {
	fake.netUserGetInfoMutex.RLock()
	defer fake.netUserGetInfoMutex.RUnlock()
	return fake.netUserGetInfoArgsForCall[i].serverName, fake.netUserGetInfoArgsForCall[i].userName, fake.netUserGetInfoArgsForCall[i].level, fake.netUserGetInfoArgsForCall[i].buf
}

func (fake *FakeSyscall) NetUserGetInfoReturns(result1 error) {
	fake.NetUserGetInfoStub = nil
	fake.netUserGetInfoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) NetUserGetInfoReturnsOnCall(i int, result1 error) {
	fake.NetUserGetInfoStub = nil
	if fake.netUserGetInfoReturnsOnCall == nil {
		fake.netUserGetInfoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.netUserGetInfoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) NetGetJoinInformation(server *uint16, name **uint16, bufType *uint32) (neterr error) {
	fake.netGetJoinInformationMutex.Lock()
	ret, specificReturn := fake.netGetJoinInformationReturnsOnCall[len(fake.netGetJoinInformationArgsForCall)]
	fake.netGetJoinInformationArgsForCall = append(fake.netGetJoinInformationArgsForCall, struct {
		server  *uint16
		name    **uint16
		bufType *uint32
	}{server, name, bufType})
	fake.recordInvocation("NetGetJoinInformation", []interface{}{server, name, bufType})
	fake.netGetJoinInformationMutex.Unlock()
	if fake.NetGetJoinInformationStub != nil {
		return fake.NetGetJoinInformationStub(server, name, bufType)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.netGetJoinInformationReturns.result1
}

func (fake *FakeSyscall) NetGetJoinInformationCallCount() int {
	fake.netGetJoinInformationMutex.RLock()
	defer fake.netGetJoinInformationMutex.RUnlock()
	return len(fake.netGetJoinInformationArgsForCall)
}

func (fake *FakeSyscall) NetGetJoinInformationArgsForCall(i int) (*uint16, **uint16, *uint32) {
	fake.netGetJoinInformationMutex.RLock()
	defer fake.netGetJoinInformationMutex.RUnlock()
	return fake.netGetJoinInformationArgsForCall[i].server, fake.netGetJoinInformationArgsForCall[i].name, fake.netGetJoinInformationArgsForCall[i].bufType
}

func (fake *FakeSyscall) NetGetJoinInformationReturns(result1 error) {
	fake.NetGetJoinInformationStub = nil
	fake.netGetJoinInformationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) NetGetJoinInformationReturnsOnCall(i int, result1 error) {
	fake.NetGetJoinInformationStub = nil
	if fake.netGetJoinInformationReturnsOnCall == nil {
		fake.netGetJoinInformationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.netGetJoinInformationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) NetApiBufferFree(buf *byte) (neterr error) {
	fake.netApiBufferFreeMutex.Lock()
	ret, specificReturn := fake.netApiBufferFreeReturnsOnCall[len(fake.netApiBufferFreeArgsForCall)]
	fake.netApiBufferFreeArgsForCall = append(fake.netApiBufferFreeArgsForCall, struct {
		buf *byte
	}{buf})
	fake.recordInvocation("NetApiBufferFree", []interface{}{buf})
	fake.netApiBufferFreeMutex.Unlock()
	if fake.NetApiBufferFreeStub != nil {
		return fake.NetApiBufferFreeStub(buf)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.netApiBufferFreeReturns.result1
}

func (fake *FakeSyscall) NetApiBufferFreeCallCount() int {
	fake.netApiBufferFreeMutex.RLock()
	defer fake.netApiBufferFreeMutex.RUnlock()
	return len(fake.netApiBufferFreeArgsForCall)
}

func (fake *FakeSyscall) NetApiBufferFreeArgsForCall(i int) *byte {
	fake.netApiBufferFreeMutex.RLock()
	defer fake.netApiBufferFreeMutex.RUnlock()
	return fake.netApiBufferFreeArgsForCall[i].buf
}

func (fake *FakeSyscall) NetApiBufferFreeReturns(result1 error) {
	fake.NetApiBufferFreeStub = nil
	fake.netApiBufferFreeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) NetApiBufferFreeReturnsOnCall(i int, result1 error) {
	fake.NetApiBufferFreeStub = nil
	if fake.netApiBufferFreeReturnsOnCall == nil {
		fake.netApiBufferFreeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.netApiBufferFreeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LookupAccountSid(systemName *uint16, sid *syscall.SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) {
	fake.lookupAccountSidMutex.Lock()
	ret, specificReturn := fake.lookupAccountSidReturnsOnCall[len(fake.lookupAccountSidArgsForCall)]
	fake.lookupAccountSidArgsForCall = append(fake.lookupAccountSidArgsForCall, struct {
		systemName        *uint16
		sid               *syscall.SID
		name              *uint16
		nameLen           *uint32
		refdDomainName    *uint16
		refdDomainNameLen *uint32
		use               *uint32
	}{systemName, sid, name, nameLen, refdDomainName, refdDomainNameLen, use})
	fake.recordInvocation("LookupAccountSid", []interface{}{systemName, sid, name, nameLen, refdDomainName, refdDomainNameLen, use})
	fake.lookupAccountSidMutex.Unlock()
	if fake.LookupAccountSidStub != nil {
		return fake.LookupAccountSidStub(systemName, sid, name, nameLen, refdDomainName, refdDomainNameLen, use)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.lookupAccountSidReturns.result1
}

func (fake *FakeSyscall) LookupAccountSidCallCount() int {
	fake.lookupAccountSidMutex.RLock()
	defer fake.lookupAccountSidMutex.RUnlock()
	return len(fake.lookupAccountSidArgsForCall)
}

func (fake *FakeSyscall) LookupAccountSidArgsForCall(i int) (*uint16, *syscall.SID, *uint16, *uint32, *uint16, *uint32, *uint32) {
	fake.lookupAccountSidMutex.RLock()
	defer fake.lookupAccountSidMutex.RUnlock()
	return fake.lookupAccountSidArgsForCall[i].systemName, fake.lookupAccountSidArgsForCall[i].sid, fake.lookupAccountSidArgsForCall[i].name, fake.lookupAccountSidArgsForCall[i].nameLen, fake.lookupAccountSidArgsForCall[i].refdDomainName, fake.lookupAccountSidArgsForCall[i].refdDomainNameLen, fake.lookupAccountSidArgsForCall[i].use
}

func (fake *FakeSyscall) LookupAccountSidReturns(result1 error) {
	fake.LookupAccountSidStub = nil
	fake.lookupAccountSidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LookupAccountSidReturnsOnCall(i int, result1 error) {
	fake.LookupAccountSidStub = nil
	if fake.lookupAccountSidReturnsOnCall == nil {
		fake.lookupAccountSidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.lookupAccountSidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LookupAccountName(systemName *uint16, accountName *uint16, sid *syscall.SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) {
	fake.lookupAccountNameMutex.Lock()
	ret, specificReturn := fake.lookupAccountNameReturnsOnCall[len(fake.lookupAccountNameArgsForCall)]
	fake.lookupAccountNameArgsForCall = append(fake.lookupAccountNameArgsForCall, struct {
		systemName        *uint16
		accountName       *uint16
		sid               *syscall.SID
		sidLen            *uint32
		refdDomainName    *uint16
		refdDomainNameLen *uint32
		use               *uint32
	}{systemName, accountName, sid, sidLen, refdDomainName, refdDomainNameLen, use})
	fake.recordInvocation("LookupAccountName", []interface{}{systemName, accountName, sid, sidLen, refdDomainName, refdDomainNameLen, use})
	fake.lookupAccountNameMutex.Unlock()
	if fake.LookupAccountNameStub != nil {
		return fake.LookupAccountNameStub(systemName, accountName, sid, sidLen, refdDomainName, refdDomainNameLen, use)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.lookupAccountNameReturns.result1
}

func (fake *FakeSyscall) LookupAccountNameCallCount() int {
	fake.lookupAccountNameMutex.RLock()
	defer fake.lookupAccountNameMutex.RUnlock()
	return len(fake.lookupAccountNameArgsForCall)
}

func (fake *FakeSyscall) LookupAccountNameArgsForCall(i int) (*uint16, *uint16, *syscall.SID, *uint32, *uint16, *uint32, *uint32) {
	fake.lookupAccountNameMutex.RLock()
	defer fake.lookupAccountNameMutex.RUnlock()
	return fake.lookupAccountNameArgsForCall[i].systemName, fake.lookupAccountNameArgsForCall[i].accountName, fake.lookupAccountNameArgsForCall[i].sid, fake.lookupAccountNameArgsForCall[i].sidLen, fake.lookupAccountNameArgsForCall[i].refdDomainName, fake.lookupAccountNameArgsForCall[i].refdDomainNameLen, fake.lookupAccountNameArgsForCall[i].use
}

func (fake *FakeSyscall) LookupAccountNameReturns(result1 error) {
	fake.LookupAccountNameStub = nil
	fake.lookupAccountNameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) LookupAccountNameReturnsOnCall(i int, result1 error) {
	fake.LookupAccountNameStub = nil
	if fake.lookupAccountNameReturnsOnCall == nil {
		fake.lookupAccountNameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.lookupAccountNameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ConvertSidToStringSid(sid *syscall.SID, stringSid **uint16) (err error) {
	fake.convertSidToStringSidMutex.Lock()
	ret, specificReturn := fake.convertSidToStringSidReturnsOnCall[len(fake.convertSidToStringSidArgsForCall)]
	fake.convertSidToStringSidArgsForCall = append(fake.convertSidToStringSidArgsForCall, struct {
		sid       *syscall.SID
		stringSid **uint16
	}{sid, stringSid})
	fake.recordInvocation("ConvertSidToStringSid", []interface{}{sid, stringSid})
	fake.convertSidToStringSidMutex.Unlock()
	if fake.ConvertSidToStringSidStub != nil {
		return fake.ConvertSidToStringSidStub(sid, stringSid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.convertSidToStringSidReturns.result1
}

func (fake *FakeSyscall) ConvertSidToStringSidCallCount() int {
	fake.convertSidToStringSidMutex.RLock()
	defer fake.convertSidToStringSidMutex.RUnlock()
	return len(fake.convertSidToStringSidArgsForCall)
}

func (fake *FakeSyscall) ConvertSidToStringSidArgsForCall(i int) (*syscall.SID, **uint16) {
	fake.convertSidToStringSidMutex.RLock()
	defer fake.convertSidToStringSidMutex.RUnlock()
	return fake.convertSidToStringSidArgsForCall[i].sid, fake.convertSidToStringSidArgsForCall[i].stringSid
}

func (fake *FakeSyscall) ConvertSidToStringSidReturns(result1 error) {
	fake.ConvertSidToStringSidStub = nil
	fake.convertSidToStringSidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ConvertSidToStringSidReturnsOnCall(i int, result1 error) {
	fake.ConvertSidToStringSidStub = nil
	if fake.convertSidToStringSidReturnsOnCall == nil {
		fake.convertSidToStringSidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.convertSidToStringSidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ConvertStringSidToSid(stringSid *uint16, sid **syscall.SID) (err error) {
	fake.convertStringSidToSidMutex.Lock()
	ret, specificReturn := fake.convertStringSidToSidReturnsOnCall[len(fake.convertStringSidToSidArgsForCall)]
	fake.convertStringSidToSidArgsForCall = append(fake.convertStringSidToSidArgsForCall, struct {
		stringSid *uint16
		sid       **syscall.SID
	}{stringSid, sid})
	fake.recordInvocation("ConvertStringSidToSid", []interface{}{stringSid, sid})
	fake.convertStringSidToSidMutex.Unlock()
	if fake.ConvertStringSidToSidStub != nil {
		return fake.ConvertStringSidToSidStub(stringSid, sid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.convertStringSidToSidReturns.result1
}

func (fake *FakeSyscall) ConvertStringSidToSidCallCount() int {
	fake.convertStringSidToSidMutex.RLock()
	defer fake.convertStringSidToSidMutex.RUnlock()
	return len(fake.convertStringSidToSidArgsForCall)
}

func (fake *FakeSyscall) ConvertStringSidToSidArgsForCall(i int) (*uint16, **syscall.SID) {
	fake.convertStringSidToSidMutex.RLock()
	defer fake.convertStringSidToSidMutex.RUnlock()
	return fake.convertStringSidToSidArgsForCall[i].stringSid, fake.convertStringSidToSidArgsForCall[i].sid
}

func (fake *FakeSyscall) ConvertStringSidToSidReturns(result1 error) {
	fake.ConvertStringSidToSidStub = nil
	fake.convertStringSidToSidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) ConvertStringSidToSidReturnsOnCall(i int, result1 error) {
	fake.ConvertStringSidToSidStub = nil
	if fake.convertStringSidToSidReturnsOnCall == nil {
		fake.convertStringSidToSidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.convertStringSidToSidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetLengthSid(sid *syscall.SID) (len uint32) {
	fake.getLengthSidMutex.Lock()
	ret, specificReturn := fake.getLengthSidReturnsOnCall[len(fake.getLengthSidArgsForCall)]
	fake.getLengthSidArgsForCall = append(fake.getLengthSidArgsForCall, struct {
		sid *syscall.SID
	}{sid})
	fake.recordInvocation("GetLengthSid", []interface{}{sid})
	fake.getLengthSidMutex.Unlock()
	if fake.GetLengthSidStub != nil {
		return fake.GetLengthSidStub(sid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getLengthSidReturns.result1
}

func (fake *FakeSyscall) GetLengthSidCallCount() int {
	fake.getLengthSidMutex.RLock()
	defer fake.getLengthSidMutex.RUnlock()
	return len(fake.getLengthSidArgsForCall)
}

func (fake *FakeSyscall) GetLengthSidArgsForCall(i int) *syscall.SID {
	fake.getLengthSidMutex.RLock()
	defer fake.getLengthSidMutex.RUnlock()
	return fake.getLengthSidArgsForCall[i].sid
}

func (fake *FakeSyscall) GetLengthSidReturns(result1 uint32) {
	fake.GetLengthSidStub = nil
	fake.getLengthSidReturns = struct {
		result1 uint32
	}{result1}
}

func (fake *FakeSyscall) GetLengthSidReturnsOnCall(i int, result1 uint32) {
	fake.GetLengthSidStub = nil
	if fake.getLengthSidReturnsOnCall == nil {
		fake.getLengthSidReturnsOnCall = make(map[int]struct {
			result1 uint32
		})
	}
	fake.getLengthSidReturnsOnCall[i] = struct {
		result1 uint32
	}{result1}
}

func (fake *FakeSyscall) CopySid(destSidLen uint32, destSid *syscall.SID, srcSid *syscall.SID) (err error) {
	fake.copySidMutex.Lock()
	ret, specificReturn := fake.copySidReturnsOnCall[len(fake.copySidArgsForCall)]
	fake.copySidArgsForCall = append(fake.copySidArgsForCall, struct {
		destSidLen uint32
		destSid    *syscall.SID
		srcSid     *syscall.SID
	}{destSidLen, destSid, srcSid})
	fake.recordInvocation("CopySid", []interface{}{destSidLen, destSid, srcSid})
	fake.copySidMutex.Unlock()
	if fake.CopySidStub != nil {
		return fake.CopySidStub(destSidLen, destSid, srcSid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.copySidReturns.result1
}

func (fake *FakeSyscall) CopySidCallCount() int {
	fake.copySidMutex.RLock()
	defer fake.copySidMutex.RUnlock()
	return len(fake.copySidArgsForCall)
}

func (fake *FakeSyscall) CopySidArgsForCall(i int) (uint32, *syscall.SID, *syscall.SID) {
	fake.copySidMutex.RLock()
	defer fake.copySidMutex.RUnlock()
	return fake.copySidArgsForCall[i].destSidLen, fake.copySidArgsForCall[i].destSid, fake.copySidArgsForCall[i].srcSid
}

func (fake *FakeSyscall) CopySidReturns(result1 error) {
	fake.CopySidStub = nil
	fake.copySidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) CopySidReturnsOnCall(i int, result1 error) {
	fake.CopySidStub = nil
	if fake.copySidReturnsOnCall == nil {
		fake.copySidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copySidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) OpenProcessToken(h syscall.Handle, access uint32, token *syscall.Token) (err error) {
	fake.openProcessTokenMutex.Lock()
	ret, specificReturn := fake.openProcessTokenReturnsOnCall[len(fake.openProcessTokenArgsForCall)]
	fake.openProcessTokenArgsForCall = append(fake.openProcessTokenArgsForCall, struct {
		h      syscall.Handle
		access uint32
		token  *syscall.Token
	}{h, access, token})
	fake.recordInvocation("OpenProcessToken", []interface{}{h, access, token})
	fake.openProcessTokenMutex.Unlock()
	if fake.OpenProcessTokenStub != nil {
		return fake.OpenProcessTokenStub(h, access, token)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.openProcessTokenReturns.result1
}

func (fake *FakeSyscall) OpenProcessTokenCallCount() int {
	fake.openProcessTokenMutex.RLock()
	defer fake.openProcessTokenMutex.RUnlock()
	return len(fake.openProcessTokenArgsForCall)
}

func (fake *FakeSyscall) OpenProcessTokenArgsForCall(i int) (syscall.Handle, uint32, *syscall.Token) {
	fake.openProcessTokenMutex.RLock()
	defer fake.openProcessTokenMutex.RUnlock()
	return fake.openProcessTokenArgsForCall[i].h, fake.openProcessTokenArgsForCall[i].access, fake.openProcessTokenArgsForCall[i].token
}

func (fake *FakeSyscall) OpenProcessTokenReturns(result1 error) {
	fake.OpenProcessTokenStub = nil
	fake.openProcessTokenReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) OpenProcessTokenReturnsOnCall(i int, result1 error) {
	fake.OpenProcessTokenStub = nil
	if fake.openProcessTokenReturnsOnCall == nil {
		fake.openProcessTokenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.openProcessTokenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetTokenInformation(t syscall.Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) {
	fake.getTokenInformationMutex.Lock()
	ret, specificReturn := fake.getTokenInformationReturnsOnCall[len(fake.getTokenInformationArgsForCall)]
	fake.getTokenInformationArgsForCall = append(fake.getTokenInformationArgsForCall, struct {
		t           syscall.Token
		infoClass   uint32
		info        *byte
		infoLen     uint32
		returnedLen *uint32
	}{t, infoClass, info, infoLen, returnedLen})
	fake.recordInvocation("GetTokenInformation", []interface{}{t, infoClass, info, infoLen, returnedLen})
	fake.getTokenInformationMutex.Unlock()
	if fake.GetTokenInformationStub != nil {
		return fake.GetTokenInformationStub(t, infoClass, info, infoLen, returnedLen)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getTokenInformationReturns.result1
}

func (fake *FakeSyscall) GetTokenInformationCallCount() int {
	fake.getTokenInformationMutex.RLock()
	defer fake.getTokenInformationMutex.RUnlock()
	return len(fake.getTokenInformationArgsForCall)
}

func (fake *FakeSyscall) GetTokenInformationArgsForCall(i int) (syscall.Token, uint32, *byte, uint32, *uint32) {
	fake.getTokenInformationMutex.RLock()
	defer fake.getTokenInformationMutex.RUnlock()
	return fake.getTokenInformationArgsForCall[i].t, fake.getTokenInformationArgsForCall[i].infoClass, fake.getTokenInformationArgsForCall[i].info, fake.getTokenInformationArgsForCall[i].infoLen, fake.getTokenInformationArgsForCall[i].returnedLen
}

func (fake *FakeSyscall) GetTokenInformationReturns(result1 error) {
	fake.GetTokenInformationStub = nil
	fake.getTokenInformationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetTokenInformationReturnsOnCall(i int, result1 error) {
	fake.GetTokenInformationStub = nil
	if fake.getTokenInformationReturnsOnCall == nil {
		fake.getTokenInformationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getTokenInformationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetUserProfileDirectory(t syscall.Token, dir *uint16, dirLen *uint32) (err error) {
	fake.getUserProfileDirectoryMutex.Lock()
	ret, specificReturn := fake.getUserProfileDirectoryReturnsOnCall[len(fake.getUserProfileDirectoryArgsForCall)]
	fake.getUserProfileDirectoryArgsForCall = append(fake.getUserProfileDirectoryArgsForCall, struct {
		t      syscall.Token
		dir    *uint16
		dirLen *uint32
	}{t, dir, dirLen})
	fake.recordInvocation("GetUserProfileDirectory", []interface{}{t, dir, dirLen})
	fake.getUserProfileDirectoryMutex.Unlock()
	if fake.GetUserProfileDirectoryStub != nil {
		return fake.GetUserProfileDirectoryStub(t, dir, dirLen)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getUserProfileDirectoryReturns.result1
}

func (fake *FakeSyscall) GetUserProfileDirectoryCallCount() int {
	fake.getUserProfileDirectoryMutex.RLock()
	defer fake.getUserProfileDirectoryMutex.RUnlock()
	return len(fake.getUserProfileDirectoryArgsForCall)
}

func (fake *FakeSyscall) GetUserProfileDirectoryArgsForCall(i int) (syscall.Token, *uint16, *uint32) {
	fake.getUserProfileDirectoryMutex.RLock()
	defer fake.getUserProfileDirectoryMutex.RUnlock()
	return fake.getUserProfileDirectoryArgsForCall[i].t, fake.getUserProfileDirectoryArgsForCall[i].dir, fake.getUserProfileDirectoryArgsForCall[i].dirLen
}

func (fake *FakeSyscall) GetUserProfileDirectoryReturns(result1 error) {
	fake.GetUserProfileDirectoryStub = nil
	fake.getUserProfileDirectoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) GetUserProfileDirectoryReturnsOnCall(i int, result1 error) {
	fake.GetUserProfileDirectoryStub = nil
	if fake.getUserProfileDirectoryReturnsOnCall == nil {
		fake.getUserProfileDirectoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getUserProfileDirectoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSyscall) NsecToFiletime(nsec int64) (ft syscall.Filetime) {
	fake.nsecToFiletimeMutex.Lock()
	ret, specificReturn := fake.nsecToFiletimeReturnsOnCall[len(fake.nsecToFiletimeArgsForCall)]
	fake.nsecToFiletimeArgsForCall = append(fake.nsecToFiletimeArgsForCall, struct {
		nsec int64
	}{nsec})
	fake.recordInvocation("NsecToFiletime", []interface{}{nsec})
	fake.nsecToFiletimeMutex.Unlock()
	if fake.NsecToFiletimeStub != nil {
		return fake.NsecToFiletimeStub(nsec)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nsecToFiletimeReturns.result1
}

func (fake *FakeSyscall) NsecToFiletimeCallCount() int {
	fake.nsecToFiletimeMutex.RLock()
	defer fake.nsecToFiletimeMutex.RUnlock()
	return len(fake.nsecToFiletimeArgsForCall)
}

func (fake *FakeSyscall) NsecToFiletimeArgsForCall(i int) int64 {
	fake.nsecToFiletimeMutex.RLock()
	defer fake.nsecToFiletimeMutex.RUnlock()
	return fake.nsecToFiletimeArgsForCall[i].nsec
}

func (fake *FakeSyscall) NsecToFiletimeReturns(result1 syscall.Filetime) {
	fake.NsecToFiletimeStub = nil
	fake.nsecToFiletimeReturns = struct {
		result1 syscall.Filetime
	}{result1}
}

func (fake *FakeSyscall) NsecToFiletimeReturnsOnCall(i int, result1 syscall.Filetime) {
	fake.NsecToFiletimeStub = nil
	if fake.nsecToFiletimeReturnsOnCall == nil {
		fake.nsecToFiletimeReturnsOnCall = make(map[int]struct {
			result1 syscall.Filetime
		})
	}
	fake.nsecToFiletimeReturnsOnCall[i] = struct {
		result1 syscall.Filetime
	}{result1}
}

func (fake *FakeSyscall) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.bpfStmtMutex.RLock()
	defer fake.bpfStmtMutex.RUnlock()
	fake.bpfJumpMutex.RLock()
	defer fake.bpfJumpMutex.RUnlock()
	fake.bpfBuflenMutex.RLock()
	defer fake.bpfBuflenMutex.RUnlock()
	fake.setBpfBuflenMutex.RLock()
	defer fake.setBpfBuflenMutex.RUnlock()
	fake.bpfDatalinkMutex.RLock()
	defer fake.bpfDatalinkMutex.RUnlock()
	fake.setBpfDatalinkMutex.RLock()
	defer fake.setBpfDatalinkMutex.RUnlock()
	fake.setBpfPromiscMutex.RLock()
	defer fake.setBpfPromiscMutex.RUnlock()
	fake.flushBpfMutex.RLock()
	defer fake.flushBpfMutex.RUnlock()
	fake.bpfInterfaceMutex.RLock()
	defer fake.bpfInterfaceMutex.RUnlock()
	fake.setBpfInterfaceMutex.RLock()
	defer fake.setBpfInterfaceMutex.RUnlock()
	fake.bpfTimeoutMutex.RLock()
	defer fake.bpfTimeoutMutex.RUnlock()
	fake.setBpfTimeoutMutex.RLock()
	defer fake.setBpfTimeoutMutex.RUnlock()
	fake.bpfStatsMutex.RLock()
	defer fake.bpfStatsMutex.RUnlock()
	fake.setBpfImmediateMutex.RLock()
	defer fake.setBpfImmediateMutex.RUnlock()
	fake.setBpfMutex.RLock()
	defer fake.setBpfMutex.RUnlock()
	fake.checkBpfVersionMutex.RLock()
	defer fake.checkBpfVersionMutex.RUnlock()
	fake.bpfHeadercmplMutex.RLock()
	defer fake.bpfHeadercmplMutex.RUnlock()
	fake.setBpfHeadercmplMutex.RLock()
	defer fake.setBpfHeadercmplMutex.RUnlock()
	fake.unmarshalDirMutex.RLock()
	defer fake.unmarshalDirMutex.RUnlock()
	fake.parseDirentMutex.RLock()
	defer fake.parseDirentMutex.RUnlock()
	fake.syscallMutex.RLock()
	defer fake.syscallMutex.RUnlock()
	fake.syscall6Mutex.RLock()
	defer fake.syscall6Mutex.RUnlock()
	fake.syscall9Mutex.RLock()
	defer fake.syscall9Mutex.RUnlock()
	fake.syscall12Mutex.RLock()
	defer fake.syscall12Mutex.RUnlock()
	fake.syscall15Mutex.RLock()
	defer fake.syscall15Mutex.RUnlock()
	fake.loadDLLMutex.RLock()
	defer fake.loadDLLMutex.RUnlock()
	fake.mustLoadDLLMutex.RLock()
	defer fake.mustLoadDLLMutex.RUnlock()
	fake.newLazyDLLMutex.RLock()
	defer fake.newLazyDLLMutex.RUnlock()
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	fake.stringSlicePtrMutex.RLock()
	defer fake.stringSlicePtrMutex.RUnlock()
	fake.slicePtrFromStringsMutex.RLock()
	defer fake.slicePtrFromStringsMutex.RUnlock()
	fake.forkExecMutex.RLock()
	defer fake.forkExecMutex.RUnlock()
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	fake.waitProcessMutex.RLock()
	defer fake.waitProcessMutex.RUnlock()
	fake.closeOnExecMutex.RLock()
	defer fake.closeOnExecMutex.RUnlock()
	fake.setNonblockMutex.RLock()
	defer fake.setNonblockMutex.RUnlock()
	fake.escapeArgMutex.RLock()
	defer fake.escapeArgMutex.RUnlock()
	fake.fullPathMutex.RLock()
	defer fake.fullPathMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.dupMutex.RLock()
	defer fake.dupMutex.RUnlock()
	fake.dup2Mutex.RLock()
	defer fake.dup2Mutex.RUnlock()
	fake.fstatMutex.RLock()
	defer fake.fstatMutex.RUnlock()
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	fake.preadMutex.RLock()
	defer fake.preadMutex.RUnlock()
	fake.pwriteMutex.RLock()
	defer fake.pwriteMutex.RUnlock()
	fake.seekMutex.RLock()
	defer fake.seekMutex.RUnlock()
	fake.pipeMutex.RLock()
	defer fake.pipeMutex.RUnlock()
	fake.fcntlFlockMutex.RLock()
	defer fake.fcntlFlockMutex.RUnlock()
	fake.readDirentMutex.RLock()
	defer fake.readDirentMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	fake.getcwdMutex.RLock()
	defer fake.getcwdMutex.RUnlock()
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	fake.unlinkMutex.RLock()
	defer fake.unlinkMutex.RUnlock()
	fake.rmdirMutex.RLock()
	defer fake.rmdirMutex.RUnlock()
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	fake.fchmodMutex.RLock()
	defer fake.fchmodMutex.RUnlock()
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	fake.fchownMutex.RLock()
	defer fake.fchownMutex.RUnlock()
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	fake.utimesNanoMutex.RLock()
	defer fake.utimesNanoMutex.RUnlock()
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	fake.ftruncateMutex.RLock()
	defer fake.ftruncateMutex.RUnlock()
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	fake.fchdirMutex.RLock()
	defer fake.fchdirMutex.RUnlock()
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	fake.fsyncMutex.RLock()
	defer fake.fsyncMutex.RUnlock()
	fake.lsfStmtMutex.RLock()
	defer fake.lsfStmtMutex.RUnlock()
	fake.lsfJumpMutex.RLock()
	defer fake.lsfJumpMutex.RUnlock()
	fake.lsfSocketMutex.RLock()
	defer fake.lsfSocketMutex.RUnlock()
	fake.setLsfPromiscMutex.RLock()
	defer fake.setLsfPromiscMutex.RUnlock()
	fake.attachLsfMutex.RLock()
	defer fake.attachLsfMutex.RUnlock()
	fake.detachLsfMutex.RLock()
	defer fake.detachLsfMutex.RUnlock()
	fake.parseFilesMutex.RLock()
	defer fake.parseFilesMutex.RUnlock()
	fake.socketMutex.RLock()
	defer fake.socketMutex.RUnlock()
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	fake.stopIOMutex.RLock()
	defer fake.stopIOMutex.RUnlock()
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	fake.getsocknameMutex.RLock()
	defer fake.getsocknameMutex.RUnlock()
	fake.getpeernameMutex.RLock()
	defer fake.getpeernameMutex.RUnlock()
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	fake.recvfromMutex.RLock()
	defer fake.recvfromMutex.RUnlock()
	fake.sendtoMutex.RLock()
	defer fake.sendtoMutex.RUnlock()
	fake.recvmsgMutex.RLock()
	defer fake.recvmsgMutex.RUnlock()
	fake.sendmsgMutex.RLock()
	defer fake.sendmsgMutex.RUnlock()
	fake.sendmsgNMutex.RLock()
	defer fake.sendmsgNMutex.RUnlock()
	fake.getsockoptIntMutex.RLock()
	defer fake.getsockoptIntMutex.RUnlock()
	fake.setsockoptIntMutex.RLock()
	defer fake.setsockoptIntMutex.RUnlock()
	fake.setsockoptByteMutex.RLock()
	defer fake.setsockoptByteMutex.RUnlock()
	fake.setsockoptLingerMutex.RLock()
	defer fake.setsockoptLingerMutex.RUnlock()
	fake.setReadDeadlineMutex.RLock()
	defer fake.setReadDeadlineMutex.RUnlock()
	fake.setWriteDeadlineMutex.RLock()
	defer fake.setWriteDeadlineMutex.RUnlock()
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	fake.setsockoptICMPv6FilterMutex.RLock()
	defer fake.setsockoptICMPv6FilterMutex.RUnlock()
	fake.setsockoptIPMreqMutex.RLock()
	defer fake.setsockoptIPMreqMutex.RUnlock()
	fake.setsockoptIPv6MreqMutex.RLock()
	defer fake.setsockoptIPv6MreqMutex.RUnlock()
	fake.setsockoptInet4AddrMutex.RLock()
	defer fake.setsockoptInet4AddrMutex.RUnlock()
	fake.setsockoptStringMutex.RLock()
	defer fake.setsockoptStringMutex.RUnlock()
	fake.setsockoptTimevalMutex.RLock()
	defer fake.setsockoptTimevalMutex.RUnlock()
	fake.socketpairMutex.RLock()
	defer fake.socketpairMutex.RUnlock()
	fake.netlinkRIBMutex.RLock()
	defer fake.netlinkRIBMutex.RUnlock()
	fake.parseNetlinkMessageMutex.RLock()
	defer fake.parseNetlinkMessageMutex.RUnlock()
	fake.parseNetlinkRouteAttrMutex.RLock()
	defer fake.parseNetlinkRouteAttrMutex.RUnlock()
	fake.fixwdMutex.RLock()
	defer fake.fixwdMutex.RUnlock()
	fake.getwdMutex.RLock()
	defer fake.getwdMutex.RUnlock()
	fake.routeRIBMutex.RLock()
	defer fake.routeRIBMutex.RUnlock()
	fake.parseRoutingMessageMutex.RLock()
	defer fake.parseRoutingMessageMutex.RUnlock()
	fake.parseRoutingSockaddrMutex.RLock()
	defer fake.parseRoutingSockaddrMutex.RUnlock()
	fake.translateAccountNameMutex.RLock()
	defer fake.translateAccountNameMutex.RUnlock()
	fake.stringToSidMutex.RLock()
	defer fake.stringToSidMutex.RUnlock()
	fake.lookupSIDMutex.RLock()
	defer fake.lookupSIDMutex.RUnlock()
	fake.openCurrentProcessTokenMutex.RLock()
	defer fake.openCurrentProcessTokenMutex.RUnlock()
	fake.unixCredentialsMutex.RLock()
	defer fake.unixCredentialsMutex.RUnlock()
	fake.parseUnixCredentialsMutex.RLock()
	defer fake.parseUnixCredentialsMutex.RUnlock()
	fake.cmsgLenMutex.RLock()
	defer fake.cmsgLenMutex.RUnlock()
	fake.cmsgSpaceMutex.RLock()
	defer fake.cmsgSpaceMutex.RUnlock()
	fake.parseSocketControlMessageMutex.RLock()
	defer fake.parseSocketControlMessageMutex.RUnlock()
	fake.unixRightsMutex.RLock()
	defer fake.unixRightsMutex.RUnlock()
	fake.parseUnixRightsMutex.RLock()
	defer fake.parseUnixRightsMutex.RUnlock()
	fake.stringByteSliceMutex.RLock()
	defer fake.stringByteSliceMutex.RUnlock()
	fake.byteSliceFromStringMutex.RLock()
	defer fake.byteSliceFromStringMutex.RUnlock()
	fake.stringBytePtrMutex.RLock()
	defer fake.stringBytePtrMutex.RUnlock()
	fake.bytePtrFromStringMutex.RLock()
	defer fake.bytePtrFromStringMutex.RUnlock()
	fake.getpagesizeMutex.RLock()
	defer fake.getpagesizeMutex.RUnlock()
	fake.getgroupsMutex.RLock()
	defer fake.getgroupsMutex.RUnlock()
	fake.setgroupsMutex.RLock()
	defer fake.setgroupsMutex.RUnlock()
	fake.wait4Mutex.RLock()
	defer fake.wait4Mutex.RUnlock()
	fake.getsockoptByteMutex.RLock()
	defer fake.getsockoptByteMutex.RUnlock()
	fake.getsockoptInet4AddrMutex.RLock()
	defer fake.getsockoptInet4AddrMutex.RUnlock()
	fake.getsockoptIPMreqMutex.RLock()
	defer fake.getsockoptIPMreqMutex.RUnlock()
	fake.getsockoptIPv6MreqMutex.RLock()
	defer fake.getsockoptIPv6MreqMutex.RUnlock()
	fake.getsockoptIPv6MTUInfoMutex.RLock()
	defer fake.getsockoptIPv6MTUInfoMutex.RUnlock()
	fake.getsockoptICMPv6FilterMutex.RLock()
	defer fake.getsockoptICMPv6FilterMutex.RUnlock()
	fake.keventMutex.RLock()
	defer fake.keventMutex.RUnlock()
	fake.sysctlMutex.RLock()
	defer fake.sysctlMutex.RUnlock()
	fake.sysctlUint32Mutex.RLock()
	defer fake.sysctlUint32Mutex.RUnlock()
	fake.utimesMutex.RLock()
	defer fake.utimesMutex.RUnlock()
	fake.futimesMutex.RLock()
	defer fake.futimesMutex.RUnlock()
	fake.mmapMutex.RLock()
	defer fake.mmapMutex.RUnlock()
	fake.munmapMutex.RLock()
	defer fake.munmapMutex.RUnlock()
	fake.ptraceAttachMutex.RLock()
	defer fake.ptraceAttachMutex.RUnlock()
	fake.ptraceDetachMutex.RLock()
	defer fake.ptraceDetachMutex.RUnlock()
	fake.getfsstatMutex.RLock()
	defer fake.getfsstatMutex.RUnlock()
	fake.killMutex.RLock()
	defer fake.killMutex.RUnlock()
	fake.gettimeofdayMutex.RLock()
	defer fake.gettimeofdayMutex.RUnlock()
	fake.setKeventMutex.RLock()
	defer fake.setKeventMutex.RUnlock()
	fake.getsockoptIPMreqnMutex.RLock()
	defer fake.getsockoptIPMreqnMutex.RUnlock()
	fake.setsockoptIPMreqnMutex.RLock()
	defer fake.setsockoptIPMreqnMutex.RUnlock()
	fake.accept4Mutex.RLock()
	defer fake.accept4Mutex.RUnlock()
	fake.accessMutex.RLock()
	defer fake.accessMutex.RUnlock()
	fake.creatMutex.RLock()
	defer fake.creatMutex.RUnlock()
	fake.mknodMutex.RLock()
	defer fake.mknodMutex.RUnlock()
	fake.openatMutex.RLock()
	defer fake.openatMutex.RUnlock()
	fake.unlinkatMutex.RLock()
	defer fake.unlinkatMutex.RUnlock()
	fake.futimesatMutex.RLock()
	defer fake.futimesatMutex.RUnlock()
	fake.mkfifoMutex.RLock()
	defer fake.mkfifoMutex.RUnlock()
	fake.getsockoptUcredMutex.RLock()
	defer fake.getsockoptUcredMutex.RUnlock()
	fake.bindToDeviceMutex.RLock()
	defer fake.bindToDeviceMutex.RUnlock()
	fake.ptracePeekTextMutex.RLock()
	defer fake.ptracePeekTextMutex.RUnlock()
	fake.ptracePeekDataMutex.RLock()
	defer fake.ptracePeekDataMutex.RUnlock()
	fake.ptracePokeTextMutex.RLock()
	defer fake.ptracePokeTextMutex.RUnlock()
	fake.ptracePokeDataMutex.RLock()
	defer fake.ptracePokeDataMutex.RUnlock()
	fake.ptraceGetRegsMutex.RLock()
	defer fake.ptraceGetRegsMutex.RUnlock()
	fake.ptraceSetRegsMutex.RLock()
	defer fake.ptraceSetRegsMutex.RUnlock()
	fake.ptraceSetOptionsMutex.RLock()
	defer fake.ptraceSetOptionsMutex.RUnlock()
	fake.ptraceGetEventMsgMutex.RLock()
	defer fake.ptraceGetEventMsgMutex.RUnlock()
	fake.ptraceContMutex.RLock()
	defer fake.ptraceContMutex.RUnlock()
	fake.ptraceSyscallMutex.RLock()
	defer fake.ptraceSyscallMutex.RUnlock()
	fake.ptraceSingleStepMutex.RLock()
	defer fake.ptraceSingleStepMutex.RUnlock()
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	fake.mountMutex.RLock()
	defer fake.mountMutex.RUnlock()
	fake.getpgrpMutex.RLock()
	defer fake.getpgrpMutex.RUnlock()
	fake.setuidMutex.RLock()
	defer fake.setuidMutex.RUnlock()
	fake.setgidMutex.RLock()
	defer fake.setgidMutex.RUnlock()
	fake.pipe2Mutex.RLock()
	defer fake.pipe2Mutex.RUnlock()
	fake.getrlimitMutex.RLock()
	defer fake.getrlimitMutex.RUnlock()
	fake.setrlimitMutex.RLock()
	defer fake.setrlimitMutex.RUnlock()
	fake.fstatfsMutex.RLock()
	defer fake.fstatfsMutex.RUnlock()
	fake.statfsMutex.RLock()
	defer fake.statfsMutex.RUnlock()
	fake.timeMutex.RLock()
	defer fake.timeMutex.RUnlock()
	fake.inotifyInitMutex.RLock()
	defer fake.inotifyInitMutex.RUnlock()
	fake.iopermMutex.RLock()
	defer fake.iopermMutex.RUnlock()
	fake.ioplMutex.RLock()
	defer fake.ioplMutex.RUnlock()
	fake.rawSyscallMutex.RLock()
	defer fake.rawSyscallMutex.RUnlock()
	fake.rawSyscall6Mutex.RLock()
	defer fake.rawSyscall6Mutex.RUnlock()
	fake.getegidMutex.RLock()
	defer fake.getegidMutex.RUnlock()
	fake.geteuidMutex.RLock()
	defer fake.geteuidMutex.RUnlock()
	fake.getgidMutex.RLock()
	defer fake.getgidMutex.RUnlock()
	fake.getppidMutex.RLock()
	defer fake.getppidMutex.RUnlock()
	fake.getpidMutex.RLock()
	defer fake.getpidMutex.RUnlock()
	fake.getuidMutex.RLock()
	defer fake.getuidMutex.RUnlock()
	fake.sendfileMutex.RLock()
	defer fake.sendfileMutex.RUnlock()
	fake.getdirentriesMutex.RLock()
	defer fake.getdirentriesMutex.RUnlock()
	fake.newErrorMutex.RLock()
	defer fake.newErrorMutex.RUnlock()
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	fake.fd2pathMutex.RLock()
	defer fake.fd2pathMutex.RUnlock()
	fake.awaitMutex.RLock()
	defer fake.awaitMutex.RUnlock()
	fake.unmountMutex.RLock()
	defer fake.unmountMutex.RUnlock()
	fake.nsecToTimevalMutex.RLock()
	defer fake.nsecToTimevalMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.wstatMutex.RLock()
	defer fake.wstatMutex.RUnlock()
	fake.gethostnameMutex.RLock()
	defer fake.gethostnameMutex.RUnlock()
	fake.getexecnameMutex.RLock()
	defer fake.getexecnameMutex.RUnlock()
	fake.stringToUTF16Mutex.RLock()
	defer fake.stringToUTF16Mutex.RUnlock()
	fake.uTF16FromStringMutex.RLock()
	defer fake.uTF16FromStringMutex.RUnlock()
	fake.uTF16ToStringMutex.RLock()
	defer fake.uTF16ToStringMutex.RUnlock()
	fake.stringToUTF16PtrMutex.RLock()
	defer fake.stringToUTF16PtrMutex.RUnlock()
	fake.uTF16PtrFromStringMutex.RLock()
	defer fake.uTF16PtrFromStringMutex.RUnlock()
	fake.formatMessageMutex.RLock()
	defer fake.formatMessageMutex.RUnlock()
	fake.newCallbackMutex.RLock()
	defer fake.newCallbackMutex.RUnlock()
	fake.newCallbackCDeclMutex.RLock()
	defer fake.newCallbackCDeclMutex.RUnlock()
	fake.computerNameMutex.RLock()
	defer fake.computerNameMutex.RUnlock()
	fake.loadCancelIoExMutex.RLock()
	defer fake.loadCancelIoExMutex.RUnlock()
	fake.loadSetFileCompletionNotificationModesMutex.RLock()
	defer fake.loadSetFileCompletionNotificationModesMutex.RUnlock()
	fake.wSASendtoMutex.RLock()
	defer fake.wSASendtoMutex.RUnlock()
	fake.loadGetAddrInfoMutex.RLock()
	defer fake.loadGetAddrInfoMutex.RUnlock()
	fake.loadConnectExMutex.RLock()
	defer fake.loadConnectExMutex.RUnlock()
	fake.connectExMutex.RLock()
	defer fake.connectExMutex.RUnlock()
	fake.timespecToNsecMutex.RLock()
	defer fake.timespecToNsecMutex.RUnlock()
	fake.nsecToTimespecMutex.RLock()
	defer fake.nsecToTimespecMutex.RUnlock()
	fake.findFirstFileMutex.RLock()
	defer fake.findFirstFileMutex.RUnlock()
	fake.findNextFileMutex.RLock()
	defer fake.findNextFileMutex.RUnlock()
	fake.loadCreateSymbolicLinkMutex.RLock()
	defer fake.loadCreateSymbolicLinkMutex.RUnlock()
	fake.timevalToNsecMutex.RLock()
	defer fake.timevalToNsecMutex.RUnlock()
	fake.adjtimeMutex.RLock()
	defer fake.adjtimeMutex.RUnlock()
	fake.chflagsMutex.RLock()
	defer fake.chflagsMutex.RUnlock()
	fake.chrootMutex.RLock()
	defer fake.chrootMutex.RUnlock()
	fake.exchangedataMutex.RLock()
	defer fake.exchangedataMutex.RUnlock()
	fake.fchflagsMutex.RLock()
	defer fake.fchflagsMutex.RUnlock()
	fake.flockMutex.RLock()
	defer fake.flockMutex.RUnlock()
	fake.fpathconfMutex.RLock()
	defer fake.fpathconfMutex.RUnlock()
	fake.getdtablesizeMutex.RLock()
	defer fake.getdtablesizeMutex.RUnlock()
	fake.getpgidMutex.RLock()
	defer fake.getpgidMutex.RUnlock()
	fake.getpriorityMutex.RLock()
	defer fake.getpriorityMutex.RUnlock()
	fake.getrusageMutex.RLock()
	defer fake.getrusageMutex.RUnlock()
	fake.getsidMutex.RLock()
	defer fake.getsidMutex.RUnlock()
	fake.issetugidMutex.RLock()
	defer fake.issetugidMutex.RUnlock()
	fake.kqueueMutex.RLock()
	defer fake.kqueueMutex.RUnlock()
	fake.mlockMutex.RLock()
	defer fake.mlockMutex.RUnlock()
	fake.mlockallMutex.RLock()
	defer fake.mlockallMutex.RUnlock()
	fake.mprotectMutex.RLock()
	defer fake.mprotectMutex.RUnlock()
	fake.munlockMutex.RLock()
	defer fake.munlockMutex.RUnlock()
	fake.munlockallMutex.RLock()
	defer fake.munlockallMutex.RUnlock()
	fake.pathconfMutex.RLock()
	defer fake.pathconfMutex.RUnlock()
	fake.revokeMutex.RLock()
	defer fake.revokeMutex.RUnlock()
	fake.selectMutex.RLock()
	defer fake.selectMutex.RUnlock()
	fake.setegidMutex.RLock()
	defer fake.setegidMutex.RUnlock()
	fake.seteuidMutex.RLock()
	defer fake.seteuidMutex.RUnlock()
	fake.setloginMutex.RLock()
	defer fake.setloginMutex.RUnlock()
	fake.setpgidMutex.RLock()
	defer fake.setpgidMutex.RUnlock()
	fake.setpriorityMutex.RLock()
	defer fake.setpriorityMutex.RUnlock()
	fake.setprivexecMutex.RLock()
	defer fake.setprivexecMutex.RUnlock()
	fake.setregidMutex.RLock()
	defer fake.setregidMutex.RUnlock()
	fake.setreuidMutex.RLock()
	defer fake.setreuidMutex.RUnlock()
	fake.setsidMutex.RLock()
	defer fake.setsidMutex.RUnlock()
	fake.settimeofdayMutex.RLock()
	defer fake.settimeofdayMutex.RUnlock()
	fake.syncMutex.RLock()
	defer fake.syncMutex.RUnlock()
	fake.umaskMutex.RLock()
	defer fake.umaskMutex.RUnlock()
	fake.undeleteMutex.RLock()
	defer fake.undeleteMutex.RUnlock()
	fake.nanosleepMutex.RLock()
	defer fake.nanosleepMutex.RUnlock()
	fake.acctMutex.RLock()
	defer fake.acctMutex.RUnlock()
	fake.adjtimexMutex.RLock()
	defer fake.adjtimexMutex.RUnlock()
	fake.dup3Mutex.RLock()
	defer fake.dup3Mutex.RUnlock()
	fake.epollCreateMutex.RLock()
	defer fake.epollCreateMutex.RUnlock()
	fake.epollCreate1Mutex.RLock()
	defer fake.epollCreate1Mutex.RUnlock()
	fake.epollCtlMutex.RLock()
	defer fake.epollCtlMutex.RUnlock()
	fake.epollWaitMutex.RLock()
	defer fake.epollWaitMutex.RUnlock()
	fake.faccessatMutex.RLock()
	defer fake.faccessatMutex.RUnlock()
	fake.fallocateMutex.RLock()
	defer fake.fallocateMutex.RUnlock()
	fake.fchmodatMutex.RLock()
	defer fake.fchmodatMutex.RUnlock()
	fake.fchownatMutex.RLock()
	defer fake.fchownatMutex.RUnlock()
	fake.fdatasyncMutex.RLock()
	defer fake.fdatasyncMutex.RUnlock()
	fake.getdentsMutex.RLock()
	defer fake.getdentsMutex.RUnlock()
	fake.gettidMutex.RLock()
	defer fake.gettidMutex.RUnlock()
	fake.getxattrMutex.RLock()
	defer fake.getxattrMutex.RUnlock()
	fake.inotifyAddWatchMutex.RLock()
	defer fake.inotifyAddWatchMutex.RUnlock()
	fake.inotifyInit1Mutex.RLock()
	defer fake.inotifyInit1Mutex.RUnlock()
	fake.inotifyRmWatchMutex.RLock()
	defer fake.inotifyRmWatchMutex.RUnlock()
	fake.klogctlMutex.RLock()
	defer fake.klogctlMutex.RUnlock()
	fake.listxattrMutex.RLock()
	defer fake.listxattrMutex.RUnlock()
	fake.mkdiratMutex.RLock()
	defer fake.mkdiratMutex.RUnlock()
	fake.mknodatMutex.RLock()
	defer fake.mknodatMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.pivotRootMutex.RLock()
	defer fake.pivotRootMutex.RUnlock()
	fake.removexattrMutex.RLock()
	defer fake.removexattrMutex.RUnlock()
	fake.renameatMutex.RLock()
	defer fake.renameatMutex.RUnlock()
	fake.setdomainnameMutex.RLock()
	defer fake.setdomainnameMutex.RUnlock()
	fake.sethostnameMutex.RLock()
	defer fake.sethostnameMutex.RUnlock()
	fake.setxattrMutex.RLock()
	defer fake.setxattrMutex.RUnlock()
	fake.sysinfoMutex.RLock()
	defer fake.sysinfoMutex.RUnlock()
	fake.teeMutex.RLock()
	defer fake.teeMutex.RUnlock()
	fake.tgkillMutex.RLock()
	defer fake.tgkillMutex.RUnlock()
	fake.timesMutex.RLock()
	defer fake.timesMutex.RUnlock()
	fake.unameMutex.RLock()
	defer fake.unameMutex.RUnlock()
	fake.unshareMutex.RLock()
	defer fake.unshareMutex.RUnlock()
	fake.ustatMutex.RLock()
	defer fake.ustatMutex.RUnlock()
	fake.utimeMutex.RLock()
	defer fake.utimeMutex.RUnlock()
	fake.madviseMutex.RLock()
	defer fake.madviseMutex.RUnlock()
	fake.setfsgidMutex.RLock()
	defer fake.setfsgidMutex.RUnlock()
	fake.setfsuidMutex.RLock()
	defer fake.setfsuidMutex.RUnlock()
	fake.setresgidMutex.RLock()
	defer fake.setresgidMutex.RUnlock()
	fake.setresuidMutex.RLock()
	defer fake.setresuidMutex.RUnlock()
	fake.spliceMutex.RLock()
	defer fake.spliceMutex.RUnlock()
	fake.syncFileRangeMutex.RLock()
	defer fake.syncFileRangeMutex.RUnlock()
	fake.fstatatMutex.RLock()
	defer fake.fstatatMutex.RUnlock()
	fake.fwstatMutex.RLock()
	defer fake.fwstatMutex.RUnlock()
	fake.getLastErrorMutex.RLock()
	defer fake.getLastErrorMutex.RUnlock()
	fake.loadLibraryMutex.RLock()
	defer fake.loadLibraryMutex.RUnlock()
	fake.freeLibraryMutex.RLock()
	defer fake.freeLibraryMutex.RUnlock()
	fake.getProcAddressMutex.RLock()
	defer fake.getProcAddressMutex.RUnlock()
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	fake.exitProcessMutex.RLock()
	defer fake.exitProcessMutex.RUnlock()
	fake.createFileMutex.RLock()
	defer fake.createFileMutex.RUnlock()
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	fake.setFilePointerMutex.RLock()
	defer fake.setFilePointerMutex.RUnlock()
	fake.closeHandleMutex.RLock()
	defer fake.closeHandleMutex.RUnlock()
	fake.getStdHandleMutex.RLock()
	defer fake.getStdHandleMutex.RUnlock()
	fake.findCloseMutex.RLock()
	defer fake.findCloseMutex.RUnlock()
	fake.getFileInformationByHandleMutex.RLock()
	defer fake.getFileInformationByHandleMutex.RUnlock()
	fake.getCurrentDirectoryMutex.RLock()
	defer fake.getCurrentDirectoryMutex.RUnlock()
	fake.setCurrentDirectoryMutex.RLock()
	defer fake.setCurrentDirectoryMutex.RUnlock()
	fake.createDirectoryMutex.RLock()
	defer fake.createDirectoryMutex.RUnlock()
	fake.removeDirectoryMutex.RLock()
	defer fake.removeDirectoryMutex.RUnlock()
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	fake.moveFileMutex.RLock()
	defer fake.moveFileMutex.RUnlock()
	fake.getComputerNameMutex.RLock()
	defer fake.getComputerNameMutex.RUnlock()
	fake.setEndOfFileMutex.RLock()
	defer fake.setEndOfFileMutex.RUnlock()
	fake.getSystemTimeAsFileTimeMutex.RLock()
	defer fake.getSystemTimeAsFileTimeMutex.RUnlock()
	fake.getTimeZoneInformationMutex.RLock()
	defer fake.getTimeZoneInformationMutex.RUnlock()
	fake.createIoCompletionPortMutex.RLock()
	defer fake.createIoCompletionPortMutex.RUnlock()
	fake.getQueuedCompletionStatusMutex.RLock()
	defer fake.getQueuedCompletionStatusMutex.RUnlock()
	fake.postQueuedCompletionStatusMutex.RLock()
	defer fake.postQueuedCompletionStatusMutex.RUnlock()
	fake.cancelIoMutex.RLock()
	defer fake.cancelIoMutex.RUnlock()
	fake.cancelIoExMutex.RLock()
	defer fake.cancelIoExMutex.RUnlock()
	fake.createProcessMutex.RLock()
	defer fake.createProcessMutex.RUnlock()
	fake.openProcessMutex.RLock()
	defer fake.openProcessMutex.RUnlock()
	fake.terminateProcessMutex.RLock()
	defer fake.terminateProcessMutex.RUnlock()
	fake.getExitCodeProcessMutex.RLock()
	defer fake.getExitCodeProcessMutex.RUnlock()
	fake.getStartupInfoMutex.RLock()
	defer fake.getStartupInfoMutex.RUnlock()
	fake.getCurrentProcessMutex.RLock()
	defer fake.getCurrentProcessMutex.RUnlock()
	fake.getProcessTimesMutex.RLock()
	defer fake.getProcessTimesMutex.RUnlock()
	fake.duplicateHandleMutex.RLock()
	defer fake.duplicateHandleMutex.RUnlock()
	fake.waitForSingleObjectMutex.RLock()
	defer fake.waitForSingleObjectMutex.RUnlock()
	fake.getTempPathMutex.RLock()
	defer fake.getTempPathMutex.RUnlock()
	fake.createPipeMutex.RLock()
	defer fake.createPipeMutex.RUnlock()
	fake.getFileTypeMutex.RLock()
	defer fake.getFileTypeMutex.RUnlock()
	fake.cryptAcquireContextMutex.RLock()
	defer fake.cryptAcquireContextMutex.RUnlock()
	fake.cryptReleaseContextMutex.RLock()
	defer fake.cryptReleaseContextMutex.RUnlock()
	fake.cryptGenRandomMutex.RLock()
	defer fake.cryptGenRandomMutex.RUnlock()
	fake.getEnvironmentStringsMutex.RLock()
	defer fake.getEnvironmentStringsMutex.RUnlock()
	fake.freeEnvironmentStringsMutex.RLock()
	defer fake.freeEnvironmentStringsMutex.RUnlock()
	fake.getEnvironmentVariableMutex.RLock()
	defer fake.getEnvironmentVariableMutex.RUnlock()
	fake.setEnvironmentVariableMutex.RLock()
	defer fake.setEnvironmentVariableMutex.RUnlock()
	fake.setFileTimeMutex.RLock()
	defer fake.setFileTimeMutex.RUnlock()
	fake.getFileAttributesMutex.RLock()
	defer fake.getFileAttributesMutex.RUnlock()
	fake.setFileAttributesMutex.RLock()
	defer fake.setFileAttributesMutex.RUnlock()
	fake.getFileAttributesExMutex.RLock()
	defer fake.getFileAttributesExMutex.RUnlock()
	fake.getCommandLineMutex.RLock()
	defer fake.getCommandLineMutex.RUnlock()
	fake.commandLineToArgvMutex.RLock()
	defer fake.commandLineToArgvMutex.RUnlock()
	fake.localFreeMutex.RLock()
	defer fake.localFreeMutex.RUnlock()
	fake.setHandleInformationMutex.RLock()
	defer fake.setHandleInformationMutex.RUnlock()
	fake.flushFileBuffersMutex.RLock()
	defer fake.flushFileBuffersMutex.RUnlock()
	fake.getFullPathNameMutex.RLock()
	defer fake.getFullPathNameMutex.RUnlock()
	fake.getLongPathNameMutex.RLock()
	defer fake.getLongPathNameMutex.RUnlock()
	fake.getShortPathNameMutex.RLock()
	defer fake.getShortPathNameMutex.RUnlock()
	fake.createFileMappingMutex.RLock()
	defer fake.createFileMappingMutex.RUnlock()
	fake.mapViewOfFileMutex.RLock()
	defer fake.mapViewOfFileMutex.RUnlock()
	fake.unmapViewOfFileMutex.RLock()
	defer fake.unmapViewOfFileMutex.RUnlock()
	fake.flushViewOfFileMutex.RLock()
	defer fake.flushViewOfFileMutex.RUnlock()
	fake.virtualLockMutex.RLock()
	defer fake.virtualLockMutex.RUnlock()
	fake.virtualUnlockMutex.RLock()
	defer fake.virtualUnlockMutex.RUnlock()
	fake.transmitFileMutex.RLock()
	defer fake.transmitFileMutex.RUnlock()
	fake.readDirectoryChangesMutex.RLock()
	defer fake.readDirectoryChangesMutex.RUnlock()
	fake.certOpenSystemStoreMutex.RLock()
	defer fake.certOpenSystemStoreMutex.RUnlock()
	fake.certOpenStoreMutex.RLock()
	defer fake.certOpenStoreMutex.RUnlock()
	fake.certEnumCertificatesInStoreMutex.RLock()
	defer fake.certEnumCertificatesInStoreMutex.RUnlock()
	fake.certAddCertificateContextToStoreMutex.RLock()
	defer fake.certAddCertificateContextToStoreMutex.RUnlock()
	fake.certCloseStoreMutex.RLock()
	defer fake.certCloseStoreMutex.RUnlock()
	fake.certGetCertificateChainMutex.RLock()
	defer fake.certGetCertificateChainMutex.RUnlock()
	fake.certFreeCertificateChainMutex.RLock()
	defer fake.certFreeCertificateChainMutex.RUnlock()
	fake.certCreateCertificateContextMutex.RLock()
	defer fake.certCreateCertificateContextMutex.RUnlock()
	fake.certFreeCertificateContextMutex.RLock()
	defer fake.certFreeCertificateContextMutex.RUnlock()
	fake.certVerifyCertificateChainPolicyMutex.RLock()
	defer fake.certVerifyCertificateChainPolicyMutex.RUnlock()
	fake.regOpenKeyExMutex.RLock()
	defer fake.regOpenKeyExMutex.RUnlock()
	fake.regCloseKeyMutex.RLock()
	defer fake.regCloseKeyMutex.RUnlock()
	fake.regQueryInfoKeyMutex.RLock()
	defer fake.regQueryInfoKeyMutex.RUnlock()
	fake.regEnumKeyExMutex.RLock()
	defer fake.regEnumKeyExMutex.RUnlock()
	fake.regQueryValueExMutex.RLock()
	defer fake.regQueryValueExMutex.RUnlock()
	fake.getConsoleModeMutex.RLock()
	defer fake.getConsoleModeMutex.RUnlock()
	fake.writeConsoleMutex.RLock()
	defer fake.writeConsoleMutex.RUnlock()
	fake.readConsoleMutex.RLock()
	defer fake.readConsoleMutex.RUnlock()
	fake.createToolhelp32SnapshotMutex.RLock()
	defer fake.createToolhelp32SnapshotMutex.RUnlock()
	fake.process32FirstMutex.RLock()
	defer fake.process32FirstMutex.RUnlock()
	fake.process32NextMutex.RLock()
	defer fake.process32NextMutex.RUnlock()
	fake.deviceIoControlMutex.RLock()
	defer fake.deviceIoControlMutex.RUnlock()
	fake.createSymbolicLinkMutex.RLock()
	defer fake.createSymbolicLinkMutex.RUnlock()
	fake.createHardLinkMutex.RLock()
	defer fake.createHardLinkMutex.RUnlock()
	fake.wSAStartupMutex.RLock()
	defer fake.wSAStartupMutex.RUnlock()
	fake.wSACleanupMutex.RLock()
	defer fake.wSACleanupMutex.RUnlock()
	fake.wSAIoctlMutex.RLock()
	defer fake.wSAIoctlMutex.RUnlock()
	fake.setsockoptMutex.RLock()
	defer fake.setsockoptMutex.RUnlock()
	fake.getsockoptMutex.RLock()
	defer fake.getsockoptMutex.RUnlock()
	fake.closesocketMutex.RLock()
	defer fake.closesocketMutex.RUnlock()
	fake.acceptExMutex.RLock()
	defer fake.acceptExMutex.RUnlock()
	fake.getAcceptExSockaddrsMutex.RLock()
	defer fake.getAcceptExSockaddrsMutex.RUnlock()
	fake.wSARecvMutex.RLock()
	defer fake.wSARecvMutex.RUnlock()
	fake.wSASendMutex.RLock()
	defer fake.wSASendMutex.RUnlock()
	fake.wSARecvFromMutex.RLock()
	defer fake.wSARecvFromMutex.RUnlock()
	fake.wSASendToMutex.RLock()
	defer fake.wSASendToMutex.RUnlock()
	fake.getHostByNameMutex.RLock()
	defer fake.getHostByNameMutex.RUnlock()
	fake.getServByNameMutex.RLock()
	defer fake.getServByNameMutex.RUnlock()
	fake.ntohsMutex.RLock()
	defer fake.ntohsMutex.RUnlock()
	fake.getProtoByNameMutex.RLock()
	defer fake.getProtoByNameMutex.RUnlock()
	fake.dnsQueryMutex.RLock()
	defer fake.dnsQueryMutex.RUnlock()
	fake.dnsRecordListFreeMutex.RLock()
	defer fake.dnsRecordListFreeMutex.RUnlock()
	fake.dnsNameCompareMutex.RLock()
	defer fake.dnsNameCompareMutex.RUnlock()
	fake.getAddrInfoWMutex.RLock()
	defer fake.getAddrInfoWMutex.RUnlock()
	fake.freeAddrInfoWMutex.RLock()
	defer fake.freeAddrInfoWMutex.RUnlock()
	fake.getIfEntryMutex.RLock()
	defer fake.getIfEntryMutex.RUnlock()
	fake.getAdaptersInfoMutex.RLock()
	defer fake.getAdaptersInfoMutex.RUnlock()
	fake.setFileCompletionNotificationModesMutex.RLock()
	defer fake.setFileCompletionNotificationModesMutex.RUnlock()
	fake.wSAEnumProtocolsMutex.RLock()
	defer fake.wSAEnumProtocolsMutex.RUnlock()
	fake.translateNameMutex.RLock()
	defer fake.translateNameMutex.RUnlock()
	fake.getUserNameExMutex.RLock()
	defer fake.getUserNameExMutex.RUnlock()
	fake.netUserGetInfoMutex.RLock()
	defer fake.netUserGetInfoMutex.RUnlock()
	fake.netGetJoinInformationMutex.RLock()
	defer fake.netGetJoinInformationMutex.RUnlock()
	fake.netApiBufferFreeMutex.RLock()
	defer fake.netApiBufferFreeMutex.RUnlock()
	fake.lookupAccountSidMutex.RLock()
	defer fake.lookupAccountSidMutex.RUnlock()
	fake.lookupAccountNameMutex.RLock()
	defer fake.lookupAccountNameMutex.RUnlock()
	fake.convertSidToStringSidMutex.RLock()
	defer fake.convertSidToStringSidMutex.RUnlock()
	fake.convertStringSidToSidMutex.RLock()
	defer fake.convertStringSidToSidMutex.RUnlock()
	fake.getLengthSidMutex.RLock()
	defer fake.getLengthSidMutex.RUnlock()
	fake.copySidMutex.RLock()
	defer fake.copySidMutex.RUnlock()
	fake.openProcessTokenMutex.RLock()
	defer fake.openProcessTokenMutex.RUnlock()
	fake.getTokenInformationMutex.RLock()
	defer fake.getTokenInformationMutex.RUnlock()
	fake.getUserProfileDirectoryMutex.RLock()
	defer fake.getUserProfileDirectoryMutex.RUnlock()
	fake.nsecToFiletimeMutex.RLock()
	defer fake.nsecToFiletimeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSyscall) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ syscallshim.Syscall = new(FakeSyscall)
