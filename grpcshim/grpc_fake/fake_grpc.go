// Code generated by counterfeiter. DO NOT EDIT.
package grpc_fake

import (
	"context"
	"net"
	"sync"
	"time"

	"code.cloudfoundry.org/goshims/grpcshim"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/naming"
	"google.golang.org/grpc/stats"
	"google.golang.org/grpc/tap"
)

type FakeGrpc struct {
	CodeStub        func(error) codes.Code
	codeMutex       sync.RWMutex
	codeArgsForCall []struct {
		arg1 error
	}
	codeReturns struct {
		result1 codes.Code
	}
	codeReturnsOnCall map[int]struct {
		result1 codes.Code
	}
	CredsStub        func(credentials.TransportCredentials) grpc.ServerOption
	credsMutex       sync.RWMutex
	credsArgsForCall []struct {
		arg1 credentials.TransportCredentials
	}
	credsReturns struct {
		result1 grpc.ServerOption
	}
	credsReturnsOnCall map[int]struct {
		result1 grpc.ServerOption
	}
	CustomCodecStub        func(grpc.Codec) grpc.ServerOption
	customCodecMutex       sync.RWMutex
	customCodecArgsForCall []struct {
		arg1 grpc.Codec
	}
	customCodecReturns struct {
		result1 grpc.ServerOption
	}
	customCodecReturnsOnCall map[int]struct {
		result1 grpc.ServerOption
	}
	DialStub        func(string, ...grpc.DialOption) (grpcshim.ClientConn, error)
	dialMutex       sync.RWMutex
	dialArgsForCall []struct {
		arg1 string
		arg2 []grpc.DialOption
	}
	dialReturns struct {
		result1 grpcshim.ClientConn
		result2 error
	}
	dialReturnsOnCall map[int]struct {
		result1 grpcshim.ClientConn
		result2 error
	}
	DialContextStub        func(context.Context, string, ...grpc.DialOption) (*grpc.ClientConn, error)
	dialContextMutex       sync.RWMutex
	dialContextArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []grpc.DialOption
	}
	dialContextReturns struct {
		result1 *grpc.ClientConn
		result2 error
	}
	dialContextReturnsOnCall map[int]struct {
		result1 *grpc.ClientConn
		result2 error
	}
	ErrorDescStub        func(error) string
	errorDescMutex       sync.RWMutex
	errorDescArgsForCall []struct {
		arg1 error
	}
	errorDescReturns struct {
		result1 string
	}
	errorDescReturnsOnCall map[int]struct {
		result1 string
	}
	ErrorfStub        func(codes.Code, string, ...interface{}) error
	errorfMutex       sync.RWMutex
	errorfArgsForCall []struct {
		arg1 codes.Code
		arg2 string
		arg3 []interface{}
	}
	errorfReturns struct {
		result1 error
	}
	errorfReturnsOnCall map[int]struct {
		result1 error
	}
	FailFastStub        func(bool) grpc.CallOption
	failFastMutex       sync.RWMutex
	failFastArgsForCall []struct {
		arg1 bool
	}
	failFastReturns struct {
		result1 grpc.CallOption
	}
	failFastReturnsOnCall map[int]struct {
		result1 grpc.CallOption
	}
	FailOnNonTempDialErrorStub        func(bool) grpc.DialOption
	failOnNonTempDialErrorMutex       sync.RWMutex
	failOnNonTempDialErrorArgsForCall []struct {
		arg1 bool
	}
	failOnNonTempDialErrorReturns struct {
		result1 grpc.DialOption
	}
	failOnNonTempDialErrorReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	HeaderStub        func(*metadata.MD) grpc.CallOption
	headerMutex       sync.RWMutex
	headerArgsForCall []struct {
		arg1 *metadata.MD
	}
	headerReturns struct {
		result1 grpc.CallOption
	}
	headerReturnsOnCall map[int]struct {
		result1 grpc.CallOption
	}
	InTapHandleStub        func(tap.ServerInHandle) grpc.ServerOption
	inTapHandleMutex       sync.RWMutex
	inTapHandleArgsForCall []struct {
		arg1 tap.ServerInHandle
	}
	inTapHandleReturns struct {
		result1 grpc.ServerOption
	}
	inTapHandleReturnsOnCall map[int]struct {
		result1 grpc.ServerOption
	}
	InvokeStub        func(context.Context, string, interface{}, interface{}, *grpc.ClientConn, ...grpc.CallOption) error
	invokeMutex       sync.RWMutex
	invokeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 interface{}
		arg5 *grpc.ClientConn
		arg6 []grpc.CallOption
	}
	invokeReturns struct {
		result1 error
	}
	invokeReturnsOnCall map[int]struct {
		result1 error
	}
	MaxConcurrentStreamsStub        func(uint32) grpc.ServerOption
	maxConcurrentStreamsMutex       sync.RWMutex
	maxConcurrentStreamsArgsForCall []struct {
		arg1 uint32
	}
	maxConcurrentStreamsReturns struct {
		result1 grpc.ServerOption
	}
	maxConcurrentStreamsReturnsOnCall map[int]struct {
		result1 grpc.ServerOption
	}
	MaxMsgSizeStub        func(int) grpc.ServerOption
	maxMsgSizeMutex       sync.RWMutex
	maxMsgSizeArgsForCall []struct {
		arg1 int
	}
	maxMsgSizeReturns struct {
		result1 grpc.ServerOption
	}
	maxMsgSizeReturnsOnCall map[int]struct {
		result1 grpc.ServerOption
	}
	NewClientStreamStub        func(context.Context, *grpc.StreamDesc, *grpc.ClientConn, string, ...grpc.CallOption) (grpc.ClientStream, error)
	newClientStreamMutex       sync.RWMutex
	newClientStreamArgsForCall []struct {
		arg1 context.Context
		arg2 *grpc.StreamDesc
		arg3 *grpc.ClientConn
		arg4 string
		arg5 []grpc.CallOption
	}
	newClientStreamReturns struct {
		result1 grpc.ClientStream
		result2 error
	}
	newClientStreamReturnsOnCall map[int]struct {
		result1 grpc.ClientStream
		result2 error
	}
	NewGZIPCompressorStub        func() grpc.Compressor
	newGZIPCompressorMutex       sync.RWMutex
	newGZIPCompressorArgsForCall []struct {
	}
	newGZIPCompressorReturns struct {
		result1 grpc.Compressor
	}
	newGZIPCompressorReturnsOnCall map[int]struct {
		result1 grpc.Compressor
	}
	NewGZIPDecompressorStub        func() grpc.Decompressor
	newGZIPDecompressorMutex       sync.RWMutex
	newGZIPDecompressorArgsForCall []struct {
	}
	newGZIPDecompressorReturns struct {
		result1 grpc.Decompressor
	}
	newGZIPDecompressorReturnsOnCall map[int]struct {
		result1 grpc.Decompressor
	}
	NewServerStub        func(...grpc.ServerOption) *grpc.Server
	newServerMutex       sync.RWMutex
	newServerArgsForCall []struct {
		arg1 []grpc.ServerOption
	}
	newServerReturns struct {
		result1 *grpc.Server
	}
	newServerReturnsOnCall map[int]struct {
		result1 *grpc.Server
	}
	RPCCompressorStub        func(grpc.Compressor) grpc.ServerOption
	rPCCompressorMutex       sync.RWMutex
	rPCCompressorArgsForCall []struct {
		arg1 grpc.Compressor
	}
	rPCCompressorReturns struct {
		result1 grpc.ServerOption
	}
	rPCCompressorReturnsOnCall map[int]struct {
		result1 grpc.ServerOption
	}
	RPCDecompressorStub        func(grpc.Decompressor) grpc.ServerOption
	rPCDecompressorMutex       sync.RWMutex
	rPCDecompressorArgsForCall []struct {
		arg1 grpc.Decompressor
	}
	rPCDecompressorReturns struct {
		result1 grpc.ServerOption
	}
	rPCDecompressorReturnsOnCall map[int]struct {
		result1 grpc.ServerOption
	}
	RoundRobinStub        func(naming.Resolver) grpc.Balancer
	roundRobinMutex       sync.RWMutex
	roundRobinArgsForCall []struct {
		arg1 naming.Resolver
	}
	roundRobinReturns struct {
		result1 grpc.Balancer
	}
	roundRobinReturnsOnCall map[int]struct {
		result1 grpc.Balancer
	}
	SendHeaderStub        func(context.Context, metadata.MD) error
	sendHeaderMutex       sync.RWMutex
	sendHeaderArgsForCall []struct {
		arg1 context.Context
		arg2 metadata.MD
	}
	sendHeaderReturns struct {
		result1 error
	}
	sendHeaderReturnsOnCall map[int]struct {
		result1 error
	}
	SetHeaderStub        func(context.Context, metadata.MD) error
	setHeaderMutex       sync.RWMutex
	setHeaderArgsForCall []struct {
		arg1 context.Context
		arg2 metadata.MD
	}
	setHeaderReturns struct {
		result1 error
	}
	setHeaderReturnsOnCall map[int]struct {
		result1 error
	}
	SetTrailerStub        func(context.Context, metadata.MD) error
	setTrailerMutex       sync.RWMutex
	setTrailerArgsForCall []struct {
		arg1 context.Context
		arg2 metadata.MD
	}
	setTrailerReturns struct {
		result1 error
	}
	setTrailerReturnsOnCall map[int]struct {
		result1 error
	}
	StatsHandlerStub        func(stats.Handler) grpc.ServerOption
	statsHandlerMutex       sync.RWMutex
	statsHandlerArgsForCall []struct {
		arg1 stats.Handler
	}
	statsHandlerReturns struct {
		result1 grpc.ServerOption
	}
	statsHandlerReturnsOnCall map[int]struct {
		result1 grpc.ServerOption
	}
	StreamInterceptorStub        func(grpc.StreamServerInterceptor) grpc.ServerOption
	streamInterceptorMutex       sync.RWMutex
	streamInterceptorArgsForCall []struct {
		arg1 grpc.StreamServerInterceptor
	}
	streamInterceptorReturns struct {
		result1 grpc.ServerOption
	}
	streamInterceptorReturnsOnCall map[int]struct {
		result1 grpc.ServerOption
	}
	TrailerStub        func(*metadata.MD) grpc.CallOption
	trailerMutex       sync.RWMutex
	trailerArgsForCall []struct {
		arg1 *metadata.MD
	}
	trailerReturns struct {
		result1 grpc.CallOption
	}
	trailerReturnsOnCall map[int]struct {
		result1 grpc.CallOption
	}
	UnaryInterceptorStub        func(grpc.UnaryServerInterceptor) grpc.ServerOption
	unaryInterceptorMutex       sync.RWMutex
	unaryInterceptorArgsForCall []struct {
		arg1 grpc.UnaryServerInterceptor
	}
	unaryInterceptorReturns struct {
		result1 grpc.ServerOption
	}
	unaryInterceptorReturnsOnCall map[int]struct {
		result1 grpc.ServerOption
	}
	WithBackoffConfigStub        func(grpc.BackoffConfig) grpc.DialOption
	withBackoffConfigMutex       sync.RWMutex
	withBackoffConfigArgsForCall []struct {
		arg1 grpc.BackoffConfig
	}
	withBackoffConfigReturns struct {
		result1 grpc.DialOption
	}
	withBackoffConfigReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithBackoffMaxDelayStub        func(time.Duration) grpc.DialOption
	withBackoffMaxDelayMutex       sync.RWMutex
	withBackoffMaxDelayArgsForCall []struct {
		arg1 time.Duration
	}
	withBackoffMaxDelayReturns struct {
		result1 grpc.DialOption
	}
	withBackoffMaxDelayReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithBalancerStub        func(grpc.Balancer) grpc.DialOption
	withBalancerMutex       sync.RWMutex
	withBalancerArgsForCall []struct {
		arg1 grpc.Balancer
	}
	withBalancerReturns struct {
		result1 grpc.DialOption
	}
	withBalancerReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithBlockStub        func() grpc.DialOption
	withBlockMutex       sync.RWMutex
	withBlockArgsForCall []struct {
	}
	withBlockReturns struct {
		result1 grpc.DialOption
	}
	withBlockReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithCodecStub        func(grpc.Codec) grpc.DialOption
	withCodecMutex       sync.RWMutex
	withCodecArgsForCall []struct {
		arg1 grpc.Codec
	}
	withCodecReturns struct {
		result1 grpc.DialOption
	}
	withCodecReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithCompressorStub        func(grpc.Compressor) grpc.DialOption
	withCompressorMutex       sync.RWMutex
	withCompressorArgsForCall []struct {
		arg1 grpc.Compressor
	}
	withCompressorReturns struct {
		result1 grpc.DialOption
	}
	withCompressorReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithDecompressorStub        func(grpc.Decompressor) grpc.DialOption
	withDecompressorMutex       sync.RWMutex
	withDecompressorArgsForCall []struct {
		arg1 grpc.Decompressor
	}
	withDecompressorReturns struct {
		result1 grpc.DialOption
	}
	withDecompressorReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithDialerStub        func(func(string, time.Duration) (net.Conn, error)) grpc.DialOption
	withDialerMutex       sync.RWMutex
	withDialerArgsForCall []struct {
		arg1 func(string, time.Duration) (net.Conn, error)
	}
	withDialerReturns struct {
		result1 grpc.DialOption
	}
	withDialerReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithInsecureStub        func() grpc.DialOption
	withInsecureMutex       sync.RWMutex
	withInsecureArgsForCall []struct {
	}
	withInsecureReturns struct {
		result1 grpc.DialOption
	}
	withInsecureReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithPerRPCCredentialsStub        func(credentials.PerRPCCredentials) grpc.DialOption
	withPerRPCCredentialsMutex       sync.RWMutex
	withPerRPCCredentialsArgsForCall []struct {
		arg1 credentials.PerRPCCredentials
	}
	withPerRPCCredentialsReturns struct {
		result1 grpc.DialOption
	}
	withPerRPCCredentialsReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithServiceConfigStub        func(<-chan grpc.ServiceConfig) grpc.DialOption
	withServiceConfigMutex       sync.RWMutex
	withServiceConfigArgsForCall []struct {
		arg1 <-chan grpc.ServiceConfig
	}
	withServiceConfigReturns struct {
		result1 grpc.DialOption
	}
	withServiceConfigReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithStatsHandlerStub        func(stats.Handler) grpc.DialOption
	withStatsHandlerMutex       sync.RWMutex
	withStatsHandlerArgsForCall []struct {
		arg1 stats.Handler
	}
	withStatsHandlerReturns struct {
		result1 grpc.DialOption
	}
	withStatsHandlerReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithStreamInterceptorStub        func(grpc.StreamClientInterceptor) grpc.DialOption
	withStreamInterceptorMutex       sync.RWMutex
	withStreamInterceptorArgsForCall []struct {
		arg1 grpc.StreamClientInterceptor
	}
	withStreamInterceptorReturns struct {
		result1 grpc.DialOption
	}
	withStreamInterceptorReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithTimeoutStub        func(time.Duration) grpc.DialOption
	withTimeoutMutex       sync.RWMutex
	withTimeoutArgsForCall []struct {
		arg1 time.Duration
	}
	withTimeoutReturns struct {
		result1 grpc.DialOption
	}
	withTimeoutReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithTransportCredentialsStub        func(credentials.TransportCredentials) grpc.DialOption
	withTransportCredentialsMutex       sync.RWMutex
	withTransportCredentialsArgsForCall []struct {
		arg1 credentials.TransportCredentials
	}
	withTransportCredentialsReturns struct {
		result1 grpc.DialOption
	}
	withTransportCredentialsReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithUnaryInterceptorStub        func(grpc.UnaryClientInterceptor) grpc.DialOption
	withUnaryInterceptorMutex       sync.RWMutex
	withUnaryInterceptorArgsForCall []struct {
		arg1 grpc.UnaryClientInterceptor
	}
	withUnaryInterceptorReturns struct {
		result1 grpc.DialOption
	}
	withUnaryInterceptorReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	WithUserAgentStub        func(string) grpc.DialOption
	withUserAgentMutex       sync.RWMutex
	withUserAgentArgsForCall []struct {
		arg1 string
	}
	withUserAgentReturns struct {
		result1 grpc.DialOption
	}
	withUserAgentReturnsOnCall map[int]struct {
		result1 grpc.DialOption
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGrpc) Code(arg1 error) codes.Code {
	fake.codeMutex.Lock()
	ret, specificReturn := fake.codeReturnsOnCall[len(fake.codeArgsForCall)]
	fake.codeArgsForCall = append(fake.codeArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.CodeStub
	fakeReturns := fake.codeReturns
	fake.recordInvocation("Code", []interface{}{arg1})
	fake.codeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) CodeCallCount() int {
	fake.codeMutex.RLock()
	defer fake.codeMutex.RUnlock()
	return len(fake.codeArgsForCall)
}

func (fake *FakeGrpc) CodeCalls(stub func(error) codes.Code) {
	fake.codeMutex.Lock()
	defer fake.codeMutex.Unlock()
	fake.CodeStub = stub
}

func (fake *FakeGrpc) CodeArgsForCall(i int) error {
	fake.codeMutex.RLock()
	defer fake.codeMutex.RUnlock()
	argsForCall := fake.codeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) CodeReturns(result1 codes.Code) {
	fake.codeMutex.Lock()
	defer fake.codeMutex.Unlock()
	fake.CodeStub = nil
	fake.codeReturns = struct {
		result1 codes.Code
	}{result1}
}

func (fake *FakeGrpc) CodeReturnsOnCall(i int, result1 codes.Code) {
	fake.codeMutex.Lock()
	defer fake.codeMutex.Unlock()
	fake.CodeStub = nil
	if fake.codeReturnsOnCall == nil {
		fake.codeReturnsOnCall = make(map[int]struct {
			result1 codes.Code
		})
	}
	fake.codeReturnsOnCall[i] = struct {
		result1 codes.Code
	}{result1}
}

func (fake *FakeGrpc) Creds(arg1 credentials.TransportCredentials) grpc.ServerOption {
	fake.credsMutex.Lock()
	ret, specificReturn := fake.credsReturnsOnCall[len(fake.credsArgsForCall)]
	fake.credsArgsForCall = append(fake.credsArgsForCall, struct {
		arg1 credentials.TransportCredentials
	}{arg1})
	stub := fake.CredsStub
	fakeReturns := fake.credsReturns
	fake.recordInvocation("Creds", []interface{}{arg1})
	fake.credsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) CredsCallCount() int {
	fake.credsMutex.RLock()
	defer fake.credsMutex.RUnlock()
	return len(fake.credsArgsForCall)
}

func (fake *FakeGrpc) CredsCalls(stub func(credentials.TransportCredentials) grpc.ServerOption) {
	fake.credsMutex.Lock()
	defer fake.credsMutex.Unlock()
	fake.CredsStub = stub
}

func (fake *FakeGrpc) CredsArgsForCall(i int) credentials.TransportCredentials {
	fake.credsMutex.RLock()
	defer fake.credsMutex.RUnlock()
	argsForCall := fake.credsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) CredsReturns(result1 grpc.ServerOption) {
	fake.credsMutex.Lock()
	defer fake.credsMutex.Unlock()
	fake.CredsStub = nil
	fake.credsReturns = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) CredsReturnsOnCall(i int, result1 grpc.ServerOption) {
	fake.credsMutex.Lock()
	defer fake.credsMutex.Unlock()
	fake.CredsStub = nil
	if fake.credsReturnsOnCall == nil {
		fake.credsReturnsOnCall = make(map[int]struct {
			result1 grpc.ServerOption
		})
	}
	fake.credsReturnsOnCall[i] = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) CustomCodec(arg1 grpc.Codec) grpc.ServerOption {
	fake.customCodecMutex.Lock()
	ret, specificReturn := fake.customCodecReturnsOnCall[len(fake.customCodecArgsForCall)]
	fake.customCodecArgsForCall = append(fake.customCodecArgsForCall, struct {
		arg1 grpc.Codec
	}{arg1})
	stub := fake.CustomCodecStub
	fakeReturns := fake.customCodecReturns
	fake.recordInvocation("CustomCodec", []interface{}{arg1})
	fake.customCodecMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) CustomCodecCallCount() int {
	fake.customCodecMutex.RLock()
	defer fake.customCodecMutex.RUnlock()
	return len(fake.customCodecArgsForCall)
}

func (fake *FakeGrpc) CustomCodecCalls(stub func(grpc.Codec) grpc.ServerOption) {
	fake.customCodecMutex.Lock()
	defer fake.customCodecMutex.Unlock()
	fake.CustomCodecStub = stub
}

func (fake *FakeGrpc) CustomCodecArgsForCall(i int) grpc.Codec {
	fake.customCodecMutex.RLock()
	defer fake.customCodecMutex.RUnlock()
	argsForCall := fake.customCodecArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) CustomCodecReturns(result1 grpc.ServerOption) {
	fake.customCodecMutex.Lock()
	defer fake.customCodecMutex.Unlock()
	fake.CustomCodecStub = nil
	fake.customCodecReturns = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) CustomCodecReturnsOnCall(i int, result1 grpc.ServerOption) {
	fake.customCodecMutex.Lock()
	defer fake.customCodecMutex.Unlock()
	fake.CustomCodecStub = nil
	if fake.customCodecReturnsOnCall == nil {
		fake.customCodecReturnsOnCall = make(map[int]struct {
			result1 grpc.ServerOption
		})
	}
	fake.customCodecReturnsOnCall[i] = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) Dial(arg1 string, arg2 ...grpc.DialOption) (grpcshim.ClientConn, error) {
	fake.dialMutex.Lock()
	ret, specificReturn := fake.dialReturnsOnCall[len(fake.dialArgsForCall)]
	fake.dialArgsForCall = append(fake.dialArgsForCall, struct {
		arg1 string
		arg2 []grpc.DialOption
	}{arg1, arg2})
	stub := fake.DialStub
	fakeReturns := fake.dialReturns
	fake.recordInvocation("Dial", []interface{}{arg1, arg2})
	fake.dialMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrpc) DialCallCount() int {
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	return len(fake.dialArgsForCall)
}

func (fake *FakeGrpc) DialCalls(stub func(string, ...grpc.DialOption) (grpcshim.ClientConn, error)) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = stub
}

func (fake *FakeGrpc) DialArgsForCall(i int) (string, []grpc.DialOption) {
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	argsForCall := fake.dialArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGrpc) DialReturns(result1 grpcshim.ClientConn, result2 error) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = nil
	fake.dialReturns = struct {
		result1 grpcshim.ClientConn
		result2 error
	}{result1, result2}
}

func (fake *FakeGrpc) DialReturnsOnCall(i int, result1 grpcshim.ClientConn, result2 error) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = nil
	if fake.dialReturnsOnCall == nil {
		fake.dialReturnsOnCall = make(map[int]struct {
			result1 grpcshim.ClientConn
			result2 error
		})
	}
	fake.dialReturnsOnCall[i] = struct {
		result1 grpcshim.ClientConn
		result2 error
	}{result1, result2}
}

func (fake *FakeGrpc) DialContext(arg1 context.Context, arg2 string, arg3 ...grpc.DialOption) (*grpc.ClientConn, error) {
	fake.dialContextMutex.Lock()
	ret, specificReturn := fake.dialContextReturnsOnCall[len(fake.dialContextArgsForCall)]
	fake.dialContextArgsForCall = append(fake.dialContextArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []grpc.DialOption
	}{arg1, arg2, arg3})
	stub := fake.DialContextStub
	fakeReturns := fake.dialContextReturns
	fake.recordInvocation("DialContext", []interface{}{arg1, arg2, arg3})
	fake.dialContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrpc) DialContextCallCount() int {
	fake.dialContextMutex.RLock()
	defer fake.dialContextMutex.RUnlock()
	return len(fake.dialContextArgsForCall)
}

func (fake *FakeGrpc) DialContextCalls(stub func(context.Context, string, ...grpc.DialOption) (*grpc.ClientConn, error)) {
	fake.dialContextMutex.Lock()
	defer fake.dialContextMutex.Unlock()
	fake.DialContextStub = stub
}

func (fake *FakeGrpc) DialContextArgsForCall(i int) (context.Context, string, []grpc.DialOption) {
	fake.dialContextMutex.RLock()
	defer fake.dialContextMutex.RUnlock()
	argsForCall := fake.dialContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrpc) DialContextReturns(result1 *grpc.ClientConn, result2 error) {
	fake.dialContextMutex.Lock()
	defer fake.dialContextMutex.Unlock()
	fake.DialContextStub = nil
	fake.dialContextReturns = struct {
		result1 *grpc.ClientConn
		result2 error
	}{result1, result2}
}

func (fake *FakeGrpc) DialContextReturnsOnCall(i int, result1 *grpc.ClientConn, result2 error) {
	fake.dialContextMutex.Lock()
	defer fake.dialContextMutex.Unlock()
	fake.DialContextStub = nil
	if fake.dialContextReturnsOnCall == nil {
		fake.dialContextReturnsOnCall = make(map[int]struct {
			result1 *grpc.ClientConn
			result2 error
		})
	}
	fake.dialContextReturnsOnCall[i] = struct {
		result1 *grpc.ClientConn
		result2 error
	}{result1, result2}
}

func (fake *FakeGrpc) ErrorDesc(arg1 error) string {
	fake.errorDescMutex.Lock()
	ret, specificReturn := fake.errorDescReturnsOnCall[len(fake.errorDescArgsForCall)]
	fake.errorDescArgsForCall = append(fake.errorDescArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.ErrorDescStub
	fakeReturns := fake.errorDescReturns
	fake.recordInvocation("ErrorDesc", []interface{}{arg1})
	fake.errorDescMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) ErrorDescCallCount() int {
	fake.errorDescMutex.RLock()
	defer fake.errorDescMutex.RUnlock()
	return len(fake.errorDescArgsForCall)
}

func (fake *FakeGrpc) ErrorDescCalls(stub func(error) string) {
	fake.errorDescMutex.Lock()
	defer fake.errorDescMutex.Unlock()
	fake.ErrorDescStub = stub
}

func (fake *FakeGrpc) ErrorDescArgsForCall(i int) error {
	fake.errorDescMutex.RLock()
	defer fake.errorDescMutex.RUnlock()
	argsForCall := fake.errorDescArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) ErrorDescReturns(result1 string) {
	fake.errorDescMutex.Lock()
	defer fake.errorDescMutex.Unlock()
	fake.ErrorDescStub = nil
	fake.errorDescReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeGrpc) ErrorDescReturnsOnCall(i int, result1 string) {
	fake.errorDescMutex.Lock()
	defer fake.errorDescMutex.Unlock()
	fake.ErrorDescStub = nil
	if fake.errorDescReturnsOnCall == nil {
		fake.errorDescReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.errorDescReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeGrpc) Errorf(arg1 codes.Code, arg2 string, arg3 ...interface{}) error {
	fake.errorfMutex.Lock()
	ret, specificReturn := fake.errorfReturnsOnCall[len(fake.errorfArgsForCall)]
	fake.errorfArgsForCall = append(fake.errorfArgsForCall, struct {
		arg1 codes.Code
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.ErrorfStub
	fakeReturns := fake.errorfReturns
	fake.recordInvocation("Errorf", []interface{}{arg1, arg2, arg3})
	fake.errorfMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) ErrorfCallCount() int {
	fake.errorfMutex.RLock()
	defer fake.errorfMutex.RUnlock()
	return len(fake.errorfArgsForCall)
}

func (fake *FakeGrpc) ErrorfCalls(stub func(codes.Code, string, ...interface{}) error) {
	fake.errorfMutex.Lock()
	defer fake.errorfMutex.Unlock()
	fake.ErrorfStub = stub
}

func (fake *FakeGrpc) ErrorfArgsForCall(i int) (codes.Code, string, []interface{}) {
	fake.errorfMutex.RLock()
	defer fake.errorfMutex.RUnlock()
	argsForCall := fake.errorfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrpc) ErrorfReturns(result1 error) {
	fake.errorfMutex.Lock()
	defer fake.errorfMutex.Unlock()
	fake.ErrorfStub = nil
	fake.errorfReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGrpc) ErrorfReturnsOnCall(i int, result1 error) {
	fake.errorfMutex.Lock()
	defer fake.errorfMutex.Unlock()
	fake.ErrorfStub = nil
	if fake.errorfReturnsOnCall == nil {
		fake.errorfReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.errorfReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGrpc) FailFast(arg1 bool) grpc.CallOption {
	fake.failFastMutex.Lock()
	ret, specificReturn := fake.failFastReturnsOnCall[len(fake.failFastArgsForCall)]
	fake.failFastArgsForCall = append(fake.failFastArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.FailFastStub
	fakeReturns := fake.failFastReturns
	fake.recordInvocation("FailFast", []interface{}{arg1})
	fake.failFastMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) FailFastCallCount() int {
	fake.failFastMutex.RLock()
	defer fake.failFastMutex.RUnlock()
	return len(fake.failFastArgsForCall)
}

func (fake *FakeGrpc) FailFastCalls(stub func(bool) grpc.CallOption) {
	fake.failFastMutex.Lock()
	defer fake.failFastMutex.Unlock()
	fake.FailFastStub = stub
}

func (fake *FakeGrpc) FailFastArgsForCall(i int) bool {
	fake.failFastMutex.RLock()
	defer fake.failFastMutex.RUnlock()
	argsForCall := fake.failFastArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) FailFastReturns(result1 grpc.CallOption) {
	fake.failFastMutex.Lock()
	defer fake.failFastMutex.Unlock()
	fake.FailFastStub = nil
	fake.failFastReturns = struct {
		result1 grpc.CallOption
	}{result1}
}

func (fake *FakeGrpc) FailFastReturnsOnCall(i int, result1 grpc.CallOption) {
	fake.failFastMutex.Lock()
	defer fake.failFastMutex.Unlock()
	fake.FailFastStub = nil
	if fake.failFastReturnsOnCall == nil {
		fake.failFastReturnsOnCall = make(map[int]struct {
			result1 grpc.CallOption
		})
	}
	fake.failFastReturnsOnCall[i] = struct {
		result1 grpc.CallOption
	}{result1}
}

func (fake *FakeGrpc) FailOnNonTempDialError(arg1 bool) grpc.DialOption {
	fake.failOnNonTempDialErrorMutex.Lock()
	ret, specificReturn := fake.failOnNonTempDialErrorReturnsOnCall[len(fake.failOnNonTempDialErrorArgsForCall)]
	fake.failOnNonTempDialErrorArgsForCall = append(fake.failOnNonTempDialErrorArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.FailOnNonTempDialErrorStub
	fakeReturns := fake.failOnNonTempDialErrorReturns
	fake.recordInvocation("FailOnNonTempDialError", []interface{}{arg1})
	fake.failOnNonTempDialErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) FailOnNonTempDialErrorCallCount() int {
	fake.failOnNonTempDialErrorMutex.RLock()
	defer fake.failOnNonTempDialErrorMutex.RUnlock()
	return len(fake.failOnNonTempDialErrorArgsForCall)
}

func (fake *FakeGrpc) FailOnNonTempDialErrorCalls(stub func(bool) grpc.DialOption) {
	fake.failOnNonTempDialErrorMutex.Lock()
	defer fake.failOnNonTempDialErrorMutex.Unlock()
	fake.FailOnNonTempDialErrorStub = stub
}

func (fake *FakeGrpc) FailOnNonTempDialErrorArgsForCall(i int) bool {
	fake.failOnNonTempDialErrorMutex.RLock()
	defer fake.failOnNonTempDialErrorMutex.RUnlock()
	argsForCall := fake.failOnNonTempDialErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) FailOnNonTempDialErrorReturns(result1 grpc.DialOption) {
	fake.failOnNonTempDialErrorMutex.Lock()
	defer fake.failOnNonTempDialErrorMutex.Unlock()
	fake.FailOnNonTempDialErrorStub = nil
	fake.failOnNonTempDialErrorReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) FailOnNonTempDialErrorReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.failOnNonTempDialErrorMutex.Lock()
	defer fake.failOnNonTempDialErrorMutex.Unlock()
	fake.FailOnNonTempDialErrorStub = nil
	if fake.failOnNonTempDialErrorReturnsOnCall == nil {
		fake.failOnNonTempDialErrorReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.failOnNonTempDialErrorReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) Header(arg1 *metadata.MD) grpc.CallOption {
	fake.headerMutex.Lock()
	ret, specificReturn := fake.headerReturnsOnCall[len(fake.headerArgsForCall)]
	fake.headerArgsForCall = append(fake.headerArgsForCall, struct {
		arg1 *metadata.MD
	}{arg1})
	stub := fake.HeaderStub
	fakeReturns := fake.headerReturns
	fake.recordInvocation("Header", []interface{}{arg1})
	fake.headerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) HeaderCallCount() int {
	fake.headerMutex.RLock()
	defer fake.headerMutex.RUnlock()
	return len(fake.headerArgsForCall)
}

func (fake *FakeGrpc) HeaderCalls(stub func(*metadata.MD) grpc.CallOption) {
	fake.headerMutex.Lock()
	defer fake.headerMutex.Unlock()
	fake.HeaderStub = stub
}

func (fake *FakeGrpc) HeaderArgsForCall(i int) *metadata.MD {
	fake.headerMutex.RLock()
	defer fake.headerMutex.RUnlock()
	argsForCall := fake.headerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) HeaderReturns(result1 grpc.CallOption) {
	fake.headerMutex.Lock()
	defer fake.headerMutex.Unlock()
	fake.HeaderStub = nil
	fake.headerReturns = struct {
		result1 grpc.CallOption
	}{result1}
}

func (fake *FakeGrpc) HeaderReturnsOnCall(i int, result1 grpc.CallOption) {
	fake.headerMutex.Lock()
	defer fake.headerMutex.Unlock()
	fake.HeaderStub = nil
	if fake.headerReturnsOnCall == nil {
		fake.headerReturnsOnCall = make(map[int]struct {
			result1 grpc.CallOption
		})
	}
	fake.headerReturnsOnCall[i] = struct {
		result1 grpc.CallOption
	}{result1}
}

func (fake *FakeGrpc) InTapHandle(arg1 tap.ServerInHandle) grpc.ServerOption {
	fake.inTapHandleMutex.Lock()
	ret, specificReturn := fake.inTapHandleReturnsOnCall[len(fake.inTapHandleArgsForCall)]
	fake.inTapHandleArgsForCall = append(fake.inTapHandleArgsForCall, struct {
		arg1 tap.ServerInHandle
	}{arg1})
	stub := fake.InTapHandleStub
	fakeReturns := fake.inTapHandleReturns
	fake.recordInvocation("InTapHandle", []interface{}{arg1})
	fake.inTapHandleMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) InTapHandleCallCount() int {
	fake.inTapHandleMutex.RLock()
	defer fake.inTapHandleMutex.RUnlock()
	return len(fake.inTapHandleArgsForCall)
}

func (fake *FakeGrpc) InTapHandleCalls(stub func(tap.ServerInHandle) grpc.ServerOption) {
	fake.inTapHandleMutex.Lock()
	defer fake.inTapHandleMutex.Unlock()
	fake.InTapHandleStub = stub
}

func (fake *FakeGrpc) InTapHandleArgsForCall(i int) tap.ServerInHandle {
	fake.inTapHandleMutex.RLock()
	defer fake.inTapHandleMutex.RUnlock()
	argsForCall := fake.inTapHandleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) InTapHandleReturns(result1 grpc.ServerOption) {
	fake.inTapHandleMutex.Lock()
	defer fake.inTapHandleMutex.Unlock()
	fake.InTapHandleStub = nil
	fake.inTapHandleReturns = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) InTapHandleReturnsOnCall(i int, result1 grpc.ServerOption) {
	fake.inTapHandleMutex.Lock()
	defer fake.inTapHandleMutex.Unlock()
	fake.InTapHandleStub = nil
	if fake.inTapHandleReturnsOnCall == nil {
		fake.inTapHandleReturnsOnCall = make(map[int]struct {
			result1 grpc.ServerOption
		})
	}
	fake.inTapHandleReturnsOnCall[i] = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) Invoke(arg1 context.Context, arg2 string, arg3 interface{}, arg4 interface{}, arg5 *grpc.ClientConn, arg6 ...grpc.CallOption) error {
	fake.invokeMutex.Lock()
	ret, specificReturn := fake.invokeReturnsOnCall[len(fake.invokeArgsForCall)]
	fake.invokeArgsForCall = append(fake.invokeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
		arg4 interface{}
		arg5 *grpc.ClientConn
		arg6 []grpc.CallOption
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.InvokeStub
	fakeReturns := fake.invokeReturns
	fake.recordInvocation("Invoke", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.invokeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) InvokeCallCount() int {
	fake.invokeMutex.RLock()
	defer fake.invokeMutex.RUnlock()
	return len(fake.invokeArgsForCall)
}

func (fake *FakeGrpc) InvokeCalls(stub func(context.Context, string, interface{}, interface{}, *grpc.ClientConn, ...grpc.CallOption) error) {
	fake.invokeMutex.Lock()
	defer fake.invokeMutex.Unlock()
	fake.InvokeStub = stub
}

func (fake *FakeGrpc) InvokeArgsForCall(i int) (context.Context, string, interface{}, interface{}, *grpc.ClientConn, []grpc.CallOption) {
	fake.invokeMutex.RLock()
	defer fake.invokeMutex.RUnlock()
	argsForCall := fake.invokeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeGrpc) InvokeReturns(result1 error) {
	fake.invokeMutex.Lock()
	defer fake.invokeMutex.Unlock()
	fake.InvokeStub = nil
	fake.invokeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGrpc) InvokeReturnsOnCall(i int, result1 error) {
	fake.invokeMutex.Lock()
	defer fake.invokeMutex.Unlock()
	fake.InvokeStub = nil
	if fake.invokeReturnsOnCall == nil {
		fake.invokeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.invokeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGrpc) MaxConcurrentStreams(arg1 uint32) grpc.ServerOption {
	fake.maxConcurrentStreamsMutex.Lock()
	ret, specificReturn := fake.maxConcurrentStreamsReturnsOnCall[len(fake.maxConcurrentStreamsArgsForCall)]
	fake.maxConcurrentStreamsArgsForCall = append(fake.maxConcurrentStreamsArgsForCall, struct {
		arg1 uint32
	}{arg1})
	stub := fake.MaxConcurrentStreamsStub
	fakeReturns := fake.maxConcurrentStreamsReturns
	fake.recordInvocation("MaxConcurrentStreams", []interface{}{arg1})
	fake.maxConcurrentStreamsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) MaxConcurrentStreamsCallCount() int {
	fake.maxConcurrentStreamsMutex.RLock()
	defer fake.maxConcurrentStreamsMutex.RUnlock()
	return len(fake.maxConcurrentStreamsArgsForCall)
}

func (fake *FakeGrpc) MaxConcurrentStreamsCalls(stub func(uint32) grpc.ServerOption) {
	fake.maxConcurrentStreamsMutex.Lock()
	defer fake.maxConcurrentStreamsMutex.Unlock()
	fake.MaxConcurrentStreamsStub = stub
}

func (fake *FakeGrpc) MaxConcurrentStreamsArgsForCall(i int) uint32 {
	fake.maxConcurrentStreamsMutex.RLock()
	defer fake.maxConcurrentStreamsMutex.RUnlock()
	argsForCall := fake.maxConcurrentStreamsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) MaxConcurrentStreamsReturns(result1 grpc.ServerOption) {
	fake.maxConcurrentStreamsMutex.Lock()
	defer fake.maxConcurrentStreamsMutex.Unlock()
	fake.MaxConcurrentStreamsStub = nil
	fake.maxConcurrentStreamsReturns = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) MaxConcurrentStreamsReturnsOnCall(i int, result1 grpc.ServerOption) {
	fake.maxConcurrentStreamsMutex.Lock()
	defer fake.maxConcurrentStreamsMutex.Unlock()
	fake.MaxConcurrentStreamsStub = nil
	if fake.maxConcurrentStreamsReturnsOnCall == nil {
		fake.maxConcurrentStreamsReturnsOnCall = make(map[int]struct {
			result1 grpc.ServerOption
		})
	}
	fake.maxConcurrentStreamsReturnsOnCall[i] = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) MaxMsgSize(arg1 int) grpc.ServerOption {
	fake.maxMsgSizeMutex.Lock()
	ret, specificReturn := fake.maxMsgSizeReturnsOnCall[len(fake.maxMsgSizeArgsForCall)]
	fake.maxMsgSizeArgsForCall = append(fake.maxMsgSizeArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.MaxMsgSizeStub
	fakeReturns := fake.maxMsgSizeReturns
	fake.recordInvocation("MaxMsgSize", []interface{}{arg1})
	fake.maxMsgSizeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) MaxMsgSizeCallCount() int {
	fake.maxMsgSizeMutex.RLock()
	defer fake.maxMsgSizeMutex.RUnlock()
	return len(fake.maxMsgSizeArgsForCall)
}

func (fake *FakeGrpc) MaxMsgSizeCalls(stub func(int) grpc.ServerOption) {
	fake.maxMsgSizeMutex.Lock()
	defer fake.maxMsgSizeMutex.Unlock()
	fake.MaxMsgSizeStub = stub
}

func (fake *FakeGrpc) MaxMsgSizeArgsForCall(i int) int {
	fake.maxMsgSizeMutex.RLock()
	defer fake.maxMsgSizeMutex.RUnlock()
	argsForCall := fake.maxMsgSizeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) MaxMsgSizeReturns(result1 grpc.ServerOption) {
	fake.maxMsgSizeMutex.Lock()
	defer fake.maxMsgSizeMutex.Unlock()
	fake.MaxMsgSizeStub = nil
	fake.maxMsgSizeReturns = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) MaxMsgSizeReturnsOnCall(i int, result1 grpc.ServerOption) {
	fake.maxMsgSizeMutex.Lock()
	defer fake.maxMsgSizeMutex.Unlock()
	fake.MaxMsgSizeStub = nil
	if fake.maxMsgSizeReturnsOnCall == nil {
		fake.maxMsgSizeReturnsOnCall = make(map[int]struct {
			result1 grpc.ServerOption
		})
	}
	fake.maxMsgSizeReturnsOnCall[i] = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) NewClientStream(arg1 context.Context, arg2 *grpc.StreamDesc, arg3 *grpc.ClientConn, arg4 string, arg5 ...grpc.CallOption) (grpc.ClientStream, error) {
	fake.newClientStreamMutex.Lock()
	ret, specificReturn := fake.newClientStreamReturnsOnCall[len(fake.newClientStreamArgsForCall)]
	fake.newClientStreamArgsForCall = append(fake.newClientStreamArgsForCall, struct {
		arg1 context.Context
		arg2 *grpc.StreamDesc
		arg3 *grpc.ClientConn
		arg4 string
		arg5 []grpc.CallOption
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.NewClientStreamStub
	fakeReturns := fake.newClientStreamReturns
	fake.recordInvocation("NewClientStream", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.newClientStreamMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrpc) NewClientStreamCallCount() int {
	fake.newClientStreamMutex.RLock()
	defer fake.newClientStreamMutex.RUnlock()
	return len(fake.newClientStreamArgsForCall)
}

func (fake *FakeGrpc) NewClientStreamCalls(stub func(context.Context, *grpc.StreamDesc, *grpc.ClientConn, string, ...grpc.CallOption) (grpc.ClientStream, error)) {
	fake.newClientStreamMutex.Lock()
	defer fake.newClientStreamMutex.Unlock()
	fake.NewClientStreamStub = stub
}

func (fake *FakeGrpc) NewClientStreamArgsForCall(i int) (context.Context, *grpc.StreamDesc, *grpc.ClientConn, string, []grpc.CallOption) {
	fake.newClientStreamMutex.RLock()
	defer fake.newClientStreamMutex.RUnlock()
	argsForCall := fake.newClientStreamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeGrpc) NewClientStreamReturns(result1 grpc.ClientStream, result2 error) {
	fake.newClientStreamMutex.Lock()
	defer fake.newClientStreamMutex.Unlock()
	fake.NewClientStreamStub = nil
	fake.newClientStreamReturns = struct {
		result1 grpc.ClientStream
		result2 error
	}{result1, result2}
}

func (fake *FakeGrpc) NewClientStreamReturnsOnCall(i int, result1 grpc.ClientStream, result2 error) {
	fake.newClientStreamMutex.Lock()
	defer fake.newClientStreamMutex.Unlock()
	fake.NewClientStreamStub = nil
	if fake.newClientStreamReturnsOnCall == nil {
		fake.newClientStreamReturnsOnCall = make(map[int]struct {
			result1 grpc.ClientStream
			result2 error
		})
	}
	fake.newClientStreamReturnsOnCall[i] = struct {
		result1 grpc.ClientStream
		result2 error
	}{result1, result2}
}

func (fake *FakeGrpc) NewGZIPCompressor() grpc.Compressor {
	fake.newGZIPCompressorMutex.Lock()
	ret, specificReturn := fake.newGZIPCompressorReturnsOnCall[len(fake.newGZIPCompressorArgsForCall)]
	fake.newGZIPCompressorArgsForCall = append(fake.newGZIPCompressorArgsForCall, struct {
	}{})
	stub := fake.NewGZIPCompressorStub
	fakeReturns := fake.newGZIPCompressorReturns
	fake.recordInvocation("NewGZIPCompressor", []interface{}{})
	fake.newGZIPCompressorMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) NewGZIPCompressorCallCount() int {
	fake.newGZIPCompressorMutex.RLock()
	defer fake.newGZIPCompressorMutex.RUnlock()
	return len(fake.newGZIPCompressorArgsForCall)
}

func (fake *FakeGrpc) NewGZIPCompressorCalls(stub func() grpc.Compressor) {
	fake.newGZIPCompressorMutex.Lock()
	defer fake.newGZIPCompressorMutex.Unlock()
	fake.NewGZIPCompressorStub = stub
}

func (fake *FakeGrpc) NewGZIPCompressorReturns(result1 grpc.Compressor) {
	fake.newGZIPCompressorMutex.Lock()
	defer fake.newGZIPCompressorMutex.Unlock()
	fake.NewGZIPCompressorStub = nil
	fake.newGZIPCompressorReturns = struct {
		result1 grpc.Compressor
	}{result1}
}

func (fake *FakeGrpc) NewGZIPCompressorReturnsOnCall(i int, result1 grpc.Compressor) {
	fake.newGZIPCompressorMutex.Lock()
	defer fake.newGZIPCompressorMutex.Unlock()
	fake.NewGZIPCompressorStub = nil
	if fake.newGZIPCompressorReturnsOnCall == nil {
		fake.newGZIPCompressorReturnsOnCall = make(map[int]struct {
			result1 grpc.Compressor
		})
	}
	fake.newGZIPCompressorReturnsOnCall[i] = struct {
		result1 grpc.Compressor
	}{result1}
}

func (fake *FakeGrpc) NewGZIPDecompressor() grpc.Decompressor {
	fake.newGZIPDecompressorMutex.Lock()
	ret, specificReturn := fake.newGZIPDecompressorReturnsOnCall[len(fake.newGZIPDecompressorArgsForCall)]
	fake.newGZIPDecompressorArgsForCall = append(fake.newGZIPDecompressorArgsForCall, struct {
	}{})
	stub := fake.NewGZIPDecompressorStub
	fakeReturns := fake.newGZIPDecompressorReturns
	fake.recordInvocation("NewGZIPDecompressor", []interface{}{})
	fake.newGZIPDecompressorMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) NewGZIPDecompressorCallCount() int {
	fake.newGZIPDecompressorMutex.RLock()
	defer fake.newGZIPDecompressorMutex.RUnlock()
	return len(fake.newGZIPDecompressorArgsForCall)
}

func (fake *FakeGrpc) NewGZIPDecompressorCalls(stub func() grpc.Decompressor) {
	fake.newGZIPDecompressorMutex.Lock()
	defer fake.newGZIPDecompressorMutex.Unlock()
	fake.NewGZIPDecompressorStub = stub
}

func (fake *FakeGrpc) NewGZIPDecompressorReturns(result1 grpc.Decompressor) {
	fake.newGZIPDecompressorMutex.Lock()
	defer fake.newGZIPDecompressorMutex.Unlock()
	fake.NewGZIPDecompressorStub = nil
	fake.newGZIPDecompressorReturns = struct {
		result1 grpc.Decompressor
	}{result1}
}

func (fake *FakeGrpc) NewGZIPDecompressorReturnsOnCall(i int, result1 grpc.Decompressor) {
	fake.newGZIPDecompressorMutex.Lock()
	defer fake.newGZIPDecompressorMutex.Unlock()
	fake.NewGZIPDecompressorStub = nil
	if fake.newGZIPDecompressorReturnsOnCall == nil {
		fake.newGZIPDecompressorReturnsOnCall = make(map[int]struct {
			result1 grpc.Decompressor
		})
	}
	fake.newGZIPDecompressorReturnsOnCall[i] = struct {
		result1 grpc.Decompressor
	}{result1}
}

func (fake *FakeGrpc) NewServer(arg1 ...grpc.ServerOption) *grpc.Server {
	fake.newServerMutex.Lock()
	ret, specificReturn := fake.newServerReturnsOnCall[len(fake.newServerArgsForCall)]
	fake.newServerArgsForCall = append(fake.newServerArgsForCall, struct {
		arg1 []grpc.ServerOption
	}{arg1})
	stub := fake.NewServerStub
	fakeReturns := fake.newServerReturns
	fake.recordInvocation("NewServer", []interface{}{arg1})
	fake.newServerMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) NewServerCallCount() int {
	fake.newServerMutex.RLock()
	defer fake.newServerMutex.RUnlock()
	return len(fake.newServerArgsForCall)
}

func (fake *FakeGrpc) NewServerCalls(stub func(...grpc.ServerOption) *grpc.Server) {
	fake.newServerMutex.Lock()
	defer fake.newServerMutex.Unlock()
	fake.NewServerStub = stub
}

func (fake *FakeGrpc) NewServerArgsForCall(i int) []grpc.ServerOption {
	fake.newServerMutex.RLock()
	defer fake.newServerMutex.RUnlock()
	argsForCall := fake.newServerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) NewServerReturns(result1 *grpc.Server) {
	fake.newServerMutex.Lock()
	defer fake.newServerMutex.Unlock()
	fake.NewServerStub = nil
	fake.newServerReturns = struct {
		result1 *grpc.Server
	}{result1}
}

func (fake *FakeGrpc) NewServerReturnsOnCall(i int, result1 *grpc.Server) {
	fake.newServerMutex.Lock()
	defer fake.newServerMutex.Unlock()
	fake.NewServerStub = nil
	if fake.newServerReturnsOnCall == nil {
		fake.newServerReturnsOnCall = make(map[int]struct {
			result1 *grpc.Server
		})
	}
	fake.newServerReturnsOnCall[i] = struct {
		result1 *grpc.Server
	}{result1}
}

func (fake *FakeGrpc) RPCCompressor(arg1 grpc.Compressor) grpc.ServerOption {
	fake.rPCCompressorMutex.Lock()
	ret, specificReturn := fake.rPCCompressorReturnsOnCall[len(fake.rPCCompressorArgsForCall)]
	fake.rPCCompressorArgsForCall = append(fake.rPCCompressorArgsForCall, struct {
		arg1 grpc.Compressor
	}{arg1})
	stub := fake.RPCCompressorStub
	fakeReturns := fake.rPCCompressorReturns
	fake.recordInvocation("RPCCompressor", []interface{}{arg1})
	fake.rPCCompressorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) RPCCompressorCallCount() int {
	fake.rPCCompressorMutex.RLock()
	defer fake.rPCCompressorMutex.RUnlock()
	return len(fake.rPCCompressorArgsForCall)
}

func (fake *FakeGrpc) RPCCompressorCalls(stub func(grpc.Compressor) grpc.ServerOption) {
	fake.rPCCompressorMutex.Lock()
	defer fake.rPCCompressorMutex.Unlock()
	fake.RPCCompressorStub = stub
}

func (fake *FakeGrpc) RPCCompressorArgsForCall(i int) grpc.Compressor {
	fake.rPCCompressorMutex.RLock()
	defer fake.rPCCompressorMutex.RUnlock()
	argsForCall := fake.rPCCompressorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) RPCCompressorReturns(result1 grpc.ServerOption) {
	fake.rPCCompressorMutex.Lock()
	defer fake.rPCCompressorMutex.Unlock()
	fake.RPCCompressorStub = nil
	fake.rPCCompressorReturns = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) RPCCompressorReturnsOnCall(i int, result1 grpc.ServerOption) {
	fake.rPCCompressorMutex.Lock()
	defer fake.rPCCompressorMutex.Unlock()
	fake.RPCCompressorStub = nil
	if fake.rPCCompressorReturnsOnCall == nil {
		fake.rPCCompressorReturnsOnCall = make(map[int]struct {
			result1 grpc.ServerOption
		})
	}
	fake.rPCCompressorReturnsOnCall[i] = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) RPCDecompressor(arg1 grpc.Decompressor) grpc.ServerOption {
	fake.rPCDecompressorMutex.Lock()
	ret, specificReturn := fake.rPCDecompressorReturnsOnCall[len(fake.rPCDecompressorArgsForCall)]
	fake.rPCDecompressorArgsForCall = append(fake.rPCDecompressorArgsForCall, struct {
		arg1 grpc.Decompressor
	}{arg1})
	stub := fake.RPCDecompressorStub
	fakeReturns := fake.rPCDecompressorReturns
	fake.recordInvocation("RPCDecompressor", []interface{}{arg1})
	fake.rPCDecompressorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) RPCDecompressorCallCount() int {
	fake.rPCDecompressorMutex.RLock()
	defer fake.rPCDecompressorMutex.RUnlock()
	return len(fake.rPCDecompressorArgsForCall)
}

func (fake *FakeGrpc) RPCDecompressorCalls(stub func(grpc.Decompressor) grpc.ServerOption) {
	fake.rPCDecompressorMutex.Lock()
	defer fake.rPCDecompressorMutex.Unlock()
	fake.RPCDecompressorStub = stub
}

func (fake *FakeGrpc) RPCDecompressorArgsForCall(i int) grpc.Decompressor {
	fake.rPCDecompressorMutex.RLock()
	defer fake.rPCDecompressorMutex.RUnlock()
	argsForCall := fake.rPCDecompressorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) RPCDecompressorReturns(result1 grpc.ServerOption) {
	fake.rPCDecompressorMutex.Lock()
	defer fake.rPCDecompressorMutex.Unlock()
	fake.RPCDecompressorStub = nil
	fake.rPCDecompressorReturns = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) RPCDecompressorReturnsOnCall(i int, result1 grpc.ServerOption) {
	fake.rPCDecompressorMutex.Lock()
	defer fake.rPCDecompressorMutex.Unlock()
	fake.RPCDecompressorStub = nil
	if fake.rPCDecompressorReturnsOnCall == nil {
		fake.rPCDecompressorReturnsOnCall = make(map[int]struct {
			result1 grpc.ServerOption
		})
	}
	fake.rPCDecompressorReturnsOnCall[i] = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) RoundRobin(arg1 naming.Resolver) grpc.Balancer {
	fake.roundRobinMutex.Lock()
	ret, specificReturn := fake.roundRobinReturnsOnCall[len(fake.roundRobinArgsForCall)]
	fake.roundRobinArgsForCall = append(fake.roundRobinArgsForCall, struct {
		arg1 naming.Resolver
	}{arg1})
	stub := fake.RoundRobinStub
	fakeReturns := fake.roundRobinReturns
	fake.recordInvocation("RoundRobin", []interface{}{arg1})
	fake.roundRobinMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) RoundRobinCallCount() int {
	fake.roundRobinMutex.RLock()
	defer fake.roundRobinMutex.RUnlock()
	return len(fake.roundRobinArgsForCall)
}

func (fake *FakeGrpc) RoundRobinCalls(stub func(naming.Resolver) grpc.Balancer) {
	fake.roundRobinMutex.Lock()
	defer fake.roundRobinMutex.Unlock()
	fake.RoundRobinStub = stub
}

func (fake *FakeGrpc) RoundRobinArgsForCall(i int) naming.Resolver {
	fake.roundRobinMutex.RLock()
	defer fake.roundRobinMutex.RUnlock()
	argsForCall := fake.roundRobinArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) RoundRobinReturns(result1 grpc.Balancer) {
	fake.roundRobinMutex.Lock()
	defer fake.roundRobinMutex.Unlock()
	fake.RoundRobinStub = nil
	fake.roundRobinReturns = struct {
		result1 grpc.Balancer
	}{result1}
}

func (fake *FakeGrpc) RoundRobinReturnsOnCall(i int, result1 grpc.Balancer) {
	fake.roundRobinMutex.Lock()
	defer fake.roundRobinMutex.Unlock()
	fake.RoundRobinStub = nil
	if fake.roundRobinReturnsOnCall == nil {
		fake.roundRobinReturnsOnCall = make(map[int]struct {
			result1 grpc.Balancer
		})
	}
	fake.roundRobinReturnsOnCall[i] = struct {
		result1 grpc.Balancer
	}{result1}
}

func (fake *FakeGrpc) SendHeader(arg1 context.Context, arg2 metadata.MD) error {
	fake.sendHeaderMutex.Lock()
	ret, specificReturn := fake.sendHeaderReturnsOnCall[len(fake.sendHeaderArgsForCall)]
	fake.sendHeaderArgsForCall = append(fake.sendHeaderArgsForCall, struct {
		arg1 context.Context
		arg2 metadata.MD
	}{arg1, arg2})
	stub := fake.SendHeaderStub
	fakeReturns := fake.sendHeaderReturns
	fake.recordInvocation("SendHeader", []interface{}{arg1, arg2})
	fake.sendHeaderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) SendHeaderCallCount() int {
	fake.sendHeaderMutex.RLock()
	defer fake.sendHeaderMutex.RUnlock()
	return len(fake.sendHeaderArgsForCall)
}

func (fake *FakeGrpc) SendHeaderCalls(stub func(context.Context, metadata.MD) error) {
	fake.sendHeaderMutex.Lock()
	defer fake.sendHeaderMutex.Unlock()
	fake.SendHeaderStub = stub
}

func (fake *FakeGrpc) SendHeaderArgsForCall(i int) (context.Context, metadata.MD) {
	fake.sendHeaderMutex.RLock()
	defer fake.sendHeaderMutex.RUnlock()
	argsForCall := fake.sendHeaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGrpc) SendHeaderReturns(result1 error) {
	fake.sendHeaderMutex.Lock()
	defer fake.sendHeaderMutex.Unlock()
	fake.SendHeaderStub = nil
	fake.sendHeaderReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGrpc) SendHeaderReturnsOnCall(i int, result1 error) {
	fake.sendHeaderMutex.Lock()
	defer fake.sendHeaderMutex.Unlock()
	fake.SendHeaderStub = nil
	if fake.sendHeaderReturnsOnCall == nil {
		fake.sendHeaderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendHeaderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGrpc) SetHeader(arg1 context.Context, arg2 metadata.MD) error {
	fake.setHeaderMutex.Lock()
	ret, specificReturn := fake.setHeaderReturnsOnCall[len(fake.setHeaderArgsForCall)]
	fake.setHeaderArgsForCall = append(fake.setHeaderArgsForCall, struct {
		arg1 context.Context
		arg2 metadata.MD
	}{arg1, arg2})
	stub := fake.SetHeaderStub
	fakeReturns := fake.setHeaderReturns
	fake.recordInvocation("SetHeader", []interface{}{arg1, arg2})
	fake.setHeaderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) SetHeaderCallCount() int {
	fake.setHeaderMutex.RLock()
	defer fake.setHeaderMutex.RUnlock()
	return len(fake.setHeaderArgsForCall)
}

func (fake *FakeGrpc) SetHeaderCalls(stub func(context.Context, metadata.MD) error) {
	fake.setHeaderMutex.Lock()
	defer fake.setHeaderMutex.Unlock()
	fake.SetHeaderStub = stub
}

func (fake *FakeGrpc) SetHeaderArgsForCall(i int) (context.Context, metadata.MD) {
	fake.setHeaderMutex.RLock()
	defer fake.setHeaderMutex.RUnlock()
	argsForCall := fake.setHeaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGrpc) SetHeaderReturns(result1 error) {
	fake.setHeaderMutex.Lock()
	defer fake.setHeaderMutex.Unlock()
	fake.SetHeaderStub = nil
	fake.setHeaderReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGrpc) SetHeaderReturnsOnCall(i int, result1 error) {
	fake.setHeaderMutex.Lock()
	defer fake.setHeaderMutex.Unlock()
	fake.SetHeaderStub = nil
	if fake.setHeaderReturnsOnCall == nil {
		fake.setHeaderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setHeaderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGrpc) SetTrailer(arg1 context.Context, arg2 metadata.MD) error {
	fake.setTrailerMutex.Lock()
	ret, specificReturn := fake.setTrailerReturnsOnCall[len(fake.setTrailerArgsForCall)]
	fake.setTrailerArgsForCall = append(fake.setTrailerArgsForCall, struct {
		arg1 context.Context
		arg2 metadata.MD
	}{arg1, arg2})
	stub := fake.SetTrailerStub
	fakeReturns := fake.setTrailerReturns
	fake.recordInvocation("SetTrailer", []interface{}{arg1, arg2})
	fake.setTrailerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) SetTrailerCallCount() int {
	fake.setTrailerMutex.RLock()
	defer fake.setTrailerMutex.RUnlock()
	return len(fake.setTrailerArgsForCall)
}

func (fake *FakeGrpc) SetTrailerCalls(stub func(context.Context, metadata.MD) error) {
	fake.setTrailerMutex.Lock()
	defer fake.setTrailerMutex.Unlock()
	fake.SetTrailerStub = stub
}

func (fake *FakeGrpc) SetTrailerArgsForCall(i int) (context.Context, metadata.MD) {
	fake.setTrailerMutex.RLock()
	defer fake.setTrailerMutex.RUnlock()
	argsForCall := fake.setTrailerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGrpc) SetTrailerReturns(result1 error) {
	fake.setTrailerMutex.Lock()
	defer fake.setTrailerMutex.Unlock()
	fake.SetTrailerStub = nil
	fake.setTrailerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGrpc) SetTrailerReturnsOnCall(i int, result1 error) {
	fake.setTrailerMutex.Lock()
	defer fake.setTrailerMutex.Unlock()
	fake.SetTrailerStub = nil
	if fake.setTrailerReturnsOnCall == nil {
		fake.setTrailerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setTrailerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGrpc) StatsHandler(arg1 stats.Handler) grpc.ServerOption {
	fake.statsHandlerMutex.Lock()
	ret, specificReturn := fake.statsHandlerReturnsOnCall[len(fake.statsHandlerArgsForCall)]
	fake.statsHandlerArgsForCall = append(fake.statsHandlerArgsForCall, struct {
		arg1 stats.Handler
	}{arg1})
	stub := fake.StatsHandlerStub
	fakeReturns := fake.statsHandlerReturns
	fake.recordInvocation("StatsHandler", []interface{}{arg1})
	fake.statsHandlerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) StatsHandlerCallCount() int {
	fake.statsHandlerMutex.RLock()
	defer fake.statsHandlerMutex.RUnlock()
	return len(fake.statsHandlerArgsForCall)
}

func (fake *FakeGrpc) StatsHandlerCalls(stub func(stats.Handler) grpc.ServerOption) {
	fake.statsHandlerMutex.Lock()
	defer fake.statsHandlerMutex.Unlock()
	fake.StatsHandlerStub = stub
}

func (fake *FakeGrpc) StatsHandlerArgsForCall(i int) stats.Handler {
	fake.statsHandlerMutex.RLock()
	defer fake.statsHandlerMutex.RUnlock()
	argsForCall := fake.statsHandlerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) StatsHandlerReturns(result1 grpc.ServerOption) {
	fake.statsHandlerMutex.Lock()
	defer fake.statsHandlerMutex.Unlock()
	fake.StatsHandlerStub = nil
	fake.statsHandlerReturns = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) StatsHandlerReturnsOnCall(i int, result1 grpc.ServerOption) {
	fake.statsHandlerMutex.Lock()
	defer fake.statsHandlerMutex.Unlock()
	fake.StatsHandlerStub = nil
	if fake.statsHandlerReturnsOnCall == nil {
		fake.statsHandlerReturnsOnCall = make(map[int]struct {
			result1 grpc.ServerOption
		})
	}
	fake.statsHandlerReturnsOnCall[i] = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) StreamInterceptor(arg1 grpc.StreamServerInterceptor) grpc.ServerOption {
	fake.streamInterceptorMutex.Lock()
	ret, specificReturn := fake.streamInterceptorReturnsOnCall[len(fake.streamInterceptorArgsForCall)]
	fake.streamInterceptorArgsForCall = append(fake.streamInterceptorArgsForCall, struct {
		arg1 grpc.StreamServerInterceptor
	}{arg1})
	stub := fake.StreamInterceptorStub
	fakeReturns := fake.streamInterceptorReturns
	fake.recordInvocation("StreamInterceptor", []interface{}{arg1})
	fake.streamInterceptorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) StreamInterceptorCallCount() int {
	fake.streamInterceptorMutex.RLock()
	defer fake.streamInterceptorMutex.RUnlock()
	return len(fake.streamInterceptorArgsForCall)
}

func (fake *FakeGrpc) StreamInterceptorCalls(stub func(grpc.StreamServerInterceptor) grpc.ServerOption) {
	fake.streamInterceptorMutex.Lock()
	defer fake.streamInterceptorMutex.Unlock()
	fake.StreamInterceptorStub = stub
}

func (fake *FakeGrpc) StreamInterceptorArgsForCall(i int) grpc.StreamServerInterceptor {
	fake.streamInterceptorMutex.RLock()
	defer fake.streamInterceptorMutex.RUnlock()
	argsForCall := fake.streamInterceptorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) StreamInterceptorReturns(result1 grpc.ServerOption) {
	fake.streamInterceptorMutex.Lock()
	defer fake.streamInterceptorMutex.Unlock()
	fake.StreamInterceptorStub = nil
	fake.streamInterceptorReturns = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) StreamInterceptorReturnsOnCall(i int, result1 grpc.ServerOption) {
	fake.streamInterceptorMutex.Lock()
	defer fake.streamInterceptorMutex.Unlock()
	fake.StreamInterceptorStub = nil
	if fake.streamInterceptorReturnsOnCall == nil {
		fake.streamInterceptorReturnsOnCall = make(map[int]struct {
			result1 grpc.ServerOption
		})
	}
	fake.streamInterceptorReturnsOnCall[i] = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) Trailer(arg1 *metadata.MD) grpc.CallOption {
	fake.trailerMutex.Lock()
	ret, specificReturn := fake.trailerReturnsOnCall[len(fake.trailerArgsForCall)]
	fake.trailerArgsForCall = append(fake.trailerArgsForCall, struct {
		arg1 *metadata.MD
	}{arg1})
	stub := fake.TrailerStub
	fakeReturns := fake.trailerReturns
	fake.recordInvocation("Trailer", []interface{}{arg1})
	fake.trailerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) TrailerCallCount() int {
	fake.trailerMutex.RLock()
	defer fake.trailerMutex.RUnlock()
	return len(fake.trailerArgsForCall)
}

func (fake *FakeGrpc) TrailerCalls(stub func(*metadata.MD) grpc.CallOption) {
	fake.trailerMutex.Lock()
	defer fake.trailerMutex.Unlock()
	fake.TrailerStub = stub
}

func (fake *FakeGrpc) TrailerArgsForCall(i int) *metadata.MD {
	fake.trailerMutex.RLock()
	defer fake.trailerMutex.RUnlock()
	argsForCall := fake.trailerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) TrailerReturns(result1 grpc.CallOption) {
	fake.trailerMutex.Lock()
	defer fake.trailerMutex.Unlock()
	fake.TrailerStub = nil
	fake.trailerReturns = struct {
		result1 grpc.CallOption
	}{result1}
}

func (fake *FakeGrpc) TrailerReturnsOnCall(i int, result1 grpc.CallOption) {
	fake.trailerMutex.Lock()
	defer fake.trailerMutex.Unlock()
	fake.TrailerStub = nil
	if fake.trailerReturnsOnCall == nil {
		fake.trailerReturnsOnCall = make(map[int]struct {
			result1 grpc.CallOption
		})
	}
	fake.trailerReturnsOnCall[i] = struct {
		result1 grpc.CallOption
	}{result1}
}

func (fake *FakeGrpc) UnaryInterceptor(arg1 grpc.UnaryServerInterceptor) grpc.ServerOption {
	fake.unaryInterceptorMutex.Lock()
	ret, specificReturn := fake.unaryInterceptorReturnsOnCall[len(fake.unaryInterceptorArgsForCall)]
	fake.unaryInterceptorArgsForCall = append(fake.unaryInterceptorArgsForCall, struct {
		arg1 grpc.UnaryServerInterceptor
	}{arg1})
	stub := fake.UnaryInterceptorStub
	fakeReturns := fake.unaryInterceptorReturns
	fake.recordInvocation("UnaryInterceptor", []interface{}{arg1})
	fake.unaryInterceptorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) UnaryInterceptorCallCount() int {
	fake.unaryInterceptorMutex.RLock()
	defer fake.unaryInterceptorMutex.RUnlock()
	return len(fake.unaryInterceptorArgsForCall)
}

func (fake *FakeGrpc) UnaryInterceptorCalls(stub func(grpc.UnaryServerInterceptor) grpc.ServerOption) {
	fake.unaryInterceptorMutex.Lock()
	defer fake.unaryInterceptorMutex.Unlock()
	fake.UnaryInterceptorStub = stub
}

func (fake *FakeGrpc) UnaryInterceptorArgsForCall(i int) grpc.UnaryServerInterceptor {
	fake.unaryInterceptorMutex.RLock()
	defer fake.unaryInterceptorMutex.RUnlock()
	argsForCall := fake.unaryInterceptorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) UnaryInterceptorReturns(result1 grpc.ServerOption) {
	fake.unaryInterceptorMutex.Lock()
	defer fake.unaryInterceptorMutex.Unlock()
	fake.UnaryInterceptorStub = nil
	fake.unaryInterceptorReturns = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) UnaryInterceptorReturnsOnCall(i int, result1 grpc.ServerOption) {
	fake.unaryInterceptorMutex.Lock()
	defer fake.unaryInterceptorMutex.Unlock()
	fake.UnaryInterceptorStub = nil
	if fake.unaryInterceptorReturnsOnCall == nil {
		fake.unaryInterceptorReturnsOnCall = make(map[int]struct {
			result1 grpc.ServerOption
		})
	}
	fake.unaryInterceptorReturnsOnCall[i] = struct {
		result1 grpc.ServerOption
	}{result1}
}

func (fake *FakeGrpc) WithBackoffConfig(arg1 grpc.BackoffConfig) grpc.DialOption {
	fake.withBackoffConfigMutex.Lock()
	ret, specificReturn := fake.withBackoffConfigReturnsOnCall[len(fake.withBackoffConfigArgsForCall)]
	fake.withBackoffConfigArgsForCall = append(fake.withBackoffConfigArgsForCall, struct {
		arg1 grpc.BackoffConfig
	}{arg1})
	stub := fake.WithBackoffConfigStub
	fakeReturns := fake.withBackoffConfigReturns
	fake.recordInvocation("WithBackoffConfig", []interface{}{arg1})
	fake.withBackoffConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithBackoffConfigCallCount() int {
	fake.withBackoffConfigMutex.RLock()
	defer fake.withBackoffConfigMutex.RUnlock()
	return len(fake.withBackoffConfigArgsForCall)
}

func (fake *FakeGrpc) WithBackoffConfigCalls(stub func(grpc.BackoffConfig) grpc.DialOption) {
	fake.withBackoffConfigMutex.Lock()
	defer fake.withBackoffConfigMutex.Unlock()
	fake.WithBackoffConfigStub = stub
}

func (fake *FakeGrpc) WithBackoffConfigArgsForCall(i int) grpc.BackoffConfig {
	fake.withBackoffConfigMutex.RLock()
	defer fake.withBackoffConfigMutex.RUnlock()
	argsForCall := fake.withBackoffConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithBackoffConfigReturns(result1 grpc.DialOption) {
	fake.withBackoffConfigMutex.Lock()
	defer fake.withBackoffConfigMutex.Unlock()
	fake.WithBackoffConfigStub = nil
	fake.withBackoffConfigReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithBackoffConfigReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withBackoffConfigMutex.Lock()
	defer fake.withBackoffConfigMutex.Unlock()
	fake.WithBackoffConfigStub = nil
	if fake.withBackoffConfigReturnsOnCall == nil {
		fake.withBackoffConfigReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withBackoffConfigReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithBackoffMaxDelay(arg1 time.Duration) grpc.DialOption {
	fake.withBackoffMaxDelayMutex.Lock()
	ret, specificReturn := fake.withBackoffMaxDelayReturnsOnCall[len(fake.withBackoffMaxDelayArgsForCall)]
	fake.withBackoffMaxDelayArgsForCall = append(fake.withBackoffMaxDelayArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	stub := fake.WithBackoffMaxDelayStub
	fakeReturns := fake.withBackoffMaxDelayReturns
	fake.recordInvocation("WithBackoffMaxDelay", []interface{}{arg1})
	fake.withBackoffMaxDelayMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithBackoffMaxDelayCallCount() int {
	fake.withBackoffMaxDelayMutex.RLock()
	defer fake.withBackoffMaxDelayMutex.RUnlock()
	return len(fake.withBackoffMaxDelayArgsForCall)
}

func (fake *FakeGrpc) WithBackoffMaxDelayCalls(stub func(time.Duration) grpc.DialOption) {
	fake.withBackoffMaxDelayMutex.Lock()
	defer fake.withBackoffMaxDelayMutex.Unlock()
	fake.WithBackoffMaxDelayStub = stub
}

func (fake *FakeGrpc) WithBackoffMaxDelayArgsForCall(i int) time.Duration {
	fake.withBackoffMaxDelayMutex.RLock()
	defer fake.withBackoffMaxDelayMutex.RUnlock()
	argsForCall := fake.withBackoffMaxDelayArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithBackoffMaxDelayReturns(result1 grpc.DialOption) {
	fake.withBackoffMaxDelayMutex.Lock()
	defer fake.withBackoffMaxDelayMutex.Unlock()
	fake.WithBackoffMaxDelayStub = nil
	fake.withBackoffMaxDelayReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithBackoffMaxDelayReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withBackoffMaxDelayMutex.Lock()
	defer fake.withBackoffMaxDelayMutex.Unlock()
	fake.WithBackoffMaxDelayStub = nil
	if fake.withBackoffMaxDelayReturnsOnCall == nil {
		fake.withBackoffMaxDelayReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withBackoffMaxDelayReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithBalancer(arg1 grpc.Balancer) grpc.DialOption {
	fake.withBalancerMutex.Lock()
	ret, specificReturn := fake.withBalancerReturnsOnCall[len(fake.withBalancerArgsForCall)]
	fake.withBalancerArgsForCall = append(fake.withBalancerArgsForCall, struct {
		arg1 grpc.Balancer
	}{arg1})
	stub := fake.WithBalancerStub
	fakeReturns := fake.withBalancerReturns
	fake.recordInvocation("WithBalancer", []interface{}{arg1})
	fake.withBalancerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithBalancerCallCount() int {
	fake.withBalancerMutex.RLock()
	defer fake.withBalancerMutex.RUnlock()
	return len(fake.withBalancerArgsForCall)
}

func (fake *FakeGrpc) WithBalancerCalls(stub func(grpc.Balancer) grpc.DialOption) {
	fake.withBalancerMutex.Lock()
	defer fake.withBalancerMutex.Unlock()
	fake.WithBalancerStub = stub
}

func (fake *FakeGrpc) WithBalancerArgsForCall(i int) grpc.Balancer {
	fake.withBalancerMutex.RLock()
	defer fake.withBalancerMutex.RUnlock()
	argsForCall := fake.withBalancerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithBalancerReturns(result1 grpc.DialOption) {
	fake.withBalancerMutex.Lock()
	defer fake.withBalancerMutex.Unlock()
	fake.WithBalancerStub = nil
	fake.withBalancerReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithBalancerReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withBalancerMutex.Lock()
	defer fake.withBalancerMutex.Unlock()
	fake.WithBalancerStub = nil
	if fake.withBalancerReturnsOnCall == nil {
		fake.withBalancerReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withBalancerReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithBlock() grpc.DialOption {
	fake.withBlockMutex.Lock()
	ret, specificReturn := fake.withBlockReturnsOnCall[len(fake.withBlockArgsForCall)]
	fake.withBlockArgsForCall = append(fake.withBlockArgsForCall, struct {
	}{})
	stub := fake.WithBlockStub
	fakeReturns := fake.withBlockReturns
	fake.recordInvocation("WithBlock", []interface{}{})
	fake.withBlockMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithBlockCallCount() int {
	fake.withBlockMutex.RLock()
	defer fake.withBlockMutex.RUnlock()
	return len(fake.withBlockArgsForCall)
}

func (fake *FakeGrpc) WithBlockCalls(stub func() grpc.DialOption) {
	fake.withBlockMutex.Lock()
	defer fake.withBlockMutex.Unlock()
	fake.WithBlockStub = stub
}

func (fake *FakeGrpc) WithBlockReturns(result1 grpc.DialOption) {
	fake.withBlockMutex.Lock()
	defer fake.withBlockMutex.Unlock()
	fake.WithBlockStub = nil
	fake.withBlockReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithBlockReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withBlockMutex.Lock()
	defer fake.withBlockMutex.Unlock()
	fake.WithBlockStub = nil
	if fake.withBlockReturnsOnCall == nil {
		fake.withBlockReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withBlockReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithCodec(arg1 grpc.Codec) grpc.DialOption {
	fake.withCodecMutex.Lock()
	ret, specificReturn := fake.withCodecReturnsOnCall[len(fake.withCodecArgsForCall)]
	fake.withCodecArgsForCall = append(fake.withCodecArgsForCall, struct {
		arg1 grpc.Codec
	}{arg1})
	stub := fake.WithCodecStub
	fakeReturns := fake.withCodecReturns
	fake.recordInvocation("WithCodec", []interface{}{arg1})
	fake.withCodecMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithCodecCallCount() int {
	fake.withCodecMutex.RLock()
	defer fake.withCodecMutex.RUnlock()
	return len(fake.withCodecArgsForCall)
}

func (fake *FakeGrpc) WithCodecCalls(stub func(grpc.Codec) grpc.DialOption) {
	fake.withCodecMutex.Lock()
	defer fake.withCodecMutex.Unlock()
	fake.WithCodecStub = stub
}

func (fake *FakeGrpc) WithCodecArgsForCall(i int) grpc.Codec {
	fake.withCodecMutex.RLock()
	defer fake.withCodecMutex.RUnlock()
	argsForCall := fake.withCodecArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithCodecReturns(result1 grpc.DialOption) {
	fake.withCodecMutex.Lock()
	defer fake.withCodecMutex.Unlock()
	fake.WithCodecStub = nil
	fake.withCodecReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithCodecReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withCodecMutex.Lock()
	defer fake.withCodecMutex.Unlock()
	fake.WithCodecStub = nil
	if fake.withCodecReturnsOnCall == nil {
		fake.withCodecReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withCodecReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithCompressor(arg1 grpc.Compressor) grpc.DialOption {
	fake.withCompressorMutex.Lock()
	ret, specificReturn := fake.withCompressorReturnsOnCall[len(fake.withCompressorArgsForCall)]
	fake.withCompressorArgsForCall = append(fake.withCompressorArgsForCall, struct {
		arg1 grpc.Compressor
	}{arg1})
	stub := fake.WithCompressorStub
	fakeReturns := fake.withCompressorReturns
	fake.recordInvocation("WithCompressor", []interface{}{arg1})
	fake.withCompressorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithCompressorCallCount() int {
	fake.withCompressorMutex.RLock()
	defer fake.withCompressorMutex.RUnlock()
	return len(fake.withCompressorArgsForCall)
}

func (fake *FakeGrpc) WithCompressorCalls(stub func(grpc.Compressor) grpc.DialOption) {
	fake.withCompressorMutex.Lock()
	defer fake.withCompressorMutex.Unlock()
	fake.WithCompressorStub = stub
}

func (fake *FakeGrpc) WithCompressorArgsForCall(i int) grpc.Compressor {
	fake.withCompressorMutex.RLock()
	defer fake.withCompressorMutex.RUnlock()
	argsForCall := fake.withCompressorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithCompressorReturns(result1 grpc.DialOption) {
	fake.withCompressorMutex.Lock()
	defer fake.withCompressorMutex.Unlock()
	fake.WithCompressorStub = nil
	fake.withCompressorReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithCompressorReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withCompressorMutex.Lock()
	defer fake.withCompressorMutex.Unlock()
	fake.WithCompressorStub = nil
	if fake.withCompressorReturnsOnCall == nil {
		fake.withCompressorReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withCompressorReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithDecompressor(arg1 grpc.Decompressor) grpc.DialOption {
	fake.withDecompressorMutex.Lock()
	ret, specificReturn := fake.withDecompressorReturnsOnCall[len(fake.withDecompressorArgsForCall)]
	fake.withDecompressorArgsForCall = append(fake.withDecompressorArgsForCall, struct {
		arg1 grpc.Decompressor
	}{arg1})
	stub := fake.WithDecompressorStub
	fakeReturns := fake.withDecompressorReturns
	fake.recordInvocation("WithDecompressor", []interface{}{arg1})
	fake.withDecompressorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithDecompressorCallCount() int {
	fake.withDecompressorMutex.RLock()
	defer fake.withDecompressorMutex.RUnlock()
	return len(fake.withDecompressorArgsForCall)
}

func (fake *FakeGrpc) WithDecompressorCalls(stub func(grpc.Decompressor) grpc.DialOption) {
	fake.withDecompressorMutex.Lock()
	defer fake.withDecompressorMutex.Unlock()
	fake.WithDecompressorStub = stub
}

func (fake *FakeGrpc) WithDecompressorArgsForCall(i int) grpc.Decompressor {
	fake.withDecompressorMutex.RLock()
	defer fake.withDecompressorMutex.RUnlock()
	argsForCall := fake.withDecompressorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithDecompressorReturns(result1 grpc.DialOption) {
	fake.withDecompressorMutex.Lock()
	defer fake.withDecompressorMutex.Unlock()
	fake.WithDecompressorStub = nil
	fake.withDecompressorReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithDecompressorReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withDecompressorMutex.Lock()
	defer fake.withDecompressorMutex.Unlock()
	fake.WithDecompressorStub = nil
	if fake.withDecompressorReturnsOnCall == nil {
		fake.withDecompressorReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withDecompressorReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithDialer(arg1 func(string, time.Duration) (net.Conn, error)) grpc.DialOption {
	fake.withDialerMutex.Lock()
	ret, specificReturn := fake.withDialerReturnsOnCall[len(fake.withDialerArgsForCall)]
	fake.withDialerArgsForCall = append(fake.withDialerArgsForCall, struct {
		arg1 func(string, time.Duration) (net.Conn, error)
	}{arg1})
	stub := fake.WithDialerStub
	fakeReturns := fake.withDialerReturns
	fake.recordInvocation("WithDialer", []interface{}{arg1})
	fake.withDialerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithDialerCallCount() int {
	fake.withDialerMutex.RLock()
	defer fake.withDialerMutex.RUnlock()
	return len(fake.withDialerArgsForCall)
}

func (fake *FakeGrpc) WithDialerCalls(stub func(func(string, time.Duration) (net.Conn, error)) grpc.DialOption) {
	fake.withDialerMutex.Lock()
	defer fake.withDialerMutex.Unlock()
	fake.WithDialerStub = stub
}

func (fake *FakeGrpc) WithDialerArgsForCall(i int) func(string, time.Duration) (net.Conn, error) {
	fake.withDialerMutex.RLock()
	defer fake.withDialerMutex.RUnlock()
	argsForCall := fake.withDialerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithDialerReturns(result1 grpc.DialOption) {
	fake.withDialerMutex.Lock()
	defer fake.withDialerMutex.Unlock()
	fake.WithDialerStub = nil
	fake.withDialerReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithDialerReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withDialerMutex.Lock()
	defer fake.withDialerMutex.Unlock()
	fake.WithDialerStub = nil
	if fake.withDialerReturnsOnCall == nil {
		fake.withDialerReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withDialerReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithInsecure() grpc.DialOption {
	fake.withInsecureMutex.Lock()
	ret, specificReturn := fake.withInsecureReturnsOnCall[len(fake.withInsecureArgsForCall)]
	fake.withInsecureArgsForCall = append(fake.withInsecureArgsForCall, struct {
	}{})
	stub := fake.WithInsecureStub
	fakeReturns := fake.withInsecureReturns
	fake.recordInvocation("WithInsecure", []interface{}{})
	fake.withInsecureMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithInsecureCallCount() int {
	fake.withInsecureMutex.RLock()
	defer fake.withInsecureMutex.RUnlock()
	return len(fake.withInsecureArgsForCall)
}

func (fake *FakeGrpc) WithInsecureCalls(stub func() grpc.DialOption) {
	fake.withInsecureMutex.Lock()
	defer fake.withInsecureMutex.Unlock()
	fake.WithInsecureStub = stub
}

func (fake *FakeGrpc) WithInsecureReturns(result1 grpc.DialOption) {
	fake.withInsecureMutex.Lock()
	defer fake.withInsecureMutex.Unlock()
	fake.WithInsecureStub = nil
	fake.withInsecureReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithInsecureReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withInsecureMutex.Lock()
	defer fake.withInsecureMutex.Unlock()
	fake.WithInsecureStub = nil
	if fake.withInsecureReturnsOnCall == nil {
		fake.withInsecureReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withInsecureReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithPerRPCCredentials(arg1 credentials.PerRPCCredentials) grpc.DialOption {
	fake.withPerRPCCredentialsMutex.Lock()
	ret, specificReturn := fake.withPerRPCCredentialsReturnsOnCall[len(fake.withPerRPCCredentialsArgsForCall)]
	fake.withPerRPCCredentialsArgsForCall = append(fake.withPerRPCCredentialsArgsForCall, struct {
		arg1 credentials.PerRPCCredentials
	}{arg1})
	stub := fake.WithPerRPCCredentialsStub
	fakeReturns := fake.withPerRPCCredentialsReturns
	fake.recordInvocation("WithPerRPCCredentials", []interface{}{arg1})
	fake.withPerRPCCredentialsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithPerRPCCredentialsCallCount() int {
	fake.withPerRPCCredentialsMutex.RLock()
	defer fake.withPerRPCCredentialsMutex.RUnlock()
	return len(fake.withPerRPCCredentialsArgsForCall)
}

func (fake *FakeGrpc) WithPerRPCCredentialsCalls(stub func(credentials.PerRPCCredentials) grpc.DialOption) {
	fake.withPerRPCCredentialsMutex.Lock()
	defer fake.withPerRPCCredentialsMutex.Unlock()
	fake.WithPerRPCCredentialsStub = stub
}

func (fake *FakeGrpc) WithPerRPCCredentialsArgsForCall(i int) credentials.PerRPCCredentials {
	fake.withPerRPCCredentialsMutex.RLock()
	defer fake.withPerRPCCredentialsMutex.RUnlock()
	argsForCall := fake.withPerRPCCredentialsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithPerRPCCredentialsReturns(result1 grpc.DialOption) {
	fake.withPerRPCCredentialsMutex.Lock()
	defer fake.withPerRPCCredentialsMutex.Unlock()
	fake.WithPerRPCCredentialsStub = nil
	fake.withPerRPCCredentialsReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithPerRPCCredentialsReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withPerRPCCredentialsMutex.Lock()
	defer fake.withPerRPCCredentialsMutex.Unlock()
	fake.WithPerRPCCredentialsStub = nil
	if fake.withPerRPCCredentialsReturnsOnCall == nil {
		fake.withPerRPCCredentialsReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withPerRPCCredentialsReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithServiceConfig(arg1 <-chan grpc.ServiceConfig) grpc.DialOption {
	fake.withServiceConfigMutex.Lock()
	ret, specificReturn := fake.withServiceConfigReturnsOnCall[len(fake.withServiceConfigArgsForCall)]
	fake.withServiceConfigArgsForCall = append(fake.withServiceConfigArgsForCall, struct {
		arg1 <-chan grpc.ServiceConfig
	}{arg1})
	stub := fake.WithServiceConfigStub
	fakeReturns := fake.withServiceConfigReturns
	fake.recordInvocation("WithServiceConfig", []interface{}{arg1})
	fake.withServiceConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithServiceConfigCallCount() int {
	fake.withServiceConfigMutex.RLock()
	defer fake.withServiceConfigMutex.RUnlock()
	return len(fake.withServiceConfigArgsForCall)
}

func (fake *FakeGrpc) WithServiceConfigCalls(stub func(<-chan grpc.ServiceConfig) grpc.DialOption) {
	fake.withServiceConfigMutex.Lock()
	defer fake.withServiceConfigMutex.Unlock()
	fake.WithServiceConfigStub = stub
}

func (fake *FakeGrpc) WithServiceConfigArgsForCall(i int) <-chan grpc.ServiceConfig {
	fake.withServiceConfigMutex.RLock()
	defer fake.withServiceConfigMutex.RUnlock()
	argsForCall := fake.withServiceConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithServiceConfigReturns(result1 grpc.DialOption) {
	fake.withServiceConfigMutex.Lock()
	defer fake.withServiceConfigMutex.Unlock()
	fake.WithServiceConfigStub = nil
	fake.withServiceConfigReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithServiceConfigReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withServiceConfigMutex.Lock()
	defer fake.withServiceConfigMutex.Unlock()
	fake.WithServiceConfigStub = nil
	if fake.withServiceConfigReturnsOnCall == nil {
		fake.withServiceConfigReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withServiceConfigReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithStatsHandler(arg1 stats.Handler) grpc.DialOption {
	fake.withStatsHandlerMutex.Lock()
	ret, specificReturn := fake.withStatsHandlerReturnsOnCall[len(fake.withStatsHandlerArgsForCall)]
	fake.withStatsHandlerArgsForCall = append(fake.withStatsHandlerArgsForCall, struct {
		arg1 stats.Handler
	}{arg1})
	stub := fake.WithStatsHandlerStub
	fakeReturns := fake.withStatsHandlerReturns
	fake.recordInvocation("WithStatsHandler", []interface{}{arg1})
	fake.withStatsHandlerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithStatsHandlerCallCount() int {
	fake.withStatsHandlerMutex.RLock()
	defer fake.withStatsHandlerMutex.RUnlock()
	return len(fake.withStatsHandlerArgsForCall)
}

func (fake *FakeGrpc) WithStatsHandlerCalls(stub func(stats.Handler) grpc.DialOption) {
	fake.withStatsHandlerMutex.Lock()
	defer fake.withStatsHandlerMutex.Unlock()
	fake.WithStatsHandlerStub = stub
}

func (fake *FakeGrpc) WithStatsHandlerArgsForCall(i int) stats.Handler {
	fake.withStatsHandlerMutex.RLock()
	defer fake.withStatsHandlerMutex.RUnlock()
	argsForCall := fake.withStatsHandlerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithStatsHandlerReturns(result1 grpc.DialOption) {
	fake.withStatsHandlerMutex.Lock()
	defer fake.withStatsHandlerMutex.Unlock()
	fake.WithStatsHandlerStub = nil
	fake.withStatsHandlerReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithStatsHandlerReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withStatsHandlerMutex.Lock()
	defer fake.withStatsHandlerMutex.Unlock()
	fake.WithStatsHandlerStub = nil
	if fake.withStatsHandlerReturnsOnCall == nil {
		fake.withStatsHandlerReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withStatsHandlerReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithStreamInterceptor(arg1 grpc.StreamClientInterceptor) grpc.DialOption {
	fake.withStreamInterceptorMutex.Lock()
	ret, specificReturn := fake.withStreamInterceptorReturnsOnCall[len(fake.withStreamInterceptorArgsForCall)]
	fake.withStreamInterceptorArgsForCall = append(fake.withStreamInterceptorArgsForCall, struct {
		arg1 grpc.StreamClientInterceptor
	}{arg1})
	stub := fake.WithStreamInterceptorStub
	fakeReturns := fake.withStreamInterceptorReturns
	fake.recordInvocation("WithStreamInterceptor", []interface{}{arg1})
	fake.withStreamInterceptorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithStreamInterceptorCallCount() int {
	fake.withStreamInterceptorMutex.RLock()
	defer fake.withStreamInterceptorMutex.RUnlock()
	return len(fake.withStreamInterceptorArgsForCall)
}

func (fake *FakeGrpc) WithStreamInterceptorCalls(stub func(grpc.StreamClientInterceptor) grpc.DialOption) {
	fake.withStreamInterceptorMutex.Lock()
	defer fake.withStreamInterceptorMutex.Unlock()
	fake.WithStreamInterceptorStub = stub
}

func (fake *FakeGrpc) WithStreamInterceptorArgsForCall(i int) grpc.StreamClientInterceptor {
	fake.withStreamInterceptorMutex.RLock()
	defer fake.withStreamInterceptorMutex.RUnlock()
	argsForCall := fake.withStreamInterceptorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithStreamInterceptorReturns(result1 grpc.DialOption) {
	fake.withStreamInterceptorMutex.Lock()
	defer fake.withStreamInterceptorMutex.Unlock()
	fake.WithStreamInterceptorStub = nil
	fake.withStreamInterceptorReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithStreamInterceptorReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withStreamInterceptorMutex.Lock()
	defer fake.withStreamInterceptorMutex.Unlock()
	fake.WithStreamInterceptorStub = nil
	if fake.withStreamInterceptorReturnsOnCall == nil {
		fake.withStreamInterceptorReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withStreamInterceptorReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithTimeout(arg1 time.Duration) grpc.DialOption {
	fake.withTimeoutMutex.Lock()
	ret, specificReturn := fake.withTimeoutReturnsOnCall[len(fake.withTimeoutArgsForCall)]
	fake.withTimeoutArgsForCall = append(fake.withTimeoutArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	stub := fake.WithTimeoutStub
	fakeReturns := fake.withTimeoutReturns
	fake.recordInvocation("WithTimeout", []interface{}{arg1})
	fake.withTimeoutMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithTimeoutCallCount() int {
	fake.withTimeoutMutex.RLock()
	defer fake.withTimeoutMutex.RUnlock()
	return len(fake.withTimeoutArgsForCall)
}

func (fake *FakeGrpc) WithTimeoutCalls(stub func(time.Duration) grpc.DialOption) {
	fake.withTimeoutMutex.Lock()
	defer fake.withTimeoutMutex.Unlock()
	fake.WithTimeoutStub = stub
}

func (fake *FakeGrpc) WithTimeoutArgsForCall(i int) time.Duration {
	fake.withTimeoutMutex.RLock()
	defer fake.withTimeoutMutex.RUnlock()
	argsForCall := fake.withTimeoutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithTimeoutReturns(result1 grpc.DialOption) {
	fake.withTimeoutMutex.Lock()
	defer fake.withTimeoutMutex.Unlock()
	fake.WithTimeoutStub = nil
	fake.withTimeoutReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithTimeoutReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withTimeoutMutex.Lock()
	defer fake.withTimeoutMutex.Unlock()
	fake.WithTimeoutStub = nil
	if fake.withTimeoutReturnsOnCall == nil {
		fake.withTimeoutReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withTimeoutReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithTransportCredentials(arg1 credentials.TransportCredentials) grpc.DialOption {
	fake.withTransportCredentialsMutex.Lock()
	ret, specificReturn := fake.withTransportCredentialsReturnsOnCall[len(fake.withTransportCredentialsArgsForCall)]
	fake.withTransportCredentialsArgsForCall = append(fake.withTransportCredentialsArgsForCall, struct {
		arg1 credentials.TransportCredentials
	}{arg1})
	stub := fake.WithTransportCredentialsStub
	fakeReturns := fake.withTransportCredentialsReturns
	fake.recordInvocation("WithTransportCredentials", []interface{}{arg1})
	fake.withTransportCredentialsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithTransportCredentialsCallCount() int {
	fake.withTransportCredentialsMutex.RLock()
	defer fake.withTransportCredentialsMutex.RUnlock()
	return len(fake.withTransportCredentialsArgsForCall)
}

func (fake *FakeGrpc) WithTransportCredentialsCalls(stub func(credentials.TransportCredentials) grpc.DialOption) {
	fake.withTransportCredentialsMutex.Lock()
	defer fake.withTransportCredentialsMutex.Unlock()
	fake.WithTransportCredentialsStub = stub
}

func (fake *FakeGrpc) WithTransportCredentialsArgsForCall(i int) credentials.TransportCredentials {
	fake.withTransportCredentialsMutex.RLock()
	defer fake.withTransportCredentialsMutex.RUnlock()
	argsForCall := fake.withTransportCredentialsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithTransportCredentialsReturns(result1 grpc.DialOption) {
	fake.withTransportCredentialsMutex.Lock()
	defer fake.withTransportCredentialsMutex.Unlock()
	fake.WithTransportCredentialsStub = nil
	fake.withTransportCredentialsReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithTransportCredentialsReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withTransportCredentialsMutex.Lock()
	defer fake.withTransportCredentialsMutex.Unlock()
	fake.WithTransportCredentialsStub = nil
	if fake.withTransportCredentialsReturnsOnCall == nil {
		fake.withTransportCredentialsReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withTransportCredentialsReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithUnaryInterceptor(arg1 grpc.UnaryClientInterceptor) grpc.DialOption {
	fake.withUnaryInterceptorMutex.Lock()
	ret, specificReturn := fake.withUnaryInterceptorReturnsOnCall[len(fake.withUnaryInterceptorArgsForCall)]
	fake.withUnaryInterceptorArgsForCall = append(fake.withUnaryInterceptorArgsForCall, struct {
		arg1 grpc.UnaryClientInterceptor
	}{arg1})
	stub := fake.WithUnaryInterceptorStub
	fakeReturns := fake.withUnaryInterceptorReturns
	fake.recordInvocation("WithUnaryInterceptor", []interface{}{arg1})
	fake.withUnaryInterceptorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithUnaryInterceptorCallCount() int {
	fake.withUnaryInterceptorMutex.RLock()
	defer fake.withUnaryInterceptorMutex.RUnlock()
	return len(fake.withUnaryInterceptorArgsForCall)
}

func (fake *FakeGrpc) WithUnaryInterceptorCalls(stub func(grpc.UnaryClientInterceptor) grpc.DialOption) {
	fake.withUnaryInterceptorMutex.Lock()
	defer fake.withUnaryInterceptorMutex.Unlock()
	fake.WithUnaryInterceptorStub = stub
}

func (fake *FakeGrpc) WithUnaryInterceptorArgsForCall(i int) grpc.UnaryClientInterceptor {
	fake.withUnaryInterceptorMutex.RLock()
	defer fake.withUnaryInterceptorMutex.RUnlock()
	argsForCall := fake.withUnaryInterceptorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithUnaryInterceptorReturns(result1 grpc.DialOption) {
	fake.withUnaryInterceptorMutex.Lock()
	defer fake.withUnaryInterceptorMutex.Unlock()
	fake.WithUnaryInterceptorStub = nil
	fake.withUnaryInterceptorReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithUnaryInterceptorReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withUnaryInterceptorMutex.Lock()
	defer fake.withUnaryInterceptorMutex.Unlock()
	fake.WithUnaryInterceptorStub = nil
	if fake.withUnaryInterceptorReturnsOnCall == nil {
		fake.withUnaryInterceptorReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withUnaryInterceptorReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithUserAgent(arg1 string) grpc.DialOption {
	fake.withUserAgentMutex.Lock()
	ret, specificReturn := fake.withUserAgentReturnsOnCall[len(fake.withUserAgentArgsForCall)]
	fake.withUserAgentArgsForCall = append(fake.withUserAgentArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WithUserAgentStub
	fakeReturns := fake.withUserAgentReturns
	fake.recordInvocation("WithUserAgent", []interface{}{arg1})
	fake.withUserAgentMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGrpc) WithUserAgentCallCount() int {
	fake.withUserAgentMutex.RLock()
	defer fake.withUserAgentMutex.RUnlock()
	return len(fake.withUserAgentArgsForCall)
}

func (fake *FakeGrpc) WithUserAgentCalls(stub func(string) grpc.DialOption) {
	fake.withUserAgentMutex.Lock()
	defer fake.withUserAgentMutex.Unlock()
	fake.WithUserAgentStub = stub
}

func (fake *FakeGrpc) WithUserAgentArgsForCall(i int) string {
	fake.withUserAgentMutex.RLock()
	defer fake.withUserAgentMutex.RUnlock()
	argsForCall := fake.withUserAgentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGrpc) WithUserAgentReturns(result1 grpc.DialOption) {
	fake.withUserAgentMutex.Lock()
	defer fake.withUserAgentMutex.Unlock()
	fake.WithUserAgentStub = nil
	fake.withUserAgentReturns = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) WithUserAgentReturnsOnCall(i int, result1 grpc.DialOption) {
	fake.withUserAgentMutex.Lock()
	defer fake.withUserAgentMutex.Unlock()
	fake.WithUserAgentStub = nil
	if fake.withUserAgentReturnsOnCall == nil {
		fake.withUserAgentReturnsOnCall = make(map[int]struct {
			result1 grpc.DialOption
		})
	}
	fake.withUserAgentReturnsOnCall[i] = struct {
		result1 grpc.DialOption
	}{result1}
}

func (fake *FakeGrpc) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.codeMutex.RLock()
	defer fake.codeMutex.RUnlock()
	fake.credsMutex.RLock()
	defer fake.credsMutex.RUnlock()
	fake.customCodecMutex.RLock()
	defer fake.customCodecMutex.RUnlock()
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	fake.dialContextMutex.RLock()
	defer fake.dialContextMutex.RUnlock()
	fake.errorDescMutex.RLock()
	defer fake.errorDescMutex.RUnlock()
	fake.errorfMutex.RLock()
	defer fake.errorfMutex.RUnlock()
	fake.failFastMutex.RLock()
	defer fake.failFastMutex.RUnlock()
	fake.failOnNonTempDialErrorMutex.RLock()
	defer fake.failOnNonTempDialErrorMutex.RUnlock()
	fake.headerMutex.RLock()
	defer fake.headerMutex.RUnlock()
	fake.inTapHandleMutex.RLock()
	defer fake.inTapHandleMutex.RUnlock()
	fake.invokeMutex.RLock()
	defer fake.invokeMutex.RUnlock()
	fake.maxConcurrentStreamsMutex.RLock()
	defer fake.maxConcurrentStreamsMutex.RUnlock()
	fake.maxMsgSizeMutex.RLock()
	defer fake.maxMsgSizeMutex.RUnlock()
	fake.newClientStreamMutex.RLock()
	defer fake.newClientStreamMutex.RUnlock()
	fake.newGZIPCompressorMutex.RLock()
	defer fake.newGZIPCompressorMutex.RUnlock()
	fake.newGZIPDecompressorMutex.RLock()
	defer fake.newGZIPDecompressorMutex.RUnlock()
	fake.newServerMutex.RLock()
	defer fake.newServerMutex.RUnlock()
	fake.rPCCompressorMutex.RLock()
	defer fake.rPCCompressorMutex.RUnlock()
	fake.rPCDecompressorMutex.RLock()
	defer fake.rPCDecompressorMutex.RUnlock()
	fake.roundRobinMutex.RLock()
	defer fake.roundRobinMutex.RUnlock()
	fake.sendHeaderMutex.RLock()
	defer fake.sendHeaderMutex.RUnlock()
	fake.setHeaderMutex.RLock()
	defer fake.setHeaderMutex.RUnlock()
	fake.setTrailerMutex.RLock()
	defer fake.setTrailerMutex.RUnlock()
	fake.statsHandlerMutex.RLock()
	defer fake.statsHandlerMutex.RUnlock()
	fake.streamInterceptorMutex.RLock()
	defer fake.streamInterceptorMutex.RUnlock()
	fake.trailerMutex.RLock()
	defer fake.trailerMutex.RUnlock()
	fake.unaryInterceptorMutex.RLock()
	defer fake.unaryInterceptorMutex.RUnlock()
	fake.withBackoffConfigMutex.RLock()
	defer fake.withBackoffConfigMutex.RUnlock()
	fake.withBackoffMaxDelayMutex.RLock()
	defer fake.withBackoffMaxDelayMutex.RUnlock()
	fake.withBalancerMutex.RLock()
	defer fake.withBalancerMutex.RUnlock()
	fake.withBlockMutex.RLock()
	defer fake.withBlockMutex.RUnlock()
	fake.withCodecMutex.RLock()
	defer fake.withCodecMutex.RUnlock()
	fake.withCompressorMutex.RLock()
	defer fake.withCompressorMutex.RUnlock()
	fake.withDecompressorMutex.RLock()
	defer fake.withDecompressorMutex.RUnlock()
	fake.withDialerMutex.RLock()
	defer fake.withDialerMutex.RUnlock()
	fake.withInsecureMutex.RLock()
	defer fake.withInsecureMutex.RUnlock()
	fake.withPerRPCCredentialsMutex.RLock()
	defer fake.withPerRPCCredentialsMutex.RUnlock()
	fake.withServiceConfigMutex.RLock()
	defer fake.withServiceConfigMutex.RUnlock()
	fake.withStatsHandlerMutex.RLock()
	defer fake.withStatsHandlerMutex.RUnlock()
	fake.withStreamInterceptorMutex.RLock()
	defer fake.withStreamInterceptorMutex.RUnlock()
	fake.withTimeoutMutex.RLock()
	defer fake.withTimeoutMutex.RUnlock()
	fake.withTransportCredentialsMutex.RLock()
	defer fake.withTransportCredentialsMutex.RUnlock()
	fake.withUnaryInterceptorMutex.RLock()
	defer fake.withUnaryInterceptorMutex.RUnlock()
	fake.withUserAgentMutex.RLock()
	defer fake.withUserAgentMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGrpc) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ grpcshim.Grpc = new(FakeGrpc)
