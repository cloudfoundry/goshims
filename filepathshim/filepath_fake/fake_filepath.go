// Code generated by counterfeiter. DO NOT EDIT.
package filepath_fake

import (
	"path/filepath"
	"sync"

	"code.cloudfoundry.org/goshims/filepathshim"
)

type FakeFilepath struct {
	AbsStub        func(string) (string, error)
	absMutex       sync.RWMutex
	absArgsForCall []struct {
		arg1 string
	}
	absReturns struct {
		result1 string
		result2 error
	}
	absReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	BaseStub        func(string) string
	baseMutex       sync.RWMutex
	baseArgsForCall []struct {
		arg1 string
	}
	baseReturns struct {
		result1 string
	}
	baseReturnsOnCall map[int]struct {
		result1 string
	}
	CleanStub        func(string) string
	cleanMutex       sync.RWMutex
	cleanArgsForCall []struct {
		arg1 string
	}
	cleanReturns struct {
		result1 string
	}
	cleanReturnsOnCall map[int]struct {
		result1 string
	}
	DirStub        func(string) string
	dirMutex       sync.RWMutex
	dirArgsForCall []struct {
		arg1 string
	}
	dirReturns struct {
		result1 string
	}
	dirReturnsOnCall map[int]struct {
		result1 string
	}
	EvalSymlinksStub        func(string) (string, error)
	evalSymlinksMutex       sync.RWMutex
	evalSymlinksArgsForCall []struct {
		arg1 string
	}
	evalSymlinksReturns struct {
		result1 string
		result2 error
	}
	evalSymlinksReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ExtStub        func(string) string
	extMutex       sync.RWMutex
	extArgsForCall []struct {
		arg1 string
	}
	extReturns struct {
		result1 string
	}
	extReturnsOnCall map[int]struct {
		result1 string
	}
	FromSlashStub        func(string) string
	fromSlashMutex       sync.RWMutex
	fromSlashArgsForCall []struct {
		arg1 string
	}
	fromSlashReturns struct {
		result1 string
	}
	fromSlashReturnsOnCall map[int]struct {
		result1 string
	}
	GlobStub        func(string) ([]string, error)
	globMutex       sync.RWMutex
	globArgsForCall []struct {
		arg1 string
	}
	globReturns struct {
		result1 []string
		result2 error
	}
	globReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	HasPrefixStub        func(string, string) bool
	hasPrefixMutex       sync.RWMutex
	hasPrefixArgsForCall []struct {
		arg1 string
		arg2 string
	}
	hasPrefixReturns struct {
		result1 bool
	}
	hasPrefixReturnsOnCall map[int]struct {
		result1 bool
	}
	IsAbsStub        func(string) bool
	isAbsMutex       sync.RWMutex
	isAbsArgsForCall []struct {
		arg1 string
	}
	isAbsReturns struct {
		result1 bool
	}
	isAbsReturnsOnCall map[int]struct {
		result1 bool
	}
	JoinStub        func(...string) string
	joinMutex       sync.RWMutex
	joinArgsForCall []struct {
		arg1 []string
	}
	joinReturns struct {
		result1 string
	}
	joinReturnsOnCall map[int]struct {
		result1 string
	}
	MatchStub        func(string, string) (bool, error)
	matchMutex       sync.RWMutex
	matchArgsForCall []struct {
		arg1 string
		arg2 string
	}
	matchReturns struct {
		result1 bool
		result2 error
	}
	matchReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RelStub        func(string, string) (string, error)
	relMutex       sync.RWMutex
	relArgsForCall []struct {
		arg1 string
		arg2 string
	}
	relReturns struct {
		result1 string
		result2 error
	}
	relReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SplitStub        func(string) (string, string)
	splitMutex       sync.RWMutex
	splitArgsForCall []struct {
		arg1 string
	}
	splitReturns struct {
		result1 string
		result2 string
	}
	splitReturnsOnCall map[int]struct {
		result1 string
		result2 string
	}
	SplitListStub        func(string) []string
	splitListMutex       sync.RWMutex
	splitListArgsForCall []struct {
		arg1 string
	}
	splitListReturns struct {
		result1 []string
	}
	splitListReturnsOnCall map[int]struct {
		result1 []string
	}
	ToSlashStub        func(string) string
	toSlashMutex       sync.RWMutex
	toSlashArgsForCall []struct {
		arg1 string
	}
	toSlashReturns struct {
		result1 string
	}
	toSlashReturnsOnCall map[int]struct {
		result1 string
	}
	VolumeNameStub        func(string) string
	volumeNameMutex       sync.RWMutex
	volumeNameArgsForCall []struct {
		arg1 string
	}
	volumeNameReturns struct {
		result1 string
	}
	volumeNameReturnsOnCall map[int]struct {
		result1 string
	}
	WalkStub        func(string, filepath.WalkFunc) error
	walkMutex       sync.RWMutex
	walkArgsForCall []struct {
		arg1 string
		arg2 filepath.WalkFunc
	}
	walkReturns struct {
		result1 error
	}
	walkReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFilepath) Abs(arg1 string) (string, error) {
	fake.absMutex.Lock()
	ret, specificReturn := fake.absReturnsOnCall[len(fake.absArgsForCall)]
	fake.absArgsForCall = append(fake.absArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AbsStub
	fakeReturns := fake.absReturns
	fake.recordInvocation("Abs", []interface{}{arg1})
	fake.absMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) AbsCallCount() int {
	fake.absMutex.RLock()
	defer fake.absMutex.RUnlock()
	return len(fake.absArgsForCall)
}

func (fake *FakeFilepath) AbsCalls(stub func(string) (string, error)) {
	fake.absMutex.Lock()
	defer fake.absMutex.Unlock()
	fake.AbsStub = stub
}

func (fake *FakeFilepath) AbsArgsForCall(i int) string {
	fake.absMutex.RLock()
	defer fake.absMutex.RUnlock()
	argsForCall := fake.absArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) AbsReturns(result1 string, result2 error) {
	fake.absMutex.Lock()
	defer fake.absMutex.Unlock()
	fake.AbsStub = nil
	fake.absReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) AbsReturnsOnCall(i int, result1 string, result2 error) {
	fake.absMutex.Lock()
	defer fake.absMutex.Unlock()
	fake.AbsStub = nil
	if fake.absReturnsOnCall == nil {
		fake.absReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.absReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) Base(arg1 string) string {
	fake.baseMutex.Lock()
	ret, specificReturn := fake.baseReturnsOnCall[len(fake.baseArgsForCall)]
	fake.baseArgsForCall = append(fake.baseArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.BaseStub
	fakeReturns := fake.baseReturns
	fake.recordInvocation("Base", []interface{}{arg1})
	fake.baseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) BaseCallCount() int {
	fake.baseMutex.RLock()
	defer fake.baseMutex.RUnlock()
	return len(fake.baseArgsForCall)
}

func (fake *FakeFilepath) BaseCalls(stub func(string) string) {
	fake.baseMutex.Lock()
	defer fake.baseMutex.Unlock()
	fake.BaseStub = stub
}

func (fake *FakeFilepath) BaseArgsForCall(i int) string {
	fake.baseMutex.RLock()
	defer fake.baseMutex.RUnlock()
	argsForCall := fake.baseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) BaseReturns(result1 string) {
	fake.baseMutex.Lock()
	defer fake.baseMutex.Unlock()
	fake.BaseStub = nil
	fake.baseReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) BaseReturnsOnCall(i int, result1 string) {
	fake.baseMutex.Lock()
	defer fake.baseMutex.Unlock()
	fake.BaseStub = nil
	if fake.baseReturnsOnCall == nil {
		fake.baseReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.baseReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) Clean(arg1 string) string {
	fake.cleanMutex.Lock()
	ret, specificReturn := fake.cleanReturnsOnCall[len(fake.cleanArgsForCall)]
	fake.cleanArgsForCall = append(fake.cleanArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CleanStub
	fakeReturns := fake.cleanReturns
	fake.recordInvocation("Clean", []interface{}{arg1})
	fake.cleanMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) CleanCallCount() int {
	fake.cleanMutex.RLock()
	defer fake.cleanMutex.RUnlock()
	return len(fake.cleanArgsForCall)
}

func (fake *FakeFilepath) CleanCalls(stub func(string) string) {
	fake.cleanMutex.Lock()
	defer fake.cleanMutex.Unlock()
	fake.CleanStub = stub
}

func (fake *FakeFilepath) CleanArgsForCall(i int) string {
	fake.cleanMutex.RLock()
	defer fake.cleanMutex.RUnlock()
	argsForCall := fake.cleanArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) CleanReturns(result1 string) {
	fake.cleanMutex.Lock()
	defer fake.cleanMutex.Unlock()
	fake.CleanStub = nil
	fake.cleanReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) CleanReturnsOnCall(i int, result1 string) {
	fake.cleanMutex.Lock()
	defer fake.cleanMutex.Unlock()
	fake.CleanStub = nil
	if fake.cleanReturnsOnCall == nil {
		fake.cleanReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cleanReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) Dir(arg1 string) string {
	fake.dirMutex.Lock()
	ret, specificReturn := fake.dirReturnsOnCall[len(fake.dirArgsForCall)]
	fake.dirArgsForCall = append(fake.dirArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DirStub
	fakeReturns := fake.dirReturns
	fake.recordInvocation("Dir", []interface{}{arg1})
	fake.dirMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) DirCallCount() int {
	fake.dirMutex.RLock()
	defer fake.dirMutex.RUnlock()
	return len(fake.dirArgsForCall)
}

func (fake *FakeFilepath) DirCalls(stub func(string) string) {
	fake.dirMutex.Lock()
	defer fake.dirMutex.Unlock()
	fake.DirStub = stub
}

func (fake *FakeFilepath) DirArgsForCall(i int) string {
	fake.dirMutex.RLock()
	defer fake.dirMutex.RUnlock()
	argsForCall := fake.dirArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) DirReturns(result1 string) {
	fake.dirMutex.Lock()
	defer fake.dirMutex.Unlock()
	fake.DirStub = nil
	fake.dirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) DirReturnsOnCall(i int, result1 string) {
	fake.dirMutex.Lock()
	defer fake.dirMutex.Unlock()
	fake.DirStub = nil
	if fake.dirReturnsOnCall == nil {
		fake.dirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.dirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) EvalSymlinks(arg1 string) (string, error) {
	fake.evalSymlinksMutex.Lock()
	ret, specificReturn := fake.evalSymlinksReturnsOnCall[len(fake.evalSymlinksArgsForCall)]
	fake.evalSymlinksArgsForCall = append(fake.evalSymlinksArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.EvalSymlinksStub
	fakeReturns := fake.evalSymlinksReturns
	fake.recordInvocation("EvalSymlinks", []interface{}{arg1})
	fake.evalSymlinksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) EvalSymlinksCallCount() int {
	fake.evalSymlinksMutex.RLock()
	defer fake.evalSymlinksMutex.RUnlock()
	return len(fake.evalSymlinksArgsForCall)
}

func (fake *FakeFilepath) EvalSymlinksCalls(stub func(string) (string, error)) {
	fake.evalSymlinksMutex.Lock()
	defer fake.evalSymlinksMutex.Unlock()
	fake.EvalSymlinksStub = stub
}

func (fake *FakeFilepath) EvalSymlinksArgsForCall(i int) string {
	fake.evalSymlinksMutex.RLock()
	defer fake.evalSymlinksMutex.RUnlock()
	argsForCall := fake.evalSymlinksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) EvalSymlinksReturns(result1 string, result2 error) {
	fake.evalSymlinksMutex.Lock()
	defer fake.evalSymlinksMutex.Unlock()
	fake.EvalSymlinksStub = nil
	fake.evalSymlinksReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) EvalSymlinksReturnsOnCall(i int, result1 string, result2 error) {
	fake.evalSymlinksMutex.Lock()
	defer fake.evalSymlinksMutex.Unlock()
	fake.EvalSymlinksStub = nil
	if fake.evalSymlinksReturnsOnCall == nil {
		fake.evalSymlinksReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.evalSymlinksReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) Ext(arg1 string) string {
	fake.extMutex.Lock()
	ret, specificReturn := fake.extReturnsOnCall[len(fake.extArgsForCall)]
	fake.extArgsForCall = append(fake.extArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ExtStub
	fakeReturns := fake.extReturns
	fake.recordInvocation("Ext", []interface{}{arg1})
	fake.extMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) ExtCallCount() int {
	fake.extMutex.RLock()
	defer fake.extMutex.RUnlock()
	return len(fake.extArgsForCall)
}

func (fake *FakeFilepath) ExtCalls(stub func(string) string) {
	fake.extMutex.Lock()
	defer fake.extMutex.Unlock()
	fake.ExtStub = stub
}

func (fake *FakeFilepath) ExtArgsForCall(i int) string {
	fake.extMutex.RLock()
	defer fake.extMutex.RUnlock()
	argsForCall := fake.extArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) ExtReturns(result1 string) {
	fake.extMutex.Lock()
	defer fake.extMutex.Unlock()
	fake.ExtStub = nil
	fake.extReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) ExtReturnsOnCall(i int, result1 string) {
	fake.extMutex.Lock()
	defer fake.extMutex.Unlock()
	fake.ExtStub = nil
	if fake.extReturnsOnCall == nil {
		fake.extReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.extReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) FromSlash(arg1 string) string {
	fake.fromSlashMutex.Lock()
	ret, specificReturn := fake.fromSlashReturnsOnCall[len(fake.fromSlashArgsForCall)]
	fake.fromSlashArgsForCall = append(fake.fromSlashArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FromSlashStub
	fakeReturns := fake.fromSlashReturns
	fake.recordInvocation("FromSlash", []interface{}{arg1})
	fake.fromSlashMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) FromSlashCallCount() int {
	fake.fromSlashMutex.RLock()
	defer fake.fromSlashMutex.RUnlock()
	return len(fake.fromSlashArgsForCall)
}

func (fake *FakeFilepath) FromSlashCalls(stub func(string) string) {
	fake.fromSlashMutex.Lock()
	defer fake.fromSlashMutex.Unlock()
	fake.FromSlashStub = stub
}

func (fake *FakeFilepath) FromSlashArgsForCall(i int) string {
	fake.fromSlashMutex.RLock()
	defer fake.fromSlashMutex.RUnlock()
	argsForCall := fake.fromSlashArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) FromSlashReturns(result1 string) {
	fake.fromSlashMutex.Lock()
	defer fake.fromSlashMutex.Unlock()
	fake.FromSlashStub = nil
	fake.fromSlashReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) FromSlashReturnsOnCall(i int, result1 string) {
	fake.fromSlashMutex.Lock()
	defer fake.fromSlashMutex.Unlock()
	fake.FromSlashStub = nil
	if fake.fromSlashReturnsOnCall == nil {
		fake.fromSlashReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.fromSlashReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) Glob(arg1 string) ([]string, error) {
	fake.globMutex.Lock()
	ret, specificReturn := fake.globReturnsOnCall[len(fake.globArgsForCall)]
	fake.globArgsForCall = append(fake.globArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GlobStub
	fakeReturns := fake.globReturns
	fake.recordInvocation("Glob", []interface{}{arg1})
	fake.globMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) GlobCallCount() int {
	fake.globMutex.RLock()
	defer fake.globMutex.RUnlock()
	return len(fake.globArgsForCall)
}

func (fake *FakeFilepath) GlobCalls(stub func(string) ([]string, error)) {
	fake.globMutex.Lock()
	defer fake.globMutex.Unlock()
	fake.GlobStub = stub
}

func (fake *FakeFilepath) GlobArgsForCall(i int) string {
	fake.globMutex.RLock()
	defer fake.globMutex.RUnlock()
	argsForCall := fake.globArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) GlobReturns(result1 []string, result2 error) {
	fake.globMutex.Lock()
	defer fake.globMutex.Unlock()
	fake.GlobStub = nil
	fake.globReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) GlobReturnsOnCall(i int, result1 []string, result2 error) {
	fake.globMutex.Lock()
	defer fake.globMutex.Unlock()
	fake.GlobStub = nil
	if fake.globReturnsOnCall == nil {
		fake.globReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.globReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) HasPrefix(arg1 string, arg2 string) bool {
	fake.hasPrefixMutex.Lock()
	ret, specificReturn := fake.hasPrefixReturnsOnCall[len(fake.hasPrefixArgsForCall)]
	fake.hasPrefixArgsForCall = append(fake.hasPrefixArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.HasPrefixStub
	fakeReturns := fake.hasPrefixReturns
	fake.recordInvocation("HasPrefix", []interface{}{arg1, arg2})
	fake.hasPrefixMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) HasPrefixCallCount() int {
	fake.hasPrefixMutex.RLock()
	defer fake.hasPrefixMutex.RUnlock()
	return len(fake.hasPrefixArgsForCall)
}

func (fake *FakeFilepath) HasPrefixCalls(stub func(string, string) bool) {
	fake.hasPrefixMutex.Lock()
	defer fake.hasPrefixMutex.Unlock()
	fake.HasPrefixStub = stub
}

func (fake *FakeFilepath) HasPrefixArgsForCall(i int) (string, string) {
	fake.hasPrefixMutex.RLock()
	defer fake.hasPrefixMutex.RUnlock()
	argsForCall := fake.hasPrefixArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFilepath) HasPrefixReturns(result1 bool) {
	fake.hasPrefixMutex.Lock()
	defer fake.hasPrefixMutex.Unlock()
	fake.HasPrefixStub = nil
	fake.hasPrefixReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFilepath) HasPrefixReturnsOnCall(i int, result1 bool) {
	fake.hasPrefixMutex.Lock()
	defer fake.hasPrefixMutex.Unlock()
	fake.HasPrefixStub = nil
	if fake.hasPrefixReturnsOnCall == nil {
		fake.hasPrefixReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasPrefixReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFilepath) IsAbs(arg1 string) bool {
	fake.isAbsMutex.Lock()
	ret, specificReturn := fake.isAbsReturnsOnCall[len(fake.isAbsArgsForCall)]
	fake.isAbsArgsForCall = append(fake.isAbsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsAbsStub
	fakeReturns := fake.isAbsReturns
	fake.recordInvocation("IsAbs", []interface{}{arg1})
	fake.isAbsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) IsAbsCallCount() int {
	fake.isAbsMutex.RLock()
	defer fake.isAbsMutex.RUnlock()
	return len(fake.isAbsArgsForCall)
}

func (fake *FakeFilepath) IsAbsCalls(stub func(string) bool) {
	fake.isAbsMutex.Lock()
	defer fake.isAbsMutex.Unlock()
	fake.IsAbsStub = stub
}

func (fake *FakeFilepath) IsAbsArgsForCall(i int) string {
	fake.isAbsMutex.RLock()
	defer fake.isAbsMutex.RUnlock()
	argsForCall := fake.isAbsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) IsAbsReturns(result1 bool) {
	fake.isAbsMutex.Lock()
	defer fake.isAbsMutex.Unlock()
	fake.IsAbsStub = nil
	fake.isAbsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFilepath) IsAbsReturnsOnCall(i int, result1 bool) {
	fake.isAbsMutex.Lock()
	defer fake.isAbsMutex.Unlock()
	fake.IsAbsStub = nil
	if fake.isAbsReturnsOnCall == nil {
		fake.isAbsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isAbsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFilepath) Join(arg1 ...string) string {
	fake.joinMutex.Lock()
	ret, specificReturn := fake.joinReturnsOnCall[len(fake.joinArgsForCall)]
	fake.joinArgsForCall = append(fake.joinArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.JoinStub
	fakeReturns := fake.joinReturns
	fake.recordInvocation("Join", []interface{}{arg1})
	fake.joinMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) JoinCallCount() int {
	fake.joinMutex.RLock()
	defer fake.joinMutex.RUnlock()
	return len(fake.joinArgsForCall)
}

func (fake *FakeFilepath) JoinCalls(stub func(...string) string) {
	fake.joinMutex.Lock()
	defer fake.joinMutex.Unlock()
	fake.JoinStub = stub
}

func (fake *FakeFilepath) JoinArgsForCall(i int) []string {
	fake.joinMutex.RLock()
	defer fake.joinMutex.RUnlock()
	argsForCall := fake.joinArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) JoinReturns(result1 string) {
	fake.joinMutex.Lock()
	defer fake.joinMutex.Unlock()
	fake.JoinStub = nil
	fake.joinReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) JoinReturnsOnCall(i int, result1 string) {
	fake.joinMutex.Lock()
	defer fake.joinMutex.Unlock()
	fake.JoinStub = nil
	if fake.joinReturnsOnCall == nil {
		fake.joinReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.joinReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) Match(arg1 string, arg2 string) (bool, error) {
	fake.matchMutex.Lock()
	ret, specificReturn := fake.matchReturnsOnCall[len(fake.matchArgsForCall)]
	fake.matchArgsForCall = append(fake.matchArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.MatchStub
	fakeReturns := fake.matchReturns
	fake.recordInvocation("Match", []interface{}{arg1, arg2})
	fake.matchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) MatchCallCount() int {
	fake.matchMutex.RLock()
	defer fake.matchMutex.RUnlock()
	return len(fake.matchArgsForCall)
}

func (fake *FakeFilepath) MatchCalls(stub func(string, string) (bool, error)) {
	fake.matchMutex.Lock()
	defer fake.matchMutex.Unlock()
	fake.MatchStub = stub
}

func (fake *FakeFilepath) MatchArgsForCall(i int) (string, string) {
	fake.matchMutex.RLock()
	defer fake.matchMutex.RUnlock()
	argsForCall := fake.matchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFilepath) MatchReturns(result1 bool, result2 error) {
	fake.matchMutex.Lock()
	defer fake.matchMutex.Unlock()
	fake.MatchStub = nil
	fake.matchReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) MatchReturnsOnCall(i int, result1 bool, result2 error) {
	fake.matchMutex.Lock()
	defer fake.matchMutex.Unlock()
	fake.MatchStub = nil
	if fake.matchReturnsOnCall == nil {
		fake.matchReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.matchReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) Rel(arg1 string, arg2 string) (string, error) {
	fake.relMutex.Lock()
	ret, specificReturn := fake.relReturnsOnCall[len(fake.relArgsForCall)]
	fake.relArgsForCall = append(fake.relArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RelStub
	fakeReturns := fake.relReturns
	fake.recordInvocation("Rel", []interface{}{arg1, arg2})
	fake.relMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) RelCallCount() int {
	fake.relMutex.RLock()
	defer fake.relMutex.RUnlock()
	return len(fake.relArgsForCall)
}

func (fake *FakeFilepath) RelCalls(stub func(string, string) (string, error)) {
	fake.relMutex.Lock()
	defer fake.relMutex.Unlock()
	fake.RelStub = stub
}

func (fake *FakeFilepath) RelArgsForCall(i int) (string, string) {
	fake.relMutex.RLock()
	defer fake.relMutex.RUnlock()
	argsForCall := fake.relArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFilepath) RelReturns(result1 string, result2 error) {
	fake.relMutex.Lock()
	defer fake.relMutex.Unlock()
	fake.RelStub = nil
	fake.relReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) RelReturnsOnCall(i int, result1 string, result2 error) {
	fake.relMutex.Lock()
	defer fake.relMutex.Unlock()
	fake.RelStub = nil
	if fake.relReturnsOnCall == nil {
		fake.relReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.relReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFilepath) Split(arg1 string) (string, string) {
	fake.splitMutex.Lock()
	ret, specificReturn := fake.splitReturnsOnCall[len(fake.splitArgsForCall)]
	fake.splitArgsForCall = append(fake.splitArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SplitStub
	fakeReturns := fake.splitReturns
	fake.recordInvocation("Split", []interface{}{arg1})
	fake.splitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFilepath) SplitCallCount() int {
	fake.splitMutex.RLock()
	defer fake.splitMutex.RUnlock()
	return len(fake.splitArgsForCall)
}

func (fake *FakeFilepath) SplitCalls(stub func(string) (string, string)) {
	fake.splitMutex.Lock()
	defer fake.splitMutex.Unlock()
	fake.SplitStub = stub
}

func (fake *FakeFilepath) SplitArgsForCall(i int) string {
	fake.splitMutex.RLock()
	defer fake.splitMutex.RUnlock()
	argsForCall := fake.splitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) SplitReturns(result1 string, result2 string) {
	fake.splitMutex.Lock()
	defer fake.splitMutex.Unlock()
	fake.SplitStub = nil
	fake.splitReturns = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeFilepath) SplitReturnsOnCall(i int, result1 string, result2 string) {
	fake.splitMutex.Lock()
	defer fake.splitMutex.Unlock()
	fake.SplitStub = nil
	if fake.splitReturnsOnCall == nil {
		fake.splitReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
		})
	}
	fake.splitReturnsOnCall[i] = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeFilepath) SplitList(arg1 string) []string {
	fake.splitListMutex.Lock()
	ret, specificReturn := fake.splitListReturnsOnCall[len(fake.splitListArgsForCall)]
	fake.splitListArgsForCall = append(fake.splitListArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SplitListStub
	fakeReturns := fake.splitListReturns
	fake.recordInvocation("SplitList", []interface{}{arg1})
	fake.splitListMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) SplitListCallCount() int {
	fake.splitListMutex.RLock()
	defer fake.splitListMutex.RUnlock()
	return len(fake.splitListArgsForCall)
}

func (fake *FakeFilepath) SplitListCalls(stub func(string) []string) {
	fake.splitListMutex.Lock()
	defer fake.splitListMutex.Unlock()
	fake.SplitListStub = stub
}

func (fake *FakeFilepath) SplitListArgsForCall(i int) string {
	fake.splitListMutex.RLock()
	defer fake.splitListMutex.RUnlock()
	argsForCall := fake.splitListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) SplitListReturns(result1 []string) {
	fake.splitListMutex.Lock()
	defer fake.splitListMutex.Unlock()
	fake.SplitListStub = nil
	fake.splitListReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeFilepath) SplitListReturnsOnCall(i int, result1 []string) {
	fake.splitListMutex.Lock()
	defer fake.splitListMutex.Unlock()
	fake.SplitListStub = nil
	if fake.splitListReturnsOnCall == nil {
		fake.splitListReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.splitListReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeFilepath) ToSlash(arg1 string) string {
	fake.toSlashMutex.Lock()
	ret, specificReturn := fake.toSlashReturnsOnCall[len(fake.toSlashArgsForCall)]
	fake.toSlashArgsForCall = append(fake.toSlashArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ToSlashStub
	fakeReturns := fake.toSlashReturns
	fake.recordInvocation("ToSlash", []interface{}{arg1})
	fake.toSlashMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) ToSlashCallCount() int {
	fake.toSlashMutex.RLock()
	defer fake.toSlashMutex.RUnlock()
	return len(fake.toSlashArgsForCall)
}

func (fake *FakeFilepath) ToSlashCalls(stub func(string) string) {
	fake.toSlashMutex.Lock()
	defer fake.toSlashMutex.Unlock()
	fake.ToSlashStub = stub
}

func (fake *FakeFilepath) ToSlashArgsForCall(i int) string {
	fake.toSlashMutex.RLock()
	defer fake.toSlashMutex.RUnlock()
	argsForCall := fake.toSlashArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) ToSlashReturns(result1 string) {
	fake.toSlashMutex.Lock()
	defer fake.toSlashMutex.Unlock()
	fake.ToSlashStub = nil
	fake.toSlashReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) ToSlashReturnsOnCall(i int, result1 string) {
	fake.toSlashMutex.Lock()
	defer fake.toSlashMutex.Unlock()
	fake.ToSlashStub = nil
	if fake.toSlashReturnsOnCall == nil {
		fake.toSlashReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.toSlashReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) VolumeName(arg1 string) string {
	fake.volumeNameMutex.Lock()
	ret, specificReturn := fake.volumeNameReturnsOnCall[len(fake.volumeNameArgsForCall)]
	fake.volumeNameArgsForCall = append(fake.volumeNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.VolumeNameStub
	fakeReturns := fake.volumeNameReturns
	fake.recordInvocation("VolumeName", []interface{}{arg1})
	fake.volumeNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) VolumeNameCallCount() int {
	fake.volumeNameMutex.RLock()
	defer fake.volumeNameMutex.RUnlock()
	return len(fake.volumeNameArgsForCall)
}

func (fake *FakeFilepath) VolumeNameCalls(stub func(string) string) {
	fake.volumeNameMutex.Lock()
	defer fake.volumeNameMutex.Unlock()
	fake.VolumeNameStub = stub
}

func (fake *FakeFilepath) VolumeNameArgsForCall(i int) string {
	fake.volumeNameMutex.RLock()
	defer fake.volumeNameMutex.RUnlock()
	argsForCall := fake.volumeNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFilepath) VolumeNameReturns(result1 string) {
	fake.volumeNameMutex.Lock()
	defer fake.volumeNameMutex.Unlock()
	fake.VolumeNameStub = nil
	fake.volumeNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) VolumeNameReturnsOnCall(i int, result1 string) {
	fake.volumeNameMutex.Lock()
	defer fake.volumeNameMutex.Unlock()
	fake.VolumeNameStub = nil
	if fake.volumeNameReturnsOnCall == nil {
		fake.volumeNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.volumeNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFilepath) Walk(arg1 string, arg2 filepath.WalkFunc) error {
	fake.walkMutex.Lock()
	ret, specificReturn := fake.walkReturnsOnCall[len(fake.walkArgsForCall)]
	fake.walkArgsForCall = append(fake.walkArgsForCall, struct {
		arg1 string
		arg2 filepath.WalkFunc
	}{arg1, arg2})
	stub := fake.WalkStub
	fakeReturns := fake.walkReturns
	fake.recordInvocation("Walk", []interface{}{arg1, arg2})
	fake.walkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFilepath) WalkCallCount() int {
	fake.walkMutex.RLock()
	defer fake.walkMutex.RUnlock()
	return len(fake.walkArgsForCall)
}

func (fake *FakeFilepath) WalkCalls(stub func(string, filepath.WalkFunc) error) {
	fake.walkMutex.Lock()
	defer fake.walkMutex.Unlock()
	fake.WalkStub = stub
}

func (fake *FakeFilepath) WalkArgsForCall(i int) (string, filepath.WalkFunc) {
	fake.walkMutex.RLock()
	defer fake.walkMutex.RUnlock()
	argsForCall := fake.walkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFilepath) WalkReturns(result1 error) {
	fake.walkMutex.Lock()
	defer fake.walkMutex.Unlock()
	fake.WalkStub = nil
	fake.walkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFilepath) WalkReturnsOnCall(i int, result1 error) {
	fake.walkMutex.Lock()
	defer fake.walkMutex.Unlock()
	fake.WalkStub = nil
	if fake.walkReturnsOnCall == nil {
		fake.walkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.walkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFilepath) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.absMutex.RLock()
	defer fake.absMutex.RUnlock()
	fake.baseMutex.RLock()
	defer fake.baseMutex.RUnlock()
	fake.cleanMutex.RLock()
	defer fake.cleanMutex.RUnlock()
	fake.dirMutex.RLock()
	defer fake.dirMutex.RUnlock()
	fake.evalSymlinksMutex.RLock()
	defer fake.evalSymlinksMutex.RUnlock()
	fake.extMutex.RLock()
	defer fake.extMutex.RUnlock()
	fake.fromSlashMutex.RLock()
	defer fake.fromSlashMutex.RUnlock()
	fake.globMutex.RLock()
	defer fake.globMutex.RUnlock()
	fake.hasPrefixMutex.RLock()
	defer fake.hasPrefixMutex.RUnlock()
	fake.isAbsMutex.RLock()
	defer fake.isAbsMutex.RUnlock()
	fake.joinMutex.RLock()
	defer fake.joinMutex.RUnlock()
	fake.matchMutex.RLock()
	defer fake.matchMutex.RUnlock()
	fake.relMutex.RLock()
	defer fake.relMutex.RUnlock()
	fake.splitMutex.RLock()
	defer fake.splitMutex.RUnlock()
	fake.splitListMutex.RLock()
	defer fake.splitListMutex.RUnlock()
	fake.toSlashMutex.RLock()
	defer fake.toSlashMutex.RUnlock()
	fake.volumeNameMutex.RLock()
	defer fake.volumeNameMutex.RUnlock()
	fake.walkMutex.RLock()
	defer fake.walkMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeFilepath) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ filepathshim.Filepath = new(FakeFilepath)
