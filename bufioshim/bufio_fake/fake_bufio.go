// Code generated by counterfeiter. DO NOT EDIT.
package bufio_fake

import (
	"bufio"
	"io"
	"sync"

	"code.cloudfoundry.org/goshims/bufioshim"
)

type FakeBufio struct {
	NewReadWriterStub        func(*bufio.Reader, *bufio.Writer) *bufio.ReadWriter
	newReadWriterMutex       sync.RWMutex
	newReadWriterArgsForCall []struct {
		arg1 *bufio.Reader
		arg2 *bufio.Writer
	}
	newReadWriterReturns struct {
		result1 *bufio.ReadWriter
	}
	newReadWriterReturnsOnCall map[int]struct {
		result1 *bufio.ReadWriter
	}
	NewReaderStub        func(io.Reader) bufioshim.Reader
	newReaderMutex       sync.RWMutex
	newReaderArgsForCall []struct {
		arg1 io.Reader
	}
	newReaderReturns struct {
		result1 bufioshim.Reader
	}
	newReaderReturnsOnCall map[int]struct {
		result1 bufioshim.Reader
	}
	NewReaderSizeStub        func(io.Reader, int) bufioshim.Reader
	newReaderSizeMutex       sync.RWMutex
	newReaderSizeArgsForCall []struct {
		arg1 io.Reader
		arg2 int
	}
	newReaderSizeReturns struct {
		result1 bufioshim.Reader
	}
	newReaderSizeReturnsOnCall map[int]struct {
		result1 bufioshim.Reader
	}
	NewScannerStub        func(io.Reader) *bufio.Scanner
	newScannerMutex       sync.RWMutex
	newScannerArgsForCall []struct {
		arg1 io.Reader
	}
	newScannerReturns struct {
		result1 *bufio.Scanner
	}
	newScannerReturnsOnCall map[int]struct {
		result1 *bufio.Scanner
	}
	NewWriterStub        func(io.Writer) *bufio.Writer
	newWriterMutex       sync.RWMutex
	newWriterArgsForCall []struct {
		arg1 io.Writer
	}
	newWriterReturns struct {
		result1 *bufio.Writer
	}
	newWriterReturnsOnCall map[int]struct {
		result1 *bufio.Writer
	}
	NewWriterSizeStub        func(io.Writer, int) *bufio.Writer
	newWriterSizeMutex       sync.RWMutex
	newWriterSizeArgsForCall []struct {
		arg1 io.Writer
		arg2 int
	}
	newWriterSizeReturns struct {
		result1 *bufio.Writer
	}
	newWriterSizeReturnsOnCall map[int]struct {
		result1 *bufio.Writer
	}
	ScanBytesStub        func([]byte, bool) (int, []byte, error)
	scanBytesMutex       sync.RWMutex
	scanBytesArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	scanBytesReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	scanBytesReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	ScanLinesStub        func([]byte, bool) (int, []byte, error)
	scanLinesMutex       sync.RWMutex
	scanLinesArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	scanLinesReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	scanLinesReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	ScanRunesStub        func([]byte, bool) (int, []byte, error)
	scanRunesMutex       sync.RWMutex
	scanRunesArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	scanRunesReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	scanRunesReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	ScanWordsStub        func([]byte, bool) (int, []byte, error)
	scanWordsMutex       sync.RWMutex
	scanWordsArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	scanWordsReturns struct {
		result1 int
		result2 []byte
		result3 error
	}
	scanWordsReturnsOnCall map[int]struct {
		result1 int
		result2 []byte
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBufio) NewReadWriter(arg1 *bufio.Reader, arg2 *bufio.Writer) *bufio.ReadWriter {
	fake.newReadWriterMutex.Lock()
	ret, specificReturn := fake.newReadWriterReturnsOnCall[len(fake.newReadWriterArgsForCall)]
	fake.newReadWriterArgsForCall = append(fake.newReadWriterArgsForCall, struct {
		arg1 *bufio.Reader
		arg2 *bufio.Writer
	}{arg1, arg2})
	stub := fake.NewReadWriterStub
	fakeReturns := fake.newReadWriterReturns
	fake.recordInvocation("NewReadWriter", []interface{}{arg1, arg2})
	fake.newReadWriterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBufio) NewReadWriterCallCount() int {
	fake.newReadWriterMutex.RLock()
	defer fake.newReadWriterMutex.RUnlock()
	return len(fake.newReadWriterArgsForCall)
}

func (fake *FakeBufio) NewReadWriterCalls(stub func(*bufio.Reader, *bufio.Writer) *bufio.ReadWriter) {
	fake.newReadWriterMutex.Lock()
	defer fake.newReadWriterMutex.Unlock()
	fake.NewReadWriterStub = stub
}

func (fake *FakeBufio) NewReadWriterArgsForCall(i int) (*bufio.Reader, *bufio.Writer) {
	fake.newReadWriterMutex.RLock()
	defer fake.newReadWriterMutex.RUnlock()
	argsForCall := fake.newReadWriterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) NewReadWriterReturns(result1 *bufio.ReadWriter) {
	fake.newReadWriterMutex.Lock()
	defer fake.newReadWriterMutex.Unlock()
	fake.NewReadWriterStub = nil
	fake.newReadWriterReturns = struct {
		result1 *bufio.ReadWriter
	}{result1}
}

func (fake *FakeBufio) NewReadWriterReturnsOnCall(i int, result1 *bufio.ReadWriter) {
	fake.newReadWriterMutex.Lock()
	defer fake.newReadWriterMutex.Unlock()
	fake.NewReadWriterStub = nil
	if fake.newReadWriterReturnsOnCall == nil {
		fake.newReadWriterReturnsOnCall = make(map[int]struct {
			result1 *bufio.ReadWriter
		})
	}
	fake.newReadWriterReturnsOnCall[i] = struct {
		result1 *bufio.ReadWriter
	}{result1}
}

func (fake *FakeBufio) NewReader(arg1 io.Reader) bufioshim.Reader {
	fake.newReaderMutex.Lock()
	ret, specificReturn := fake.newReaderReturnsOnCall[len(fake.newReaderArgsForCall)]
	fake.newReaderArgsForCall = append(fake.newReaderArgsForCall, struct {
		arg1 io.Reader
	}{arg1})
	stub := fake.NewReaderStub
	fakeReturns := fake.newReaderReturns
	fake.recordInvocation("NewReader", []interface{}{arg1})
	fake.newReaderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBufio) NewReaderCallCount() int {
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	return len(fake.newReaderArgsForCall)
}

func (fake *FakeBufio) NewReaderCalls(stub func(io.Reader) bufioshim.Reader) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = stub
}

func (fake *FakeBufio) NewReaderArgsForCall(i int) io.Reader {
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	argsForCall := fake.newReaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBufio) NewReaderReturns(result1 bufioshim.Reader) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = nil
	fake.newReaderReturns = struct {
		result1 bufioshim.Reader
	}{result1}
}

func (fake *FakeBufio) NewReaderReturnsOnCall(i int, result1 bufioshim.Reader) {
	fake.newReaderMutex.Lock()
	defer fake.newReaderMutex.Unlock()
	fake.NewReaderStub = nil
	if fake.newReaderReturnsOnCall == nil {
		fake.newReaderReturnsOnCall = make(map[int]struct {
			result1 bufioshim.Reader
		})
	}
	fake.newReaderReturnsOnCall[i] = struct {
		result1 bufioshim.Reader
	}{result1}
}

func (fake *FakeBufio) NewReaderSize(arg1 io.Reader, arg2 int) bufioshim.Reader {
	fake.newReaderSizeMutex.Lock()
	ret, specificReturn := fake.newReaderSizeReturnsOnCall[len(fake.newReaderSizeArgsForCall)]
	fake.newReaderSizeArgsForCall = append(fake.newReaderSizeArgsForCall, struct {
		arg1 io.Reader
		arg2 int
	}{arg1, arg2})
	stub := fake.NewReaderSizeStub
	fakeReturns := fake.newReaderSizeReturns
	fake.recordInvocation("NewReaderSize", []interface{}{arg1, arg2})
	fake.newReaderSizeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBufio) NewReaderSizeCallCount() int {
	fake.newReaderSizeMutex.RLock()
	defer fake.newReaderSizeMutex.RUnlock()
	return len(fake.newReaderSizeArgsForCall)
}

func (fake *FakeBufio) NewReaderSizeCalls(stub func(io.Reader, int) bufioshim.Reader) {
	fake.newReaderSizeMutex.Lock()
	defer fake.newReaderSizeMutex.Unlock()
	fake.NewReaderSizeStub = stub
}

func (fake *FakeBufio) NewReaderSizeArgsForCall(i int) (io.Reader, int) {
	fake.newReaderSizeMutex.RLock()
	defer fake.newReaderSizeMutex.RUnlock()
	argsForCall := fake.newReaderSizeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) NewReaderSizeReturns(result1 bufioshim.Reader) {
	fake.newReaderSizeMutex.Lock()
	defer fake.newReaderSizeMutex.Unlock()
	fake.NewReaderSizeStub = nil
	fake.newReaderSizeReturns = struct {
		result1 bufioshim.Reader
	}{result1}
}

func (fake *FakeBufio) NewReaderSizeReturnsOnCall(i int, result1 bufioshim.Reader) {
	fake.newReaderSizeMutex.Lock()
	defer fake.newReaderSizeMutex.Unlock()
	fake.NewReaderSizeStub = nil
	if fake.newReaderSizeReturnsOnCall == nil {
		fake.newReaderSizeReturnsOnCall = make(map[int]struct {
			result1 bufioshim.Reader
		})
	}
	fake.newReaderSizeReturnsOnCall[i] = struct {
		result1 bufioshim.Reader
	}{result1}
}

func (fake *FakeBufio) NewScanner(arg1 io.Reader) *bufio.Scanner {
	fake.newScannerMutex.Lock()
	ret, specificReturn := fake.newScannerReturnsOnCall[len(fake.newScannerArgsForCall)]
	fake.newScannerArgsForCall = append(fake.newScannerArgsForCall, struct {
		arg1 io.Reader
	}{arg1})
	stub := fake.NewScannerStub
	fakeReturns := fake.newScannerReturns
	fake.recordInvocation("NewScanner", []interface{}{arg1})
	fake.newScannerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBufio) NewScannerCallCount() int {
	fake.newScannerMutex.RLock()
	defer fake.newScannerMutex.RUnlock()
	return len(fake.newScannerArgsForCall)
}

func (fake *FakeBufio) NewScannerCalls(stub func(io.Reader) *bufio.Scanner) {
	fake.newScannerMutex.Lock()
	defer fake.newScannerMutex.Unlock()
	fake.NewScannerStub = stub
}

func (fake *FakeBufio) NewScannerArgsForCall(i int) io.Reader {
	fake.newScannerMutex.RLock()
	defer fake.newScannerMutex.RUnlock()
	argsForCall := fake.newScannerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBufio) NewScannerReturns(result1 *bufio.Scanner) {
	fake.newScannerMutex.Lock()
	defer fake.newScannerMutex.Unlock()
	fake.NewScannerStub = nil
	fake.newScannerReturns = struct {
		result1 *bufio.Scanner
	}{result1}
}

func (fake *FakeBufio) NewScannerReturnsOnCall(i int, result1 *bufio.Scanner) {
	fake.newScannerMutex.Lock()
	defer fake.newScannerMutex.Unlock()
	fake.NewScannerStub = nil
	if fake.newScannerReturnsOnCall == nil {
		fake.newScannerReturnsOnCall = make(map[int]struct {
			result1 *bufio.Scanner
		})
	}
	fake.newScannerReturnsOnCall[i] = struct {
		result1 *bufio.Scanner
	}{result1}
}

func (fake *FakeBufio) NewWriter(arg1 io.Writer) *bufio.Writer {
	fake.newWriterMutex.Lock()
	ret, specificReturn := fake.newWriterReturnsOnCall[len(fake.newWriterArgsForCall)]
	fake.newWriterArgsForCall = append(fake.newWriterArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	stub := fake.NewWriterStub
	fakeReturns := fake.newWriterReturns
	fake.recordInvocation("NewWriter", []interface{}{arg1})
	fake.newWriterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBufio) NewWriterCallCount() int {
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	return len(fake.newWriterArgsForCall)
}

func (fake *FakeBufio) NewWriterCalls(stub func(io.Writer) *bufio.Writer) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = stub
}

func (fake *FakeBufio) NewWriterArgsForCall(i int) io.Writer {
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	argsForCall := fake.newWriterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBufio) NewWriterReturns(result1 *bufio.Writer) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = nil
	fake.newWriterReturns = struct {
		result1 *bufio.Writer
	}{result1}
}

func (fake *FakeBufio) NewWriterReturnsOnCall(i int, result1 *bufio.Writer) {
	fake.newWriterMutex.Lock()
	defer fake.newWriterMutex.Unlock()
	fake.NewWriterStub = nil
	if fake.newWriterReturnsOnCall == nil {
		fake.newWriterReturnsOnCall = make(map[int]struct {
			result1 *bufio.Writer
		})
	}
	fake.newWriterReturnsOnCall[i] = struct {
		result1 *bufio.Writer
	}{result1}
}

func (fake *FakeBufio) NewWriterSize(arg1 io.Writer, arg2 int) *bufio.Writer {
	fake.newWriterSizeMutex.Lock()
	ret, specificReturn := fake.newWriterSizeReturnsOnCall[len(fake.newWriterSizeArgsForCall)]
	fake.newWriterSizeArgsForCall = append(fake.newWriterSizeArgsForCall, struct {
		arg1 io.Writer
		arg2 int
	}{arg1, arg2})
	stub := fake.NewWriterSizeStub
	fakeReturns := fake.newWriterSizeReturns
	fake.recordInvocation("NewWriterSize", []interface{}{arg1, arg2})
	fake.newWriterSizeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBufio) NewWriterSizeCallCount() int {
	fake.newWriterSizeMutex.RLock()
	defer fake.newWriterSizeMutex.RUnlock()
	return len(fake.newWriterSizeArgsForCall)
}

func (fake *FakeBufio) NewWriterSizeCalls(stub func(io.Writer, int) *bufio.Writer) {
	fake.newWriterSizeMutex.Lock()
	defer fake.newWriterSizeMutex.Unlock()
	fake.NewWriterSizeStub = stub
}

func (fake *FakeBufio) NewWriterSizeArgsForCall(i int) (io.Writer, int) {
	fake.newWriterSizeMutex.RLock()
	defer fake.newWriterSizeMutex.RUnlock()
	argsForCall := fake.newWriterSizeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) NewWriterSizeReturns(result1 *bufio.Writer) {
	fake.newWriterSizeMutex.Lock()
	defer fake.newWriterSizeMutex.Unlock()
	fake.NewWriterSizeStub = nil
	fake.newWriterSizeReturns = struct {
		result1 *bufio.Writer
	}{result1}
}

func (fake *FakeBufio) NewWriterSizeReturnsOnCall(i int, result1 *bufio.Writer) {
	fake.newWriterSizeMutex.Lock()
	defer fake.newWriterSizeMutex.Unlock()
	fake.NewWriterSizeStub = nil
	if fake.newWriterSizeReturnsOnCall == nil {
		fake.newWriterSizeReturnsOnCall = make(map[int]struct {
			result1 *bufio.Writer
		})
	}
	fake.newWriterSizeReturnsOnCall[i] = struct {
		result1 *bufio.Writer
	}{result1}
}

func (fake *FakeBufio) ScanBytes(arg1 []byte, arg2 bool) (int, []byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.scanBytesMutex.Lock()
	ret, specificReturn := fake.scanBytesReturnsOnCall[len(fake.scanBytesArgsForCall)]
	fake.scanBytesArgsForCall = append(fake.scanBytesArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	stub := fake.ScanBytesStub
	fakeReturns := fake.scanBytesReturns
	fake.recordInvocation("ScanBytes", []interface{}{arg1Copy, arg2})
	fake.scanBytesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBufio) ScanBytesCallCount() int {
	fake.scanBytesMutex.RLock()
	defer fake.scanBytesMutex.RUnlock()
	return len(fake.scanBytesArgsForCall)
}

func (fake *FakeBufio) ScanBytesCalls(stub func([]byte, bool) (int, []byte, error)) {
	fake.scanBytesMutex.Lock()
	defer fake.scanBytesMutex.Unlock()
	fake.ScanBytesStub = stub
}

func (fake *FakeBufio) ScanBytesArgsForCall(i int) ([]byte, bool) {
	fake.scanBytesMutex.RLock()
	defer fake.scanBytesMutex.RUnlock()
	argsForCall := fake.scanBytesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) ScanBytesReturns(result1 int, result2 []byte, result3 error) {
	fake.scanBytesMutex.Lock()
	defer fake.scanBytesMutex.Unlock()
	fake.ScanBytesStub = nil
	fake.scanBytesReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanBytesReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.scanBytesMutex.Lock()
	defer fake.scanBytesMutex.Unlock()
	fake.ScanBytesStub = nil
	if fake.scanBytesReturnsOnCall == nil {
		fake.scanBytesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.scanBytesReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanLines(arg1 []byte, arg2 bool) (int, []byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.scanLinesMutex.Lock()
	ret, specificReturn := fake.scanLinesReturnsOnCall[len(fake.scanLinesArgsForCall)]
	fake.scanLinesArgsForCall = append(fake.scanLinesArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	stub := fake.ScanLinesStub
	fakeReturns := fake.scanLinesReturns
	fake.recordInvocation("ScanLines", []interface{}{arg1Copy, arg2})
	fake.scanLinesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBufio) ScanLinesCallCount() int {
	fake.scanLinesMutex.RLock()
	defer fake.scanLinesMutex.RUnlock()
	return len(fake.scanLinesArgsForCall)
}

func (fake *FakeBufio) ScanLinesCalls(stub func([]byte, bool) (int, []byte, error)) {
	fake.scanLinesMutex.Lock()
	defer fake.scanLinesMutex.Unlock()
	fake.ScanLinesStub = stub
}

func (fake *FakeBufio) ScanLinesArgsForCall(i int) ([]byte, bool) {
	fake.scanLinesMutex.RLock()
	defer fake.scanLinesMutex.RUnlock()
	argsForCall := fake.scanLinesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) ScanLinesReturns(result1 int, result2 []byte, result3 error) {
	fake.scanLinesMutex.Lock()
	defer fake.scanLinesMutex.Unlock()
	fake.ScanLinesStub = nil
	fake.scanLinesReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanLinesReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.scanLinesMutex.Lock()
	defer fake.scanLinesMutex.Unlock()
	fake.ScanLinesStub = nil
	if fake.scanLinesReturnsOnCall == nil {
		fake.scanLinesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.scanLinesReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanRunes(arg1 []byte, arg2 bool) (int, []byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.scanRunesMutex.Lock()
	ret, specificReturn := fake.scanRunesReturnsOnCall[len(fake.scanRunesArgsForCall)]
	fake.scanRunesArgsForCall = append(fake.scanRunesArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	stub := fake.ScanRunesStub
	fakeReturns := fake.scanRunesReturns
	fake.recordInvocation("ScanRunes", []interface{}{arg1Copy, arg2})
	fake.scanRunesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBufio) ScanRunesCallCount() int {
	fake.scanRunesMutex.RLock()
	defer fake.scanRunesMutex.RUnlock()
	return len(fake.scanRunesArgsForCall)
}

func (fake *FakeBufio) ScanRunesCalls(stub func([]byte, bool) (int, []byte, error)) {
	fake.scanRunesMutex.Lock()
	defer fake.scanRunesMutex.Unlock()
	fake.ScanRunesStub = stub
}

func (fake *FakeBufio) ScanRunesArgsForCall(i int) ([]byte, bool) {
	fake.scanRunesMutex.RLock()
	defer fake.scanRunesMutex.RUnlock()
	argsForCall := fake.scanRunesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) ScanRunesReturns(result1 int, result2 []byte, result3 error) {
	fake.scanRunesMutex.Lock()
	defer fake.scanRunesMutex.Unlock()
	fake.ScanRunesStub = nil
	fake.scanRunesReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanRunesReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.scanRunesMutex.Lock()
	defer fake.scanRunesMutex.Unlock()
	fake.ScanRunesStub = nil
	if fake.scanRunesReturnsOnCall == nil {
		fake.scanRunesReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.scanRunesReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanWords(arg1 []byte, arg2 bool) (int, []byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.scanWordsMutex.Lock()
	ret, specificReturn := fake.scanWordsReturnsOnCall[len(fake.scanWordsArgsForCall)]
	fake.scanWordsArgsForCall = append(fake.scanWordsArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	stub := fake.ScanWordsStub
	fakeReturns := fake.scanWordsReturns
	fake.recordInvocation("ScanWords", []interface{}{arg1Copy, arg2})
	fake.scanWordsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBufio) ScanWordsCallCount() int {
	fake.scanWordsMutex.RLock()
	defer fake.scanWordsMutex.RUnlock()
	return len(fake.scanWordsArgsForCall)
}

func (fake *FakeBufio) ScanWordsCalls(stub func([]byte, bool) (int, []byte, error)) {
	fake.scanWordsMutex.Lock()
	defer fake.scanWordsMutex.Unlock()
	fake.ScanWordsStub = stub
}

func (fake *FakeBufio) ScanWordsArgsForCall(i int) ([]byte, bool) {
	fake.scanWordsMutex.RLock()
	defer fake.scanWordsMutex.RUnlock()
	argsForCall := fake.scanWordsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBufio) ScanWordsReturns(result1 int, result2 []byte, result3 error) {
	fake.scanWordsMutex.Lock()
	defer fake.scanWordsMutex.Unlock()
	fake.ScanWordsStub = nil
	fake.scanWordsReturns = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) ScanWordsReturnsOnCall(i int, result1 int, result2 []byte, result3 error) {
	fake.scanWordsMutex.Lock()
	defer fake.scanWordsMutex.Unlock()
	fake.ScanWordsStub = nil
	if fake.scanWordsReturnsOnCall == nil {
		fake.scanWordsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 []byte
			result3 error
		})
	}
	fake.scanWordsReturnsOnCall[i] = struct {
		result1 int
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBufio) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.newReadWriterMutex.RLock()
	defer fake.newReadWriterMutex.RUnlock()
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	fake.newReaderSizeMutex.RLock()
	defer fake.newReaderSizeMutex.RUnlock()
	fake.newScannerMutex.RLock()
	defer fake.newScannerMutex.RUnlock()
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	fake.newWriterSizeMutex.RLock()
	defer fake.newWriterSizeMutex.RUnlock()
	fake.scanBytesMutex.RLock()
	defer fake.scanBytesMutex.RUnlock()
	fake.scanLinesMutex.RLock()
	defer fake.scanLinesMutex.RUnlock()
	fake.scanRunesMutex.RLock()
	defer fake.scanRunesMutex.RUnlock()
	fake.scanWordsMutex.RLock()
	defer fake.scanWordsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBufio) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ bufioshim.Bufio = new(FakeBufio)
